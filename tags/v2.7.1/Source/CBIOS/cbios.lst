0001   0000             ;__________________________________________________________________________________________________
0002   0000             ;
0003   0000             ;	CBIOS FOR N8VEM
0004   0000             ;
0005   0000             ;	BY ANDREW LYNCH, WITH INPUT FROM MANY SOURCES
0006   0000             ;	ROMWBW ADAPTATION BY WAYNE WARTHEN
0007   0000             ;__________________________________________________________________________________________________
0008   0000             ;
0009   0000             ; The std.asm file contains the majority of the standard equates
0010   0000             ; that describe data structures, magic values and bit fields used 
0011   0000             ; by the CBIOS.
0012   0000             ;
0013   0000             ;
0014   0000             ;
0015   0000             ; IOBYTE INIT
0016   0000             ; CIO ASSIGNMENTS
0017   0000             ; CRT SETUP
0018   0000             ;
0019   0000             
0020   0000             #INCLUDE "std.asm"
0001+  0000             ; ~/RomWBW/branches/s100/Source/std.asm 1/19/2013 dwg - 
0002+  0000             ;
0003+  0000             
0004+  0000             ; The purpose of this file is to define generic symbols and to include
0005+  0000             ; the appropriate std-*.inc file to bring in platform specifics.
0006+  0000             
0007+  0000             ; There are four classes of systems supported by N8VEM.
0008+  0000             ; 1. N8VEM 	Platforms that include ECB interface
0009+  0000             ; 2. ZETA	Genrally N8VEM-like, but no ECB
0010+  0000             ; 3. N8		Generally N8VEM-like bt 180 and extra embedded devices
0011+  0000             ; 4. S100	Assumes Z80 Master CPU Card
0012+  0000             
0013+  0000             ; All the classes require certain generic definitions, and these are
0014+  0000             ; defined here prior to the inclusion of platform specific .inc files.
0015+  0000             
0016+  0000             ; It is unfortunate, but all the possible config items must be defined
0017+  0000             ; here because the config gets read before the specific std-*.inc's
0018+  0000             
0019+  0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0020+  0000             ;
0021+  0000             TRUE		.EQU 	1
0022+  0000             FALSE		.EQU 	0
0023+  0000             ;
0024+  0000             ; PRIMARY HARDWARE PLATFORMS
0025+  0000             ;
0026+  0000             PLT_N8VEM	.EQU	1		; N8VEM ECB Z80 SBC
0027+  0000             PLT_ZETA	.EQU	2		; ZETA Z80 SBC
0028+  0000             PLT_N8		.EQU	3		; N8 (HOME COMPUTER) Z180 SBC
0029+  0000             PLT_MK4		.EQU	4
0030+  0000             PLT_S2I		.EQU	5		; SCSI2IDE
0031+  0000             PLT_S100	.EQU	6		; S100COMPUTERS Z80 based system
0032+  0000             PLT_UNA		.EQU	7		; UNA BIOS
0033+  0000             ;
0034+  0000             ; RAM DISK INITIALIZATION OPTIONS
0035+  0000             ;
0036+  0000             CLR_NEVER	.EQU	0		; NEVER CLEAR RAM DISK
0037+  0000             CLR_AUTO	.EQU	1		; CLEAR RAM DISK IF INVALID DIR ENTRIES
0038+  0000             CLR_ALWAYS	.EQU	2		; ALWAYS CLEAR RAM DISK
0039+  0000             ;
0040+  0000             ; FLOPPY DISK MEDIA SELECTIONS (ID'S MUST BE INDEX OF ENTRY IN FCD_TBL)
0041+  0000             ;
0042+  0000             FDM720		.EQU	0		; 3.5" FLOPPY, 720KB, 2 SIDES, 80 TRKS, 9 SECTORS
0043+  0000             FDM144		.EQU	1		; 3.5" FLOPPY, 1.44MB, 2 SIDES, 80 TRKS, 18 SECTORS
0044+  0000             FDM360		.EQU	2		; 5.25" FLOPPY, 360KB, 2 SIDES, 40 TRKS, 9 SECTORS
0045+  0000             FDM120		.EQU	3		; 5.25" FLOPPY, 1.2MB, 2 SIDES, 80 TRKS, 15 SECTORS
0046+  0000             FDM111		.EQU	4		; 8" FLOPPY, 1.11MB, 2 SIDES, 74 TRKS, 15 SECTORS
0047+  0000             ;
0048+  0000             ; MEDIA ID VALUES
0049+  0000             ;
0050+  0000             MID_NONE	.EQU	0
0051+  0000             MID_MDROM	.EQU	1
0052+  0000             MID_MDRAM	.EQU	2
0053+  0000             MID_RF		.EQU	3
0054+  0000             MID_HD		.EQU	4
0055+  0000             MID_FD720	.EQU	5
0056+  0000             MID_FD144	.EQU	6
0057+  0000             MID_FD360	.EQU	7
0058+  0000             MID_FD120	.EQU	8
0059+  0000             MID_FD111	.EQU	9
0060+  0000             ;
0061+  0000             ; CONSOLE TERMINAL TYPE CHOICES
0062+  0000             ;
0063+  0000             TERM_TTY	.EQU	0
0064+  0000             TERM_ANSI	.EQU	1
0065+  0000             TERM_WYSE	.EQU	2
0066+  0000             TERM_VT52	.EQU	3
0067+  0000             ;
0068+  0000             ; EMULATION TYPES
0069+  0000             ;
0070+  0000             EMUTYP_NONE	.EQU	0
0071+  0000             EMUTYP_TTY	.EQU	1
0072+  0000             EMUTYP_ANSI	.EQU	2
0073+  0000             ;
0074+  0000             ; SYSTEM GENERATION SETTINGS
0075+  0000             ;
0076+  0000             SYS_CPM		.EQU	1		; CPM (IMPLIES BDOS + CCP)
0077+  0000             SYS_ZSYS	.EQU	2		; ZSYSTEM OS (IMPLIES ZSDOS + ZCPR)
0078+  0000             ;
0079+  0000             DOS_BDOS	.EQU	1		; BDOS
0080+  0000             DOS_ZDDOS	.EQU	2		; ZDDOS VARIANT OF ZSDOS
0081+  0000             DOS_ZSDOS	.EQU	3		; ZSDOS
0082+  0000             ;
0083+  0000             CP_CCP		.EQU	1		; CCP COMMAND PROCESSOR
0084+  0000             CP_ZCPR		.EQU	2		; ZCPR COMMAND PROCESSOR
0085+  0000             ;
0086+  0000             ; CONFIGURE DOS (DOS) AND COMMAND PROCESSOR (CP) BASED ON SYSTEM SETTING (SYS)
0087+  0000             ;
0088+  0000             #IFNDEF BLD_SYS
0089+  0000             SYS		.EQU	SYS_CPM
0090+  0000~            #ELSE
0091+  0000~            SYS		.EQU	BLD_SYS
0092+  0000             #ENDIF
0093+  0000             ;
0094+  0000             #IF (SYS == SYS_CPM)
0095+  0000             DOS		.EQU	DOS_BDOS
0096+  0000             CP		.EQU	CP_CCP
0097+  0000             #DEFINE		OSLBL	"CP/M-80 2.2"
0098+  0000             #ENDIF
0099+  0000             ;
0100+  0000~            #IF (SYS == SYS_ZSYS)
0101+  0000~            DOS		.EQU	DOS_ZSDOS
0102+  0000~            CP		.EQU	CP_ZCPR
0103+  0000~            #DEFINE		OSLBL	"ZSDOS 1.1"
0104+  0000             #ENDIF
0105+  0000             ;
0106+  0000             ; INCLUDE VERSION AND BUILD SETTINGS
0107+  0000             ;
0108+  0000             #INCLUDE "ver.inc"			; ADD BIOSVER
0001++ 0000             #DEFINE	RMJ	2
0002++ 0000             #DEFINE	RMN	7
0003++ 0000             #DEFINE	RUP	0
0004++ 0000             #DEFINE	RTP	0
0005++ 0000             #DEFINE BIOSVER	"2.7.0"
0006++ 0000             #DEFINE BIOSBLD "Build 0 Developmental"
0007++ 0000             #DEFINE REVISION 500
0109+  0000             ;
0110+  0000             #INCLUDE "build.inc"			; INCLUDE USER CONFIG, ADD VARIANT, TIMESTAMP, & ROMSIZE
0001++ 0000             ; RomWBW Configured for N8VEM simh, 2015-02-14T09:50:52
0002++ 0000             ;
0003++ 0000             #DEFINE		TIMESTAMP	"14-Feb-2015"
0004++ 0000             ;
0005++ 0000             PLATFORM	.EQU		PLT_N8VEM		; HARDWARE PLATFORM
0006++ 0000             ROMSIZE		.EQU		512		; SIZE OF ROM IN KB
0007++ 0000             ;
0008++ 0000             ; INCLUDE PLATFORM SPECIFIC DEVICE DEFINITIONS
0009++ 0000             ;
0010++ 0000             #INCLUDE "std-n8vem.inc"
0001+++0000             ;
0002+++0000             ; CHARACTER DEVICES
0003+++0000             ;
0004+++0000             CIODEV_UART	.EQU	$00
0005+++0000             CIODEV_ASCI	.EQU	$10
0006+++0000             CIODEV_VDU	.EQU	$20
0007+++0000             CIODEV_CVDU	.EQU	$30
0008+++0000             CIODEV_UPD7220	.EQU	$40
0009+++0000             CIODEV_N8V	.EQU	$50
0010+++0000             CIODEV_PRPCON	.EQU	$60
0011+++0000             CIODEV_PPPCON	.EQU	$70
0012+++0000             CIODEV_CONSOLE	.EQU	$C0
0013+++0000             CIODEV_CRT	.EQU	$D0
0014+++0000             CIODEV_BAT	.EQU	$E0
0015+++0000             CIODEV_NUL	.EQU	$F0
0016+++0000             ;
0017+++0000             ; DISK DEVICES (ONLY FIRST NIBBLE RELEVANT, SECOND NIBBLE RESERVED FOR UNIT)
0018+++0000             ;
0019+++0000             DIODEV_MD	.EQU	$00
0020+++0000             DIODEV_FD	.EQU	$10
0021+++0000             DIODEV_RF	.EQU	$20
0022+++0000             DIODEV_IDE	.EQU	$30
0023+++0000             DIODEV_ATAPI	.EQU	$40
0024+++0000             DIODEV_PPIDE	.EQU	$50
0025+++0000             DIODEV_SD	.EQU	$60
0026+++0000             DIODEV_PRPSD	.EQU	$70
0027+++0000             DIODEV_PPPSD	.EQU	$80
0028+++0000             DIODEV_HDSK	.EQU	$90
0029+++0000             ;
0030+++0000             ; VDA DEVICES (VIDEO DISPLAY ADAPTER)
0031+++0000             ;
0032+++0000             VDADEV_NONE	.EQU	$00		; NO VDA DEVICE
0033+++0000             VDADEV_VDU	.EQU	$10		; ECB VDU - 6545 CHIP
0034+++0000             VDADEV_CVDU	.EQU	$20		; ECB COLOR VDU - 8563 CHIP (NOT IMP)
0035+++0000             VDADEV_UPD7220	.EQU	$30		; ECB uP7220 (NOT IMPLEMENTED)
0036+++0000             VDADEV_N8V	.EQU	$40		; N8 ONBOARD VDA SUBSYSTEM
0011++ 0000             ;
0012++ 0000             #INCLUDE "config.asm"
0001+++0000             ;
0002+++0000             ;==================================================================================================
0003+++0000             ;   ROMWBW 2.X CONFIGURATION FOR SIMH EMULATOR
0004+++0000             ;==================================================================================================
0005+++0000             ;
0006+++0000             ; BUILD CONFIGURATION OPTIONS
0007+++0000             ;
0008+++0000             DEFCON		.EQU	CIODEV_UART	; DEFAULT CONSOLE DEVICE (LOADER AND MONITOR): CIODEV_UART, CIODEV_CRT, CIODEV_PRPCON, CIODEV_PPPCON
0009+++0000             ;
0010+++0000             RAMSIZE		.EQU	512		; SIZE OF RAM IN KB, MUST MATCH YOUR HARDWARE!!!
0011+++0000             CLRRAMDISK	.EQU	CLR_ALWAYS	; CLR_ALWAYS, CLR_NEVER, CLR_AUTO (CLEAR IF INVALID DIR AREA)
0012+++0000             ;
0013+++0000             ;DSKYENABLE	.EQU	FALSE		; TRUE FOR DSKY SUPPORT (DO NOT COMBINE WITH PPIDE)
0014+++0000             ;
0015+++0000             DEFIOBYTE	.EQU	$00		; DEFAULT INITIAL VALUE FOR CP/M IOBYTE, $00=TTY, $01=CRT (MUST HAVE CRT HARDWARE)
0016+++0000             ALTIOBYTE	.EQU	DEFIOBYTE	; ALT INITIAL VALUE (USED WHEN CONFIG JUMPER SHORTED)
0017+++0000             WRTCACHE	.EQU	TRUE		; ENABLE WRITE CACHING IN CBIOS (DE)BLOCKING ALGORITHM
0018+++0000             DSKTRACE	.EQU	FALSE		; ENABLE TRACING OF CBIOS DISK FUNCTION CALLS
0019+++0000             ;
0020+++0000             #DEFINE		AUTOCMD	""		; AUTO STARTUP COMMAND FOR CP/M
0013++ 0000             ;
0111+  0000             ;
0112+  0000             ; INCLUDE PLATFORM SPECIFIC HARDWARE DEFINITIONS
0113+  0000             ;
0114+  0000             #IF ((PLATFORM == PLT_N8VEM) | (PLATFORM == PLT_ZETA))
0115+  0000             #INCLUDE "n8vem.inc"
0001++ 0000             ;
0002++ 0000             ; N8VEM HARDWARE IO PORT ADDRESSES AND MEMORY LOCATIONS
0003++ 0000             ;
0004++ 0000             RTC		.EQU	$70		; ADDRESS OF RTC LATCH AND INPUT PORT
0005++ 0000             ;
0006++ 0000             ; MEMORY BANK CONFIGURATION
0007++ 0000             ;
0008++ 0000             BID_ROM0	.EQU	$00
0009++ 0000             BID_ROMN	.EQU	(BID_ROM0 + ((ROMSIZE / 32) - 1))
0010++ 0000             BID_RAM0	.EQU	$80
0011++ 0000             BID_RAMN	.EQU	(BID_RAM0 + ((RAMSIZE / 32) - 1))
0012++ 0000             
0013++ 0000             BID_BOOT	.EQU	BID_ROM0	; BOOT BANK
0014++ 0000             BID_BIOSIMG	.EQU	BID_ROM0 + 1	; BIOS IMAGE BANK
0015++ 0000             BID_OSIMG	.EQU	BID_ROM0 + 2	; ROM LOADER AND IMAGES BANK
0016++ 0000             BID_FSFAT	.EQU	BID_ROM0 + 3	; FAT FILESYSTEM DRIVER BANK
0017++ 0000             BID_ROMD0	.EQU	BID_ROM0 + 4	; FIRST ROM DRIVE BANK
0018++ 0000             BID_ROMDN	.EQU	BID_ROMN	; LAST ROM DRIVE BANK
0019++ 0000             
0020++ 0000             BID_RAMD0	.EQU	BID_RAM0	; FIRST RAM DRIVE BANK
0021++ 0000             BID_RAMDN	.EQU	BID_RAMN - 4	; LAST RAM DRIVE BANK
0022++ 0000             BID_AUX		.EQU	BID_RAMN - 3	; AUX BANK (BPBIOS, ETC.)
0023++ 0000             BID_BIOS	.EQU	BID_RAMN - 2	; BIOS BANK
0024++ 0000             BID_USR		.EQU	BID_RAMN - 1	; USER BANK (CP/M TPA, ETC.)
0025++ 0000             BID_COM		.EQU	BID_RAMN	; COMMON BANK, UPPER 32K
0116+  0000             #ENDIF
0117+  0000             ;
0118+  0000~            #IF (PLATFORM == PLT_S2I)
0119+  0000~            #INCLUDE "s2i.inc"
0120+  0000             #ENDIF
0121+  0000             ;
0122+  0000~            #IF (PLATFORM == PLT_N8)
0123+  0000~            #INCLUDE "n8.inc"
0124+  0000             #ENDIF
0125+  0000             ;
0126+  0000~            #IF (PLATFORM == PLT_MK4)
0127+  0000~            #INCLUDE "mk4.inc"
0128+  0000             #ENDIF
0129+  0000             ;
0130+  0000~            #IF (PLATFORM == PLT_UNA)
0131+  0000~            #INCLUDE "una.inc"
0132+  0000             #ENDIF
0133+  0000             ;
0134+  0000             ; CHARACTER DEVICE FUNCTIONS
0135+  0000             ;
0136+  0000             CF_INIT		.EQU	0
0137+  0000             CF_IN		.EQU	1
0138+  0000             CF_IST		.EQU	2
0139+  0000             CF_OUT		.EQU	3
0140+  0000             CF_OST		.EQU	4
0141+  0000             ;
0142+  0000             ; DISK OPERATIONS
0143+  0000             ;
0144+  0000             DOP_READ	.EQU	0		; READ OPERATION
0145+  0000             DOP_WRITE	.EQU	1		; WRITE OPERATION
0146+  0000             DOP_FORMAT	.EQU	2		; FORMAT OPERATION
0147+  0000             DOP_READID	.EQU	3		; READ ID OPERATION
0148+  0000             ;
0149+  0000             ; BIOS FUNCTIONS
0150+  0000             ;
0151+  0000~            #IF (PLATFORM == PLT_UNA)
0152+  0000~            BF_CIO		.EQU	$10
0153+  0000~            BF_CIOIN	.EQU	BF_CIO + 1	; CHARACTER INPUT
0154+  0000~            BF_CIOOUT	.EQU	BF_CIO + 2	; CHARACTER OUTPUT
0155+  0000~            BF_CIOIST	.EQU	BF_CIO + 3	; CHARACTER INPUT STATUS
0156+  0000~            BF_CIOOST	.EQU	BF_CIO + 4	; CHARACTER OUTPUT STATUS
0157+  0000~            ;
0158+  0000~            BF_DIO		.EQU	$40
0159+  0000~            BF_DIORD	.EQU	BF_DIO + 2	; DISK READ
0160+  0000~            BF_DIOWR	.EQU	BF_DIO + 3	; DISK WRITE
0161+  0000             #ELSE
0162+  0000             BF_CIO		.EQU	$00
0163+  0000             BF_CIOIN	.EQU	BF_CIO + 0	; CHARACTER INPUT
0164+  0000             BF_CIOOUT	.EQU	BF_CIO + 1	; CHARACTER OUTPUT
0165+  0000             BF_CIOIST	.EQU	BF_CIO + 2	; CHARACTER INPUT STATUS
0166+  0000             BF_CIOOST	.EQU	BF_CIO + 3	; CHARACTER OUTPUT STATUS
0167+  0000             BF_CIOCFG	.EQU	BF_CIO + 4	; CHARACTER I/O CONFIG
0168+  0000             ;
0169+  0000             BF_DIO		.EQU	$10
0170+  0000             BF_DIORD	.EQU	BF_DIO + 0	; DISK READ
0171+  0000             BF_DIOWR	.EQU	BF_DIO + 1	; DISK WRITE
0172+  0000             BF_DIOST	.EQU	BF_DIO + 2	; DISK STATUS
0173+  0000             BF_DIOMED	.EQU	BF_DIO + 3	; DISK MEDIA
0174+  0000             BF_DIOID	.EQU	BF_DIO + 4	; DISK IDENTIFY
0175+  0000             BF_DIOGETBUF	.EQU	BF_DIO + 8	; DISK GET BUFFER ADR
0176+  0000             BF_DIOSETBUF	.EQU	BF_DIO + 9	; DISK SET BUFFER ADR
0177+  0000             BF_DIODEVCNT	.EQU	BF_DIO + 10	; DISK DEVICE COUNT
0178+  0000             BF_DIODEVINF	.EQU	BF_DIO + 11	; DISK DEVICE INFO
0179+  0000             ;
0180+  0000             BF_RTC		.EQU	$20
0181+  0000             BF_RTCGETTIM	.EQU	BF_RTC + 0	; GET TIME
0182+  0000             BF_RTCSETTIM	.EQU	BF_RTC + 1	; SET TIME
0183+  0000             BF_RTCGETBYT	.EQU	BF_RTC + 2	; GET NVRAM BYTE BY INDEX
0184+  0000             BF_RTCSETBYT	.EQU	BF_RTC + 3	; SET NVRAM BYTE BY INDEX
0185+  0000             BF_RTCGETBLK	.EQU	BF_RTC + 4	; GET NVRAM DATA BLOCK
0186+  0000             BF_RTCSETBLK	.EQU	BF_RTC + 5	; SET NVRAM DATA BLOCK
0187+  0000             ;
0188+  0000             BF_EMU		.EQU	$30
0189+  0000             BF_EMUIN	.EQU	BF_EMU + 0	; EMULATOR CHARACTER INPUT
0190+  0000             BF_EMUOUT	.EQU	BF_EMU + 1	; EMULATOR CHARACTER OUTPUT
0191+  0000             BF_EMUIST	.EQU	BF_EMU + 2	; EMULATOR CHARACTER INPUT STATUS
0192+  0000             BF_EMUOST	.EQU	BF_EMU + 3	; EMULATOR CHARACTER OUTPUT STATUS
0193+  0000             BF_EMUCFG	.EQU	BF_EMU + 4	; EMULATOR CHARACTER I/O CONFIG
0194+  0000             BF_EMUINI	.EQU	BF_EMU + 8	; INITIALIZE EMULATION
0195+  0000             BF_EMUQRY	.EQU	BF_EMU + 9	; QUERY EMULATION STATUS
0196+  0000             ;
0197+  0000             BF_VDA		.EQU	$40
0198+  0000             BF_VDAINI	.EQU	BF_VDA + 0	; INITIALIZE VDU
0199+  0000             BF_VDAQRY	.EQU	BF_VDA + 1	; QUERY VDU STATUS
0200+  0000             BF_VDARES	.EQU	BF_VDA + 2	; SOFT RESET VDU
0201+  0000             BF_VDASCS	.EQU	BF_VDA + 3	; SET CURSOR STYLE
0202+  0000             BF_VDASCP	.EQU	BF_VDA + 4	; SET CURSOR POSITION
0203+  0000             BF_VDASAT	.EQU	BF_VDA + 5	; SET CHARACTER ATTRIBUTE
0204+  0000             BF_VDASCO	.EQU	BF_VDA + 6	; SET CHARACTER COLOR
0205+  0000             BF_VDAWRC	.EQU	BF_VDA + 7	; WRITE CHARACTER
0206+  0000             BF_VDAFIL	.EQU	BF_VDA + 8	; FILL
0207+  0000             BF_VDACPY	.EQU	BF_VDA + 9	; COPY
0208+  0000             BF_VDASCR	.EQU	BF_VDA + 10	; SCROLL
0209+  0000             BF_VDAKST	.EQU	BF_VDA + 11	; GET KEYBOARD STATUS
0210+  0000             BF_VDAKFL	.EQU	BF_VDA + 12	; FLUSH KEYBOARD BUFFER
0211+  0000             BF_VDAKRD	.EQU	BF_VDA + 13	; READ KEYBOARD
0212+  0000             ;
0213+  0000             BF_SYS		.EQU	$F0
0214+  0000             BF_SYSSETBNK	.EQU	BF_SYS + 0	; SET CURRENT BANK
0215+  0000             BF_SYSGETBNK	.EQU	BF_SYS + 1	; GET CURRENT BANK
0216+  0000             BF_SYSCPY	.EQU	BF_SYS + 2	; COPY TO/FROM RAM/ROM MEMORY BANK
0217+  0000             BF_SYSXCPY	.EQU	BF_SYS + 3	; EXTENDED COPY SETUP
0218+  0000             BF_SYSATTR	.EQU	BF_SYS + 4	; GET/SET SYSTEM ATTRIBUTE VALUE
0219+  0000             ;BF_SYSXXXX	.EQU	BF_SYS + 5	; 
0220+  0000             BF_SYSGETVER	.EQU	BF_SYS + 6	; GET VERSION OF HBIOS
0221+  0000             #ENDIF
0222+  0000             ;	
0223+  0000             ; SYSTEM ATTRIBUTE IDS
0224+  0000             ;
0225+  0000             AID_BOOTVOL	.EQU	0		; BOOT VOLUME, MSB=DEV/UNIT, LSB=LU
0226+  0000             AID_BOOTROM	.EQU	0		; BANK ID OF ROM PAGE BOOTED
0227+  0000             ;
0228+  0000             ; MEMORY LAYOUT
0229+  0000             ;
0230+  0000             SYS_SIZ		.EQU	$3000			; COMBINED SIZE OF SYSTEM AREA (OS + HBIOS PROXY)
0231+  0000             HBBUF_SIZ	.EQU	1024			; INVARIANT HBIOS PHYSICAL DISK BUFFER, 1K
0232+  0000             HBX_SIZ		.EQU	$200			; HBIOS PROXY SIZE (SUBJECT TO CHANGE)
0233+  0000             CPM_SIZ		.EQU	SYS_SIZ - HBX_SIZ	; NET SIZE OF ALL OS COMPONENTS (EXCLUDING HBIOS PROXY)
0234+  0000             CCP_SIZ		.EQU	$800			; INVARIANT SIZE OF CCP
0235+  0000             BDOS_SIZ	.EQU	$E00			; INVARIANT SIZE OF BDOS
0236+  0000             CBIOS_SIZ	.EQU	CPM_SIZ - CCP_SIZ - BDOS_SIZ	; CBIOS IS THE REMAINDER
0237+  0000             
0238+  0000             MEMTOP		.EQU	$10000			; INVARIANT TOP OF Z80 ADDRESSABLE MEMORY
0239+  0000             BNKTOP		.EQU	$8000			; BANK MEMORY BARRIER
0240+  0000             
0241+  0000             HBBUF_IMG	.EQU	BNKTOP - HBBUF_SIZ	; LOC OF DISK BUFFER IN HBIOS IMAGE BANK
0242+  0000             HBX_IMG		.EQU	BNKTOP - HBX_SIZ	; LOC OF HBX IMAGE IN HBIOS IMAGE BANK
0243+  0000             
0244+  0000             HBBUF_END	.EQU	BNKTOP			; END OF PHYSICAL DISK BUFFER IN HBIOS
0245+  0000             HBBUF_LOC	.EQU	HBBUF_END - HBBUF_SIZ	; START OF PHYSICAL DISK BUFFER
0246+  0000             HBX_END		.EQU	MEMTOP			; END OF HBIOS PROXY
0247+  0000             HBX_LOC		.EQU	HBX_END - HBX_SIZ	; START OF HBIOS PROXY
0248+  0000             CPM_END		.EQU	HBX_LOC			; END OF CPM COMPONENTS (INCLUDING CBIOS)
0249+  0000             CPM_LOC		.EQU	CPM_END - CPM_SIZ	; START OF CPM COMPONENTS
0250+  0000             CBIOS_END	.EQU	HBX_LOC			; END OF CBIOS
0251+  0000             CBIOS_LOC	.EQU	CBIOS_END - CBIOS_SIZ	; START OF CBIOS
0252+  0000             BDOS_END	.EQU	CBIOS_LOC		; END OF BDOS
0253+  0000             BDOS_LOC	.EQU	BDOS_END - BDOS_SIZ	; START OF BDOS
0254+  0000             CCP_END		.EQU	BDOS_LOC		; END OF CCP
0255+  0000             CCP_LOC		.EQU	CCP_END - CCP_SIZ	; START OF CCP
0256+  0000             
0257+  0000             CPM_ENT		.EQU	CBIOS_LOC		; CPM ENTRY POINT (IN CBIOS)
0258+  0000             CCP_ENT		.EQU	CPM_LOC			; COMMAND PROCESSOR ENTRY POINT (IN CCP)
0259+  0000             
0260+  0000             MON_LOC		.EQU	$C000			; LOCATION OF MONITOR FOR RUNNING SYSTEM
0261+  0000             MON_SIZ		.EQU	$1000			; SIZE OF MONITOR BINARY IMAGE
0262+  0000             MON_END		.EQU	MON_LOC + MON_SIZ	; END OF MONITOR
0263+  0000             
0264+  0000             MON_DSKY	.EQU	MON_LOC + (0 * 3)	; MONITOR ENTRY (DSKY)
0265+  0000             MON_SERIAL	.EQU	MON_LOC + (1 * 3)	; MONITOR ENTRY (SERIAL PORT)
0266+  0000             
0267+  0000             CBIOS_BOOT	.EQU	CBIOS_LOC + (0 * 3)
0268+  0000             CBIOS_WBOOT	.EQU	CBIOS_LOC + (1 * 3)
0269+  0000             CBIOS_CONST	.EQU	CBIOS_LOC + (2 * 3)
0270+  0000             CBIOS_CONIN	.EQU	CBIOS_LOC + (3 * 3)
0271+  0000             CBIOS_CONOUT	.EQU	CBIOS_LOC + (4 * 3)
0272+  0000             CBIOS_LIST	.EQU	CBIOS_LOC + (5 * 3)
0273+  0000             CBIOS_PUNCH	.EQU	CBIOS_LOC + (6 * 3)
0274+  0000             CBIOS_READER	.EQU	CBIOS_LOC + (7 * 3)
0275+  0000             CBIOS_HOME	.EQU	CBIOS_LOC + (8 * 3)
0276+  0000             CBIOS_SELDSK	.EQU	CBIOS_LOC + (9 * 3)
0277+  0000             CBIOS_SETTRK	.EQU	CBIOS_LOC + (10 * 3)
0278+  0000             CBIOS_SETSEC	.EQU	CBIOS_LOC + (11 * 3)
0279+  0000             CBIOS_SETDMA	.EQU	CBIOS_LOC + (12 * 3)
0280+  0000             CBIOS_READ	.EQU	CBIOS_LOC + (13 * 3)
0281+  0000             CBIOS_WRITE	.EQU	CBIOS_LOC + (14 * 3)
0282+  0000             CBIOS_LISTST	.EQU	CBIOS_LOC + (15 * 3)
0283+  0000             CBIOS_SECTRN	.EQU	CBIOS_LOC + (16 * 3)
0284+  0000             ;
0285+  0000             CDISK:	 	.EQU 	4	; LOC IN PAGE 0 OF CURRENT DISK NUMBER 0=A,...,15=P
0286+  0000             IOBYTE:	 	.EQU 	3	; LOC IN PAGE 0 OF I/O DEFINITION BYTE
0287+  0000             ;
0288+  0000             ; HBIOS PROXY COMMON DATA BLOCK
0289+  0000             ; EXACTLY 32 BYTES AT $FFE0-$FFFF
0290+  0000             ;
0291+  0000             HBX_XFC		.EQU	$10000 - $20		; HBIOS PROXY INTERFACE AREA, 32 BYTES FIXED
0292+  0000             ;
0293+  0000             HBX_XFCDAT	.EQU	HBX_XFC			; DATA PORTION OF HBIOX PROXY INTERFACE AREA
0294+  0000             HB_CURBNK	.EQU	HBX_XFCDAT + 0		; CURRENTLY ACTIVE LOW MEMORY BANK ID
0295+  0000             HB_PRVBNK	.EQU	HBX_XFCDAT + 1		; PREVIOUS BANK (BANK SELECTED PRIOR TO CURRENT BANK)
0296+  0000             HB_SRCADR	.EQU	HBX_XFCDAT + 2		; BNKCPY: DESTINATION BANK ID
0297+  0000             HB_SRCBNK	.EQU	HBX_XFCDAT + 4		; BNKCPY: SOURCE BANK ID
0298+  0000             HB_DSTADR	.EQU	HBX_XFCDAT + 5		; BNKCPY: DESTINATION ADDRESS
0299+  0000             HB_DSTBNK	.EQU	HBX_XFCDAT + 7		; BNKCPY: SOURCE ADDRESS
0300+  0000             HB_CNT		.EQU	HBX_XFCDAT + 8		; BNKCPY: COUNT
0301+  0000             ;
0302+  0000             HBX_XFCFNS	.EQU	HBX_XFC + $10		; JUMP TABLE PORTION OF HBIOS PROXY INTERFACE AREA
0303+  0000             HB_INVOKE	.EQU	HBX_XFCFNS + (0 * 3)	; INVOKE HBIOS FUNCTION
0304+  0000             HB_BNKSEL	.EQU	HBX_XFCFNS + (1 * 3)	; SELECT LOW MEMORY BANK ID
0305+  0000             HB_BNKCPY	.EQU	HBX_XFCFNS + (2 * 3)	; INTERBANK MEMORY COPY
0306+  0000             HB_BNKCALL	.EQU	HBX_XFCFNS + (3 * 3)	; INTERBANK FUNCTION CALL
0307+  0000             HB_LOC		.EQU	HBX_XFCFNS + 12		; ADDRESS OF HBIOS PROXY START
0308+  0000             HB_IDENT	.EQU	HBX_XFCFNS + 14		; POINTER TO HBIOS IDENT DATA BLOCK
0021   0000             ;
0022   E600                  	.ORG	CBIOS_LOC		; DEFINED IN STD.ASM
0023   E600             ;
0024   E600             STACK	.EQU	CBIOS_END		; USE SLACK SPACE FOR STACK AS NEEDED
0025   E600             ;
0026   E600             ;==================================================================================================
0027   E600             ;	CP/M JUMP VECTOR TABLE FOR INDIVIDUAL SUBROUTINES
0028   E600             ;==================================================================================================
0029   E600             ; These jumps are defined in the CP/M-80 v2.2 system guide and comprise
0030   E600             ; the invariant part of the BIOS.
0031   E600             ;
0032   E600 C3 65 E6    	JP	BOOT			; #0  - COLD START
0033   E603 C3 7F E6    WBOOTE	JP	WBOOT			; #1  - WARM START
0034   E606 C3 E4 E6    	JP	CONST			; #2  - CONSOLE STATUS
0035   E609 C3 EB E6    	JP	CONIN			; #3  - CONSOLE CHARACTER IN
0036   E60C C3 F2 E6    	JP	CONOUT			; #4  - CONSOLE CHARACTER OUT
0037   E60F C3 FD E6    	JP	LIST			; #5  - LIST CHARACTER OUT
0038   E612 C3 13 E7    	JP	PUNCH			; #6  - PUNCH CHARACTER OUT
0039   E615 C3 24 E7    	JP	READER			; #7  - READER CHARACTER IN
0040   E618 C3 93 E7    	JP	HOME			; #8  - MOVE HEAD TO HOME POSITION
0041   E61B C3 90 E7    	JP	SELDSK			; #9  - SELECT DISK
0042   E61E C3 9F E7    	JP	SETTRK			; #10 - SET TRACK NUMBER
0043   E621 C3 A4 E7    	JP	SETSEC			; #11 - SET SECTOR NUMBER
0044   E624 C3 AC E7    	JP	SETDMA			; #12 - SET DMA ADDRESS
0045   E627 C3 B1 E7    	JP	READ			; #13 - READ DISK
0046   E62A C3 B5 E7    	JP	WRITE			; #14 - WRITE DISK
0047   E62D C3 03 E7    	JP	LISTST			; #15 - RETURN LIST STATUS
0048   E630 C3 A9 E7    	JP	SECTRN			; #16 - SECTOR TRANSLATE
0049   E633             ;
0050   E633             ;==================================================================================================
0051   E633             ;   CBIOS STAMP FOR ROMWBW
0052   E633             ;==================================================================================================
0053   E633             ;
0054   E633             ; RomWBW CBIOS places the following stamp data into page zero
0055   E633             ; at address $40.  The address range $40-$4F is reserved by CP/M
0056   E633             ; as a scratch area for CBIOS.  This data below is copied there at
0057   E633             ; every warm start.  It allows applications to identify RomWBW CBIOS.
0058   E633             ; Additionally, it contains a pointer to additional CBIOS extension
0059   E633             ; data (CBX) specific to RomWBW CBIOS.
0060   E633             ;
0061   E633             ; RomWBW CBIOS page zero stamp starts at $40
0062   E633             ; $40-$41: Marker ('W', ~'W')
0063   E633             ; $42-$43: Version bytes: major/minor, update/patch
0064   E633             ; $44-$45: CBIOS Extension Info address
0065   E633             ;
0066   E633             STPLOC	.EQU	$40
0067   E633 57 A8       STPIMG:	.DB	'W',~'W'		; MARKER
0068   E635 27          	.DB	RMJ << 4 | RMN		; FIRST BYTE OF VERSION INFO
0069   E636 00          	.DB	RUP << 4 | RTP		; SECOND BYTE OF VERSION INFO
0070   E637 39 E6       	.DW	CBX			; ADDRESS OF CBIOS EXT DATA
0071   E639             STPSIZ	.EQU	$ - STPIMG
0072   E639             ;
0073   E639             ; The following section contains key information and addresses for the
0074   E639             ; RomWBW CBIOS.  A pointer to the start of this section is stored with
0075   E639             ; with the ZPX data in page zero at $44 (see above).
0076   E639             ;
0077   E639             CBX:
0078   E639 40 E6       DEVMAPADR	.DW	DEVMAP		; DEVICE MAP ADDRESS
0079   E63B 00 00       DRVMAPADR	.DW	0		; DRIVE MAP ADDRESS (FILLED IN LATER)
0080   E63D 51 E6       DPBMAPADR	.DW	DPBMAP		; DPB MAP ADDRESS
0081   E63F             ;
0082   E63F             CBXSIZ	.EQU	$ - CBX
0083   E63F             	.ECHO	"CBIOS extension info occupies "
0084   E63F             	.ECHO	CBXSIZ
0085   E63F             	.ECHO	" bytes.\n"
0086   E63F             ;
0087   E63F             ;==================================================================================================
0088   E63F             ; CHARACTER DEVICE MAPPING
0089   E63F             ;==================================================================================================
0090   E63F             ;
0091   E63F             ;	MAP LOGICAL CHARACTER DEVICES TO PHYSICAL CHARACTER DEVICES
0092   E63F             ;
0093   E63F~            #IF (PLATFORM == PLT_UNA)
0094   E63F~            
0095   E63F~            LD_TTY	.EQU	0
0096   E63F~            LD_CRT	.EQU	0
0097   E63F~            LD_BAT	.EQU	CIODEV_BAT
0098   E63F~            LD_UC1	.EQU	0
0099   E63F~            LD_PTR	.EQU	0
0100   E63F~            LD_UR1	.EQU	0
0101   E63F~            LD_UR2	.EQU	0
0102   E63F~            LD_PTP	.EQU	0
0103   E63F~            LD_UP1	.EQU	0
0104   E63F~            LD_UP2	.EQU	0
0105   E63F~            LD_LPT	.EQU	0
0106   E63F~            LD_UL1	.EQU	0
0107   E63F~            
0108   E63F             #ELSE
0109   E63F             
0110   E63F~            #IF ((PLATFORM == PLT_N8) | (PLATFORM == PLT_MK4))
0111   E63F~            TTYDEV	.EQU	CIODEV_ASCI
0112   E63F             #ELSE
0113   E63F             TTYDEV	.EQU	CIODEV_UART
0114   E63F             #ENDIF
0115   E63F             ;
0116   E63F             LD_TTY	.EQU	TTYDEV
0117   E63F             LD_CRT	.EQU	TTYDEV
0118   E63F             LD_BAT	.EQU	CIODEV_BAT
0119   E63F             LD_UC1	.EQU	TTYDEV
0120   E63F             LD_PTR	.EQU	TTYDEV
0121   E63F             LD_UR1	.EQU	TTYDEV
0122   E63F             LD_UR2	.EQU	TTYDEV
0123   E63F             LD_PTP	.EQU	TTYDEV
0124   E63F             LD_UP1	.EQU	TTYDEV
0125   E63F             LD_UP2	.EQU	TTYDEV
0126   E63F             LD_LPT	.EQU	TTYDEV
0127   E63F             LD_UL1	.EQU	TTYDEV
0128   E63F             ;;
0129   E63F             ;#IF ((PLATFORM == PLT_N8) | (PLATFORM == PLT_MK4))
0130   E63F             ;LD_UC1	.SET	CIODEV_ASCI + 1
0131   E63F             ;LD_PTR	.SET	CIODEV_ASCI + 1
0132   E63F             ;LD_PTP	.SET	CIODEV_ASCI + 1
0133   E63F             ;#ENDIF
0134   E63F             ;;
0135   E63F             ;#IF (UARTENABLE & (UARTCNT >= 2))
0136   E63F             LD_UC1	.SET	CIODEV_UART + 1
0137   E63F             LD_PTR	.SET	CIODEV_UART + 1
0138   E63F             LD_PTP	.SET	CIODEV_UART + 1
0139   E63F             ;#ENDIF
0140   E63F             ;
0141   E63F             ;#IF (VDUENABLE | CVDUENABLE | N8VENABLE)
0142   E63F             LD_CRT	.SET	CIODEV_CRT
0143   E63F             ;#ENDIF
0144   E63F             ;#IF (PRPENABLE & PRPCONENABLE)
0145   E63F             ;LD_CRT	.SET	CIODEV_PRPCON
0146   E63F             ;#ENDIF
0147   E63F             ;#IF (PPPENABLE & PPPCONENABLE)
0148   E63F             ;LD_CRT	.SET	CIODEV_PPPCON
0149   E63F             ;#ENDIF
0150   E63F             
0151   E63F             #ENDIF
0152   E63F             ;
0153   E63F 10          	.DB	DEVCNT
0154   E640             DEVMAP:
0155   E640             ;
0156   E640             	; CONSOLE
0157   E640 00          	.DB	LD_TTY			; CON:=TTY: (IOBYTE XXXXXX00)
0158   E641 D0          	.DB	LD_CRT			; CON:=CRT: (IOBYTE XXXXXX01)
0159   E642 E0          	.DB	LD_BAT			; CON:=BAT: (IOBYTE XXXXXX10)
0160   E643 01          	.DB	LD_UC1			; CON:=UC1: (IOBYTE XXXXXX11)
0161   E644             	; READER
0162   E644 00          	.DB	LD_TTY			; RDR:=TTY: (IOBYTE XXXX00XX)
0163   E645 01          	.DB	LD_PTR			; RDR:=PTR: (IOBYTE XXXX01XX)
0164   E646 00          	.DB	LD_UR1			; RDR:=UR1: (IOBYTE XXXX10XX)
0165   E647 00          	.DB	LD_UR2			; RDR:=UR2: (IOBYTE XXXX11XX)
0166   E648             	; PUNCH
0167   E648 00          	.DB	LD_TTY			; PUN:=TTY: (IOBYTE XX00XXXX)
0168   E649 01          	.DB	LD_PTP			; PUN:=PTP: (IOBYTE XX01XXXX)
0169   E64A 00          	.DB	LD_UP1			; PUN:=UP1: (IOBYTE XX10XXXX)
0170   E64B 00          	.DB	LD_UP2			; PUN:=UP2: (IOBYTE XX11XXXX)
0171   E64C             	; LIST
0172   E64C 00          	.DB	LD_TTY			; LST:=TTY: (IOBYTE 00XXXXXX)
0173   E64D D0          	.DB	LD_CRT			; LST:=CRT: (IOBYTE 01XXXXXX)
0174   E64E 00          	.DB	LD_LPT			; LST:=LPT: (IOBYTE 10XXXXXX)
0175   E64F 00          	.DB	LD_UL1			; LST:=UL1: (IOBYTE 11XXXXXX)
0176   E650             ;
0177   E650             DEVCNT	.EQU	($ - DEVMAP)
0178   E650             	.ECHO	DEVCNT
0179   E650             	.ECHO	" Input/Output devices defined.\n"
0180   E650             ;
0181   E650             ;==================================================================================================
0182   E650             ;   DRIVE MAPPING TABLE
0183   E650             ;==================================================================================================
0184   E650             ;
0185   E650             ; Disk mapping is done using a drive map table (DRVMAP) which is built
0186   E650             ; dynamically at cold boot.  See the DRV_INIT routine.  This table is
0187   E650             ; made up of entries as documented below.  The table is prefixed with one
0188   E650             ; byte indicating the number of entries.  The index of the entry indicates
0189   E650             ; the drive letter, so the first entry is A:, the second entry is B:, etc.
0190   E650             ;
0191   E650             ;	BYTE: DEVICE/UNIT (OR JUST UNIT FOR UNA)
0192   E650             ;	BYTE: SLICE
0193   E650             ;	WORD: ADDRESS OF DPH FOR THE DRIVE
0194   E650             ;
0195   E650             ;==================================================================================================
0196   E650             ; DPB MAPPING TABLE
0197   E650             ;==================================================================================================
0198   E650             ;
0199   E650             ; MAP MEDIA ID'S TO APPROPRIATE DPB ADDRESSEES
0200   E650             ; THE ENTRIES IN THIS TABLE MUST CONCIDE WITH THE VALUES
0201   E650             ; OF THE MEDIA ID'S (SAME SEQUENCE, NO GAPS)
0202   E650             ;
0203   E650 0A          	.DB	DPBCNT
0204   E651             ;
0205   E651             DPBMAP:
0206   E651 00 00       	.DW	0		; MID_NONE (NO MEDIA)
0207   E653 D2 EB       	.DW	DPB_ROM		; MID_MDROM
0208   E655 E6 EB       	.DW	DPB_RAM		; MID_MDRAM
0209   E657 FA EB       	.DW	DPB_RF		; MID_RF
0210   E659 0E EC       	.DW	DPB_HD		; MID_HD
0211   E65B 22 EC       	.DW	DPB_FD720	; MID_FD720
0212   E65D 36 EC       	.DW	DPB_FD144	; MID_FD144
0213   E65F 4A EC       	.DW	DPB_FD360	; MID_FD360
0214   E661 5E EC       	.DW	DPB_FD120	; MID_FD120
0215   E663 72 EC       	.DW	DPB_FD111	; MID_FD111
0216   E665             ;
0217   E665             DPBCNT	.EQU	($ - DPBMAP) / 2
0218   E665             ;
0219   E665             ;==================================================================================================
0220   E665             ;   BIOS FUNCTIONS
0221   E665             ;==================================================================================================
0222   E665             ;
0223   E665             ;__________________________________________________________________________________________________
0224   E665             
0225   E665             BOOT:
0226   E665             	; STANDARD BOOT INVOCATION
0227   E665 F3          	DI
0228   E666 ED 56       	IM	1
0229   E668 31 00 FE    	LD	SP,STACK	; STACK FOR INITIALIZATION
0230   E66B             ;
0231   E66B CD C1 ED    	CALL	INIT		; EXECUTE COLD BOOT CODE ROUTINE
0232   E66E             ;
0233   E66E 31 00 01    	LD	SP,$100		; MOVE STACK SO WE CAN INIT BUFFER AREA
0234   E671 21 C1 ED    	LD	HL,INIT		; INIT BUFFERS AREA
0235   E674 01 3F 10    	LD	BC,CBIOS_END - INIT	; SIZE OF BUFFER SPACE
0236   E677 CD 1C EB    	CALL	FILL		; DO IT
0237   E67A             ;
0238   E67A 31 00 FE    	LD	SP,STACK	; PUT STACK BACK WHERE IT BELONGS
0239   E67D 18 1A       	JR	GOCPM		; THEN OFF TO CP/M WE GO...
0240   E67F             ;
0241   E67F             ;__________________________________________________________________________________________________
0242   E67F             WBOOT:
0243   E67F F3          	DI
0244   E680 ED 56       	IM	1
0245   E682             ;
0246   E682 31 00 FE    	LD	SP,STACK	; STACK FOR INITIALIZATION
0247   E685             ;
0248   E685~            #IF (PLATFORM == PLT_UNA)
0249   E685~            	; RESTORE COMMAND PROCESSOR FROM UNA BIOS CACHE
0250   E685~            	LD	BC,$01FB	; UNA FUNC = SET BANK
0251   E685~            	LD	DE,BID_BIOS	; UBIOS_PAGE (SEE PAGES.INC)
0252   E685~            	RST	08		; DO IT
0253   E685~            	PUSH	DE		; SAVE PREVIOUS BANK
0254   E685~            	
0255   E685~            	LD	HL,(CCPBUF)	; ADDRESS OF CCP BUF IN BIOS MEM
0256   E685~            	LD	DE,CPM_LOC	; ADDRESS IN HI MEM OF CCP
0257   E685~            	LD	BC,CCP_SIZ	; SIZE OF CCP
0258   E685~            	LDIR			; DO IT
0259   E685~            
0260   E685~            	LD	BC,$01FB	; UNA FUNC = SET BANK
0261   E685~            	POP	DE		; RECOVER OPERATING BANK
0262   E685~            	RST	08		; DO IT
0263   E685             #ELSE
0264   E685             	; RESTORE COMMAND PROCESSOR FROM CACHE IN HB BANK
0265   E685 06 F3       	LD	B,BF_SYSXCPY	; HBIOS FUNC: SYSTEM EXTENDED COPY
0266   E687 16 8E       	LD	D,BID_USR	; D = DEST BANK = USR BANK = TPA
0267   E689 1E 8D       	LD	E,BID_BIOS	; E = SRC BANK = HB BANK
0268   E68B CF          	RST	08		; SET BANKS FOR INTERBANK COPY
0269   E68C 06 F2       	LD	B,BF_SYSCPY	; HBIOS FUNC: SYSTEM COPY
0270   E68E 2A 9B EB    	LD	HL,(CCPBUF)	; COPY FROM FIXED LOCATION IN HB BANK
0271   E691 11 00 D0    	LD	DE,CPM_LOC	; TO CCP LOCATION IN USR BANK
0272   E694 DD 21 00 08 	LD	IX,CCP_SIZ	; COPY CONTENTS OF COMMAND PROCESSOR
0273   E698 CF          	RST	08		; DO IT
0274   E699             #ENDIF
0275   E699             ;
0276   E699             	; FALL THRU TO INVOKE CP/M
0277   E699             ;
0278   E699             ;__________________________________________________________________________________________________			
0279   E699             GOCPM:
0280   E699~            #IF (PLATFORM == PLT_UNA)
0281   E699~            	; USE A DEDICATED BUFFER FOR UNA PHYSICAL DISK I/O
0282   E699~            	LD	HL,SECBUF		; ADDRESS OF PHYSICAL SECTOR BUFFER
0283   E699~            	LD	(BUFADR),HL		; SAVE IT IN BUFADR FOR LATER
0284   E699             #ELSE
0285   E699             	; CALL BF_DIOSETBUF WITH A PARM OF ZERO TO CAUSE IT TO RESET
0286   E699             	; THE PHYSICAL DISK BUFFER TO THE DEFAULT LOCATION PRE-ALLOCATED
0287   E699             	; INSIDE OF THE HBIOS BANK.  THE ADDRESS IS RETURNED IN HL AND SAVED.
0288   E699 06 19       	LD	B,BF_DIOSETBUF		; GET DISK BUFFER ADR IN HBIOS DRIVER BANK
0289   E69B 21 00 00    	LD	HL,0
0290   E69E CF          	RST	08			; MAKE HBIOS CALL
0291   E69F 22 A2 EB    	LD	(BUFADR),HL		; RECORD THE BUFFER ADDRESS
0292   E6A2             #ENDIF
0293   E6A2             ;
0294   E6A2 3E C3       	LD	A,$C3			; LOAD A WITH 'JP' INSTRUCTION (USED BELOW)
0295   E6A4             ;
0296   E6A4             	; CPU RESET / RST 0 / JP 0 -> WARM START CP/M
0297   E6A4 32 00 00    	LD	($0000),A		; JP OPCODE GOES HERE
0298   E6A7 21 03 E6    	LD	HL,WBOOTE		; GET WARM BOOT ENTRY ADDRESS
0299   E6AA 22 01 00    	LD	($0001),HL		; AND PUT IT AT $0001
0300   E6AD             
0301   E6AD             ;	; INT / RST 38 -> INVOKE MONITOR
0302   E6AD             ;	LD	($0038),A
0303   E6AD             ;	LD	HL,GOMON
0304   E6AD             ;	LD	($0039),HL
0305   E6AD             
0306   E6AD             ;	; INT / RST 38 -> PANIC
0307   E6AD             ;	LD	($0038),A
0308   E6AD             ;	LD	HL,PANIC		; PANIC ROUTINE ADDRESS
0309   E6AD             ;	LD	($0039),HL		; POKE IT
0310   E6AD             	
0311   E6AD             	; CALL 5 -> INVOKE BDOS
0312   E6AD 32 05 00    	LD	($0005),A		; JP OPCODE AT $0005
0313   E6B0 21 06 D8    	LD	HL,BDOS_LOC + 6		; GET BDOS ENTRY ADDRESS
0314   E6B3 22 06 00    	LD	($0006),HL		; PUT IT AT $0006
0315   E6B6             ;
0316   E6B6             	; INSTALL ROMWBW CBIOS PAGE ZERO STAMP AT $40
0317   E6B6 21 33 E6    	LD	HL,STPIMG		; FORM STAMP DATA IMAGE
0318   E6B9 11 40 00    	LD	DE,STPLOC		; TO IT'S LOCATION IN PAGE ZERO
0319   E6BC 01 06 00    	LD	BC,STPSIZ		; SIZE OF BLOCK TO COPY
0320   E6BF ED B0       	LDIR				; DO IT
0321   E6C1             ;
0322   E6C1             	; RESET (DE)BLOCKING ALGORITHM
0323   E6C1 CD C2 E7    	CALL	BLKRES
0324   E6C4             ;
0325   E6C4             	; DEFAULT DMA ADDRESS
0326   E6C4 01 80 00    	LD	BC,$80			; DEFAULT DMA ADDRESS IS $80
0327   E6C7 CD AC E7    	CALL	SETDMA			; SET IT
0328   E6CA             ;
0329   E6CA             	; ENSURE VALID DISK AND JUMP TO CCP
0330   E6CA 3A 04 00    	LD	A,(CDISK)		; GET CURRENT USER/DISK
0331   E6CD E6 0F       	AND	$0F			; ISOLATE DISK PART
0332   E6CF 4F          	LD	C,A			; SETUP C WITH CURRENT USER/DISK, ASSUME IT IS OK
0333   E6D0 CD 7F E9    	CALL	DSK_STATUS		; CHECK DISK STATUS
0334   E6D3 28 05       	JR	Z,CURDSK		; ZERO MEANS OK
0335   E6D5 3A 9A EB    	LD	A,(DEFDRIVE)		; CURRENT DRIVE NOT READY, USE DEFAULT
0336   E6D8 18 03       	JR	GOCCP			; JUMP TO COMMAND PROCESSOR
0337   E6DA             CURDSK:
0338   E6DA 3A 04 00    	LD	A,(CDISK)		; GET CURRENT USER/DISK
0339   E6DD             GOCCP:
0340   E6DD 4F          	LD	C,A			; SETUP C WITH CURRENT USER/DISK, ASSUME IT IS OK
0341   E6DE C3 00 D0    	JP	CCP_ENT			; JUMP TO COMMAND PROCESSOR
0342   E6E1             ;
0343   E6E1             ;__________________________________________________________________________________________________			
0344   E6E1             GOMON:
0345   E6E1 CD 66 EA    	CALL	PANIC
0346   E6E4             ;
0347   E6E4             ;	DI
0348   E6E4             ;	IM	1
0349   E6E4             ;
0350   E6E4             ;	LD	SP,STACK
0351   E6E4             ;
0352   E6E4             ;	; RELOAD MONITOR INTO RAM (IN CASE IT HAS BEEN OVERWRITTEN)
0353   E6E4             ;	CALL	ROMPGZ
0354   E6E4             ;	LD	HL,MON_IMG
0355   E6E4             ;	LD	DE,MON_LOC
0356   E6E4             ;	LD	BC,MON_SIZ
0357   E6E4             ;	LDIR
0358   E6E4             ;	CALL	RAMPGZ
0359   E6E4             	
0360   E6E4             ;	; JUMP TO MONITOR WARM ENTRY
0361   E6E4             ;	JP	MON_UART
0362   E6E4             ;
0363   E6E4             ;
0364   E6E4             ;==================================================================================================
0365   E6E4             ;   CHARACTER BIOS FUNCTIONS
0366   E6E4             ;==================================================================================================
0367   E6E4             ;
0368   E6E4             ;__________________________________________________________________________________________________
0369   E6E4             ;
0370   E6E4             ;__________________________________________________________________________________________________
0371   E6E4             CONST:
0372   E6E4             ; CONSOLE STATUS, RETURN $FF IF CHARACTER READY, $00 IF NOT
0373   E6E4             ;
0374   E6E4 06 02       	LD	B,BF_CIOIST	; B = FUNCTION
0375   E6E6 21 3E E7    	LD	HL,CIOST	; HL = ADDRESS OF COMPLETION ROUTINE
0376   E6E9 18 0B       	JR	CONIO
0377   E6EB             ;
0378   E6EB             ;__________________________________________________________________________________________________			
0379   E6EB             CONIN:
0380   E6EB             ; CONSOLE CHARACTER INTO REGISTER A
0381   E6EB             ;
0382   E6EB 06 00       	LD	B,BF_CIOIN	; B = FUNCTION
0383   E6ED 21 3B E7    	LD	HL,CIOIN	; HL = ADDRESS OF COMPLETION ROUTINE
0384   E6F0 18 04       	JR	CONIO
0385   E6F2             
0386   E6F2             ;__________________________________________________________________________________________________			
0387   E6F2             CONOUT:
0388   E6F2             ; CONSOLE CHARACTER OUTPUT FROM REGISTER C
0389   E6F2             ;
0390   E6F2 06 01       	LD	B,BF_CIOOUT	; B = FUNCTION
0391   E6F4 E1          	POP	HL		; NO COMPLETION ROUTINE, SETUP DIRECT RETURN TO CALLER
0392   E6F5 59          	LD	E,C		; E = CHARACTER TO SEND
0393   E6F6             ;	JR	CONIO		; COMMENTED OUT, FALL THROUGH OK
0394   E6F6             ;
0395   E6F6             ;__________________________________________________________________________________________________			
0396   E6F6             CONIO:
0397   E6F6             ;
0398   E6F6 3A 03 00    	LD	A,(IOBYTE)	; GET IOBYTE
0399   E6F9 E6 03       	AND	$03		; ISOLATE RELEVANT IOBYTE BITS FOR CONSOLE
0400   E6FB             ;	OR	$00		; PUT LOGICAL DEVICE IN BITS 2-3 (CON:=$00, RDR:=$04, PUN:=$08, LST:=$0C
0401   E6FB 18 46       	JR	CIO_DISP
0402   E6FD             ;
0403   E6FD             ;__________________________________________________________________________________________________			
0404   E6FD             LIST:					
0405   E6FD             ; LIST CHARACTER FROM REGISTER C
0406   E6FD             ;
0407   E6FD 06 01       	LD	B,BF_CIOOUT	; B = FUNCTION
0408   E6FF E1          	POP	HL		; NO COMPLETION ROUTINE, SETUP DIRECT RETURN TO CALLER
0409   E700 59          	LD	E,C		; E = CHARACTER TO SEND
0410   E701 18 05       	JR	LISTIO
0411   E703             ;
0412   E703             ;__________________________________________________________________________________________________			
0413   E703             LISTST:
0414   E703             ; RETURN LIST STATUS (0 IF NOT READY, 1 IF READY)
0415   E703             ;
0416   E703 06 03       	LD	B,BF_CIOOST	; B = FUNCTION
0417   E705 21 3E E7    	LD	HL,CIOST	; HL = ADDRESS OF COMPLETION ROUTINE
0418   E708             ;	JR	LISTIO		; COMMENTED OUT, FALL THROUGH OK
0419   E708             ;
0420   E708             ;__________________________________________________________________________________________________			
0421   E708             LISTIO:
0422   E708             ;
0423   E708 3A 03 00    	LD	A,(IOBYTE)	; GET IOBYTE
0424   E70B 07          	RLCA			; SHIFT RELEVANT BITS TO BITS 0-1
0425   E70C 07          	RLCA
0426   E70D E6 03       	AND	$03		; ISOLATE RELEVANT IOBYTE BITS FOR LST:
0427   E70F F6 0C       	OR	$0C		; PUT LOGICAL DEVICE IN BITS 2-3 (CON:=$00, RDR:=$04, PUN:=$08, LST:=$0C
0428   E711 18 30       	JR	CIO_DISP
0429   E713             ;
0430   E713             ;__________________________________________________________________________________________________			
0431   E713             PUNCH:
0432   E713             ; PUNCH CHARACTER FROM REGISTER C
0433   E713             ;
0434   E713 06 01       	LD	B,BF_CIOOUT	; B = FUNCTION
0435   E715 E1          	POP	HL		; NO COMPLETION ROUTINE, SETUP DIRECT RETURN TO CALLER
0436   E716 59          	LD	E,C		; E = CHARACTER TO SEND
0437   E717             ;	JR	PUNCHIO		; COMMENTED OUT, FALL THROUGH OK
0438   E717             ;
0439   E717             ;__________________________________________________________________________________________________			
0440   E717             PUNCHIO:
0441   E717             ;
0442   E717 3A 03 00    	LD	A,(IOBYTE)	; GET IOBYTE
0443   E71A 07          	RLCA			; SHIFT RELEVANT BITS TO BITS 0-1
0444   E71B 07          	RLCA
0445   E71C 07          	RLCA
0446   E71D 07          	RLCA
0447   E71E E6 03       	AND	$03		; ISOLATE RELEVANT IOBYTE BITS FOR PUN:
0448   E720 F6 08       	OR	$08		; PUT LOGICAL DEVICE IN BITS 2-3 (CON:=$00, RDR:=$04, PUN:=$08, LST:=$0C
0449   E722 18 1F       	JR	CIO_DISP
0450   E724             ;
0451   E724             ;__________________________________________________________________________________________________			
0452   E724             READER:
0453   E724             ; READ CHARACTER INTO REGISTER A FROM READER DEVICE
0454   E724             ;
0455   E724 06 00       	LD	B,BF_CIOIN	; B = FUNCTION
0456   E726 21 3B E7    	LD	HL,CIOIN	; HL = ADDRESS OF COMPLETION ROUTINE
0457   E729 18 05       	JR	READERIO
0458   E72B             ;
0459   E72B             ;__________________________________________________________________________________________________			
0460   E72B             READERST:
0461   E72B             ; RETURN READER STATUS (0 IF NOT READY, 1 IF READY)
0462   E72B             ;
0463   E72B 06 02       	LD	B,BF_CIOIST	; B = FUNCTION
0464   E72D 21 3E E7    	LD	HL,CIOST	; HL = ADDRESS OF COMPLETION ROUTINE
0465   E730             ;	JR	READERIO	; COMMENTED OUT, FALL THROUGH OK
0466   E730             ;
0467   E730             ;__________________________________________________________________________________________________			
0468   E730             READERIO:
0469   E730             ;
0470   E730 3A 03 00    	LD	A,(IOBYTE)	; GET IOBYTE
0471   E733 0F          	RRCA			; SHIFT RELEVANT BITS TO BITS 0-1
0472   E734 0F          	RRCA
0473   E735 E6 03       	AND	$03		; ISOLATE RELEVANT IOBYTE BITS FOR RDR:
0474   E737 F6 04       	OR	$04		; PUT LOGICAL DEVICE IN BITS 2-3 (CON:=$00, RDR:=$04, PUN:=$08, LST:=$0C
0475   E739 18 08       	JR	CIO_DISP
0476   E73B             ;
0477   E73B             ;__________________________________________________________________________________________________			
0478   E73B             CIOIN:
0479   E73B             ; COMPLETION ROUTINE FOR CHARACTER INPUT FUNCTIONS
0480   E73B             ;
0481   E73B 7B          	LD	A,E		; MOVE CHARACTER RETURNED TO A
0482   E73C C9          	RET			; FALL THRU
0483   E73D             ;;
0484   E73D             ;;__________________________________________________________________________________________________			
0485   E73D             ;CIOOUT:
0486   E73D             ;; COMPLETION ROUTINE FOR CHARACTER OUTPUT FUNCTIONS
0487   E73D             ;;
0488   E73D C9          	RET
0489   E73E             ;
0490   E73E             ;__________________________________________________________________________________________________			
0491   E73E             CIOST:
0492   E73E             ; COMPLETION ROUTINE FOR CHARACTER STATUS FUNCTIONS (IST/OST)
0493   E73E             ;
0494   E73E~            #IF (PLATFORM == PLT_UNA)
0495   E73E~            	LD	A,E
0496   E73E             #ENDIF
0497   E73E B7          	OR	A		; SET FLAGS
0498   E73F C8          	RET	Z		; NO CHARACTERS WAITING (IST) OR OUTPUT BUF FULL (OST)
0499   E740 F6 FF       	OR	$FF		; $FF SIGNALS READY TO READ (IST) OR WRITE (OST)
0500   E742 C9          	RET
0501   E743             ;
0502   E743             ;==================================================================================================
0503   E743             ;   CHARACTER DEVICE INTERFACE
0504   E743             ;==================================================================================================
0505   E743             ;
0506   E743             ; ROUTING FOR CHARACTER DEVICE FUNCTIONS
0507   E743             ;   A = INDEX INTO DEVICE MAP BASED ON IOBYTE BIOS REQUEST
0508   E743             ;   B = FUNCTION REQUESTED: BF_CIO(IN/OUT/IST/OST)
0509   E743             ;   E = CHARACTER (IF APPLICABLE TO FUNCTION)
0510   E743             ;   HL = ADDRESS OF COMPLETION ROUTINE
0511   E743             ;
0512   E743             CIO_DISP:
0513   E743 E5          	PUSH	HL		; PUT COMPLETION ROUTINE ON STACK
0514   E744             
0515   E744             	; LOOKUP IOBYTE MAPPED DEVICE CODE
0516   E744 E6 0F       	AND	$0F		; ISOLATE INDEX INTO DEVICE MAP
0517   E746             
0518   E746 21 40 E6    	LD	HL,DEVMAP	; HL = ADDRESS OF DEVICE MAP
0519   E749 CD 0B EB    	CALL	ADDHLA		; ADD OFFSET
0520   E74C             	
0521   E74C 7E          	LD	A,(HL)		; LOOKUP DEVICE CODE
0522   E74D~            #IF (PLATFORM == PLT_UNA)
0523   E74D~            	LD	C,B		; MOVE FUNCTION TO C
0524   E74D~            	LD	B,A		; DEVICE GOES IN B
0525   E74D             #ELSE
0526   E74D 4F          	LD	C,A		; SAVE IN C FOR BIOS USAGE
0527   E74E             #ENDIF
0528   E74E             
0529   E74E FE E0       	CP	CIODEV_BAT	; CHECK FOR SPECIAL DEVICE (BAT, NUL)
0530   E750 30 02       	JR	NC,CIO_DISP1	; HANDLE SPECIAL DEVICE
0531   E752 CF          	RST	08		; RETURN VIA COMPLETION ROUTINE SET AT START
0532   E753 C9          	RET
0533   E754             	
0534   E754             CIO_DISP1:
0535   E754             	; HANDLE SPECIAL DEVICES
0536   E754 E6 F0       	AND	$F0		; ISOLATE DEVICE
0537   E756 FE E0       	CP	CIODEV_BAT	; BAT: ?
0538   E758 28 07       	JR	Z,CIO_BAT	; YES, GO TO BAT DEVICE HANDLER
0539   E75A FE F0       	CP	CIODEV_NUL	; NUL: ?
0540   E75C 28 18       	JR	Z,CIO_NUL	; YES, GO TO NUL DEVICE HANDLER
0541   E75E CD 66 EA    	CALL	PANIC		; SOMETHING BAD HAPPENED
0542   E761             ;
0543   E761             ; BAT: IS A PSEUDO DEVICE REDIRECTING INPUT TO READER AND OUTPUT TO LIST
0544   E761             ;
0545   E761             CIO_BAT:
0546   E761 4B          	LD	C,E		; PUT CHAR BACK IN C
0547   E762 78          	LD	A,B		; GET REQUESTED FUNCTION
0548   E763 FE 00       	CP	BF_CIOIN	; INPUT?
0549   E765 28 BD       	JR	Z,READER	; -> READER
0550   E767 FE 02       	CP	BF_CIOIST	; INPUT STATUS?
0551   E769 28 C0       	JR	Z,READERST	; -> READER
0552   E76B FE 01       	CP	BF_CIOOUT	; OUTPUT?
0553   E76D 28 8E       	JR	Z,LIST		; -> LIST
0554   E76F FE 03       	CP	BF_CIOOST	; OUTPUT STATUS?
0555   E771 28 90       	JR	Z,LISTST	; -> LIST
0556   E773 CD 66 EA    	CALL	PANIC		; SOMETHING BAD HAPPENED
0557   E776             ;
0558   E776             ; NUL: IS A DUMMY DEVICE THAT DOES NOTHING
0559   E776             ;
0560   E776             CIO_NUL:
0561   E776 78          	LD	A,B		; FUNCTION
0562   E777 FE 00       	CP	BF_CIOIN
0563   E779 28 0F       	JR	Z,NUL_IN
0564   E77B FE 02       	CP	BF_CIOIST
0565   E77D 28 0E       	JR	Z,NUL_IST
0566   E77F FE 01       	CP	BF_CIOOUT
0567   E781 28 09       	JR	Z,NUL_OUT
0568   E783 FE 03       	CP	BF_CIOOST
0569   E785 28 06       	JR	Z,NUL_OST
0570   E787 CD 66 EA    	CALL	PANIC
0571   E78A             ;
0572   E78A             NUL_IN:
0573   E78A 1E 1B       	LD	E,$1B		; RETURN EOF
0574   E78C             NUL_OUT:
0575   E78C C9          	RET
0576   E78D             ;
0577   E78D             NUL_IST:
0578   E78D             NUL_OST:
0579   E78D F6 FF       	OR	$FF		; A=$FF & NZ SET
0580   E78F C9          	RET
0581   E790             ;
0582   E790             ;==================================================================================================
0583   E790             ;   DISK BIOS FUNCTIONS
0584   E790             ;==================================================================================================
0585   E790             ;
0586   E790             ;__________________________________________________________________________________________________
0587   E790             SELDSK:
0588   E790             ; SELECT DISK NUMBER FOR SUBSEQUENT DISK OPS
0589   E790~            #IF DSKTRACE
0590   E790~            	CALL	PRTSELDSK	; *DEBUG*
0591   E790             #ENDIF
0592   E790             ;
0593   E790 C3 3C E9    	JP	DSK_SELECT
0594   E793             ;
0595   E793             ;__________________________________________________________________________________________________	
0596   E793             HOME:
0597   E793             ; SELECT TRACK 0 (BC = 0) AND FALL THRU TO SETTRK
0598   E793~            #IF DSKTRACE
0599   E793~            	CALL	PRTHOME		; *DEBUG*
0600   E793             #ENDIF
0601   E793             ;	
0602   E793 3A A1 EB    	LD	A,(HSTWRT)	; CHECK FOR PENDING WRITE
0603   E796 B7          	OR	A		; SET FLAGS
0604   E797 20 03       	JR	NZ,HOMED	; BUFFER IS DIRTY
0605   E799 32 C4 EB    	LD	(HSTACT),A	; CLEAR HOST ACTIVE FLAG
0606   E79C             ;
0607   E79C             HOMED:
0608   E79C 01 00 00    	LD	BC,0
0609   E79F             ;
0610   E79F             ;__________________________________________________________________________________________________
0611   E79F             SETTRK:
0612   E79F             ; SET TRACK GIVEN BY REGISTER BC
0613   E79F ED 43 A5 EB 	LD	(SEKTRK),BC
0614   E7A3 C9          	RET
0615   E7A4             ;
0616   E7A4             ;__________________________________________________________________________________________________
0617   E7A4             SETSEC:
0618   E7A4             ; SET SECTOR GIVEN BY REGISTER BC
0619   E7A4 ED 43 A7 EB 	LD	(SEKSEC),BC
0620   E7A8 C9          	RET
0621   E7A9             ;
0622   E7A9             ;__________________________________________________________________________________________________
0623   E7A9             SECTRN:
0624   E7A9             ; SECTOR TRANSLATION FOR SKEW, HARD CODED 1:1, NO SKEW IMPLEMENTED
0625   E7A9 60          	LD	H,B
0626   E7AA 69          	LD	L,C
0627   E7AB C9          	RET
0628   E7AC             ;
0629   E7AC             ;__________________________________________________________________________________________________
0630   E7AC             SETDMA:
0631   E7AC ED 43 9F EB 	LD	(DMAADR),BC
0632   E7B0 C9          	RET
0633   E7B1             ;
0634   E7B1             ;__________________________________________________________________________________________________
0635   E7B1             READ:
0636   E7B1 3E 00       	LD	A,DOP_READ
0637   E7B3 18 08       	JR	READWRITE
0638   E7B5             ;
0639   E7B5             ;__________________________________________________________________________________________________
0640   E7B5             WRITE:
0641   E7B5 79          	LD	A,C
0642   E7B6 32 9E EB    	LD	(WRTYPE),A	; SAVE WRITE TYPE
0643   E7B9 3E 01       	LD	A,DOP_WRITE
0644   E7BB 18 00       	JR	READWRITE
0645   E7BD             ;
0646   E7BD             ;__________________________________________________________________________________________________
0647   E7BD             READWRITE:
0648   E7BD 32 9D EB    	LD	(DSKOP),A		; SET THE ACTIVE DISK OPERATION
0649   E7C0 18 14       	JR	BLKRW
0650   E7C2             ;
0651   E7C2             ;==================================================================================================
0652   E7C2             ;   BLOCKED READ/WRITE (BLOCK AND BUFFER FOR 512 BYTE SECTOR)
0653   E7C2             ;==================================================================================================
0654   E7C2             ;
0655   E7C2             ;__________________________________________________________________________________________________
0656   E7C2             ;
0657   E7C2             ; RESET (DE)BLOCKING ALGORITHM - JUST MARK BUFFER INVALID
0658   E7C2             ; NOTE: BUFFER CONTENTS INVALIDATED, BUT RETAIN ANY PENDING WRITE
0659   E7C2             ;
0660   E7C2             BLKRES:
0661   E7C2 AF          	XOR	A
0662   E7C3 32 C4 EB    	LD	(HSTACT),A	; BUFFER NO LONGER VALID
0663   E7C6 32 CA EB    	LD	(UNACNT),A	; CLEAR UNALLOC COUNT
0664   E7C9             	
0665   E7C9 C9          	RET
0666   E7CA             
0667   E7CA             ;__________________________________________________________________________________________________
0668   E7CA             ;
0669   E7CA             ; FLUSH (DE)BLOCKING ALGORITHM - DO PENDING WRITES
0670   E7CA             ;
0671   E7CA             BLKFLSH:
0672   E7CA             	; CHECK FOR BUFFER WRITTEN (DIRTY)
0673   E7CA 3A A1 EB    	LD	A,(HSTWRT)	; GET BUFFER WRITTEN FLAG
0674   E7CD B7          	OR	A
0675   E7CE C8          	RET	Z		; NOT DIRTY, RETURN WITH A=0 AND Z SET
0676   E7CF             
0677   E7CF             	; CLEAR THE BUFFER WRITTEN FLAG (EVEN IF A WRITE ERROR OCCURS)
0678   E7CF AF          	XOR	A		; Z = 0
0679   E7D0 32 A1 EB    	LD	(HSTWRT),A	; SAVE IT
0680   E7D3             
0681   E7D3             	; DO THE WRITE AND RETURN RESULT
0682   E7D3 C3 8C E9    	JP	DSK_WRITE
0683   E7D6             
0684   E7D6             #IF WRTCACHE
0685   E7D6             
0686   E7D6             WRT_ALC	.EQU	0			; WRITE TO ALLOCATED
0687   E7D6             WRT_DIR	.EQU	1			; WRITE TO DIRECTORY
0688   E7D6             WRT_UNA	.EQU	2			; WRITE TO UNALLOCATED
0689   E7D6             
0690   E7D6             ;
0691   E7D6             ;__________________________________________________________________________________________________
0692   E7D6             ;
0693   E7D6             ; (DE)BLOCKING READ/WRITE ROUTINE.  MANAGES PHYSICAL DISK BUFFER AND CALLS
0694   E7D6             ; PHYSICAL READ/WRITE ROUTINES APPROPRIATELY.
0695   E7D6             ;
0696   E7D6             BLKRW:
0697   E7D6~            #IF DSKTRACE
0698   E7D6~            	CALL	PRTDSKOP		; *DEBUG*
0699   E7D6             #ENDIF
0700   E7D6             
0701   E7D6             	; FIX!!! WE ABORT ON FIRST ERROR, DRI SEEMS TO PASS ERROR STATUS TO THE END!!!
0702   E7D6             
0703   E7D6             	; IF WRITE OPERATION, GO TO SPECIAL WRITE PROCESSING
0704   E7D6 3A 9D EB    	LD	A,(DSKOP)	; GET REQUESTED OPERATION
0705   E7D9 FE 01       	CP	DOP_WRITE	; WRITE
0706   E7DB 28 09       	JR	Z,BLKRW1	; GO TO WRITE PROCESSING
0707   E7DD             
0708   E7DD             	; OTHERWISE, CLEAR OUT ANY SEQUENTIAL, UNALLOC WRITE PROCESSING
0709   E7DD             	; AND GO DIRECTLY TO MAIN I/O
0710   E7DD AF          	XOR	A		; ZERO TO A
0711   E7DE 32 9E EB    	LD	(WRTYPE),A	; SET WRITE TYPE = 0 (WRT_ALC) TO ENSURE READ OCCURS
0712   E7E1 32 CA EB    	LD	(UNACNT),A	; SET UNACNT TO ABORT SEQ WRITE PROCESSING
0713   E7E4             	
0714   E7E4 18 24       	JR	BLKRW4		; GO TO I/O
0715   E7E6             
0716   E7E6             BLKRW1:
0717   E7E6             	; WRITE PROCESSING
0718   E7E6             	; CHECK FOR FIRST WRITE TO UNALLOCATED BLOCK
0719   E7E6 3A 9E EB    	LD	A,(WRTYPE)	; GET WRITE TYPE
0720   E7E9 FE 02       	CP	WRT_UNA		; IS IT WRITE TO UNALLOC?
0721   E7EB 20 07       	JR	NZ,BLKRW2	; NOPE, BYPASS
0722   E7ED             	
0723   E7ED             	; INITIALIZE START OF SEQUENTIAL WRITING TO UNALLOCATED BLOCK
0724   E7ED             	; AND THEN TREAT SUBSEQUENT PROCESSING AS A NORMAL WRITE
0725   E7ED CD 49 E8    	CALL	UNA_INI		; INITIALIZE SEQUENTIAL WRITE TRACKING
0726   E7F0 AF          	XOR	A		; A = 0 = WRT_ALC
0727   E7F1 32 9E EB    	LD	(WRTYPE),A	; NOW TREAT LIKE WRITE TO ALLOCATED
0728   E7F4             
0729   E7F4             BLKRW2:
0730   E7F4             	; IF WRTYPE = WRT_ALC AND SEQ WRITE, GOTO BLKRW7 (SKIP READ)
0731   E7F4 B7          	OR	A		; NOTE: A WILL ALREADY HAVE THE WRITE TYPE HERE
0732   E7F5 20 0F       	JR	NZ,BLKRW3	; NOT TYPE = 0 = WRT_ALC, SO MOVE ON
0733   E7F7             
0734   E7F7 CD 6D E8    	CALL	UNA_CHK		; CHECK FOR CONTINUATION OF SEQ WRITES TO UNALLOCATED BLOCK
0735   E7FA 20 0A       	JR	NZ,BLKRW3	; NOPE, ABORT
0736   E7FC             	
0737   E7FC             	; WE MATCHED EVERYTHING, TREAT AS WRITE TO UNALLOCATED BLOCK
0738   E7FC 3E 02       	LD	A,WRT_UNA	; WRITE TO UNALLOCATED
0739   E7FE 32 9E EB    	LD	(WRTYPE),A	; SAVE WRITE TYPE
0740   E801             	
0741   E801 CD 7F E8    	CALL	UNA_INC		; INCREMENT SEQUENTIAL WRITE TRACKING
0742   E804 18 04       	JR	BLKRW4		; PROCEED TO I/O PROCESSING
0743   E806             
0744   E806             BLKRW3:
0745   E806             	; NON-SEQUENTIAL WRITE DETECTED, STOP ANY FURTHER CHECKING
0746   E806 AF          	XOR	A		; ZERO
0747   E807 32 CA EB    	LD	(UNACNT),A	; CLEAR UNALLOCATED WRITE COUNT
0748   E80A             
0749   E80A             	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0750   E80A             	; IS A FLUSH NEEDED HERE???
0751   E80A             	; FLUSH CURRENT BUFFER CONTENTS IF NEEDED
0752   E80A             	;CALL	BLKFLSH		; FLUSH PENDING WRITES
0753   E80A             	;RET	NZ		; ABORT ON ERROR
0754   E80A             	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0755   E80A             
0756   E80A             BLKRW4:
0757   E80A             	; START OF ACTUAL I/O PROCESSING
0758   E80A CD 9E E8    	CALL	BLK_XLT		; DO THE LOGICAL TO PHYSICAL MAPPING: SEK... -> XLT...
0759   E80D CD C6 E8    	CALL	BLK_CMP		; IS THE DESIRED PHYSICAL BLOCK IN BUFFER?
0760   E810 28 19       	JR	Z,BLKRW6	; BLOCK ALREADY IN ACTIVE BUFFER, NO READ REQUIRED
0761   E812             
0762   E812             	; AT THIS POINT, WE KNOW WE NEED TO READ THE TARGET PHYSICAL SECTOR
0763   E812             	; IT MAY ACTUALLY BE A PREREAD FOR A SUBSEQUENT WRITE, BUT THAT IS OK
0764   E812             
0765   E812             	; FIRST, FLUSH CURRENT BUFFER CONTENTS
0766   E812 CD CA E7    	CALL	BLKFLSH		; FLUSH PENDING WRITES
0767   E815 C0          	RET	NZ		; ABORT ON ERROR
0768   E816             
0769   E816             	; IMPLEMENT THE TRANSLATED VALUES
0770   E816 CD BA E8    	CALL	BLK_SAV		; SAVE XLAT VALUES: XLT... -> HST...
0771   E819             	
0772   E819             	; IF WRITE TO UNALLOC BLOCK, BYPASS READ, LEAVES BUFFER UNDEFINED
0773   E819 3A 9E EB    	LD	A,(WRTYPE)
0774   E81C FE 02       	CP	2
0775   E81E 28 0B       	JR	Z,BLKRW6
0776   E820             	
0777   E820             	; DO THE ACTUAL READ
0778   E820 CD 88 E9    	CALL	DSK_READ	; READ PHYSICAL SECTOR INTO BUFFER
0779   E823 28 06       	JR	Z,BLKRW6	; GOOD READ, CONTINUE
0780   E825             	
0781   E825             	; IF READ FAILED, RESET (DE)BLOCKING ALGORITHM AND RETURN ERROR
0782   E825 F5          	PUSH	AF		; SAVE ERROR STATUS
0783   E826 CD C2 E7    	CALL	BLKRES		; INVALIDATE (DE)BLOCKING BUFFER
0784   E829 F1          	POP	AF		; RECOVER ERROR STATUS
0785   E82A C9          	RET			; ERROR RETURN
0786   E82B             
0787   E82B             BLKRW6:
0788   E82B             	; CHECK TYPE OF OPERATIONS, IF WRITE, THEN GO TO WRITE PROCESSING
0789   E82B 3A 9D EB    	LD	A,(DSKOP)	; GET PENDING OPERATION
0790   E82E FE 01       	CP	DOP_WRITE	; IS IT A WRITE?
0791   E830 28 05       	JR	Z,BLKRW7	; YES, GO TO WRITE PROCESSING
0792   E832             
0793   E832             	; THIS IS A READ OPERATION, WE ALREADY DID THE I/O, NOW JUST DEBLOCK AND RETURN
0794   E832 CD ED E8    	CALL	BLK_DEBLOCK	; EXTRACT DATA FROM BLOCK
0795   E835 AF          	XOR	A		; NO ERROR
0796   E836 C9          	RET			; ALL DONE
0797   E837             	
0798   E837             BLKRW7:
0799   E837             	; THIS IS A WRITE OPERATION, INSERT DATA INTO BLOCK
0800   E837 CD D6 E8    	CALL	BLK_BLOCK	; INSERT DATA INTO BLOCK
0801   E83A             
0802   E83A             	; MARK THE BUFFER AS WRITTEN
0803   E83A 3E 01       	LD	A,TRUE		; BUFFER DIRTY = TRUE
0804   E83C 32 A1 EB    	LD	(HSTWRT),A	; SAVE IT
0805   E83F             	
0806   E83F             	; CHECK WRITE TYPE, IF WRT_DIR, FORCE THE PHYSICAL WRITE
0807   E83F 3A 9E EB    	LD	A,(WRTYPE)	; GET WRITE TYPE
0808   E842 FE 01       	CP	WRT_DIR		; 1 = DIRECTORY WRITE
0809   E844 CA CA E7    	JP	Z,BLKFLSH	; FLUSH PENDING WRITES AND RETURN STATUS
0810   E847             
0811   E847 AF          	XOR	A		; ALL IS WELL, SET RETURN CODE 0
0812   E848 C9          	RET			; RETURN
0813   E849             ;
0814   E849             ;__________________________________________________________________________________________________
0815   E849             ;
0816   E849             ; INITIALIZE TRACKING OF SEQUENTIAL WRITES INTO UNALLOCATED BLOCK
0817   E849             ; SETUP UNA... VARIABLES
0818   E849             ;
0819   E849             UNA_INI:
0820   E849             	; COPY SEKDSK/TRK/SEC TO UNA...
0821   E849 21 A4 EB    	LD	HL,SEK
0822   E84C 11 C5 EB    	LD	DE,UNA
0823   E84F 01 05 00    	LD	BC,UNASIZ
0824   E852 ED B0       	LDIR
0825   E854             
0826   E854             	; SETUP UNACNT AND UNASPT
0827   E854 2A AA EB    	LD	HL,(SEKDPH)	; HL POINTS TO DPH
0828   E857 11 0A 00    	LD	DE,10		; OFFSET OF DPB ADDRESS IN DPH
0829   E85A 19          	ADD	HL,DE		; DPH POINTS TO DPB ADDRESS
0830   E85B 7E          	LD	A,(HL)
0831   E85C 23          	INC	HL
0832   E85D 66          	LD	H,(HL)
0833   E85E 6F          	LD	L,A		; HL POINTS TO DPB
0834   E85F 4E          	LD	C,(HL)
0835   E860 23          	INC	HL
0836   E861 46          	LD	B,(HL)		; BC HAS SPT
0837   E862 ED 43 CB EB 	LD	(UNASPT),BC	; SAVE SECTORS PER TRACK
0838   E866 2B          	DEC	HL
0839   E867 2B          	DEC	HL		; HL POINTS TO RECORDS PER BLOCK (BYTE IN FRONT OF DPB)
0840   E868 7E          	LD	A,(HL)		; GET IT
0841   E869 32 CA EB    	LD	(UNACNT),A	; SAVE IT
0842   E86C             	
0843   E86C C9          	RET
0844   E86D             ;
0845   E86D             ;__________________________________________________________________________________________________
0846   E86D             ;
0847   E86D             ; CHECK FOR CONTINUATION OF SEQUENTIAL WRITES TO UNALLOCATED BLOCK
0848   E86D             ; SEE IF UNACNT > 0 AND UNA... VARIABLES MATCH SEK... VARIABLES
0849   E86D             ;
0850   E86D             UNA_CHK:
0851   E86D 3A CA EB    	LD	A,(UNACNT)	; GET THE COUNTER
0852   E870 B7          	OR	A
0853   E871 20 02       	JR	NZ,UNA_CHK1	; IF NOT DONE WITH BLOCK, KEEP CHECKING
0854   E873             
0855   E873             	; CNT IS NOW ZERO, EXHAUSTED RECORDS IN ONE BLOCK!
0856   E873 3D          	DEC	A		; HACK TO SET NZ
0857   E874 C9          	RET			; RETURN WITH NZ
0858   E875             
0859   E875             UNA_CHK1:
0860   E875             	; COMPARE UNA... VARIABLES WITH SEK... VARIABLES
0861   E875 21 A4 EB    	LD	HL,SEK
0862   E878 11 C5 EB    	LD	DE,UNA
0863   E87B 06 05       	LD	B,UNASIZ
0864   E87D 18 4F       	JR	BLK_CMPLOOP
0865   E87F             ;
0866   E87F             ;__________________________________________________________________________________________________
0867   E87F             ;
0868   E87F             ; INCREMENT THE SEQUENTIAL WRITE TRACKING VARIABLES
0869   E87F             ; TO REFLECT THE NEXT RECORD (TRK/SEC) WE EXPECT
0870   E87F             ;
0871   E87F             UNA_INC:
0872   E87F             	; DECREMENT THE BLOCK RECORD COUNT
0873   E87F 21 CA EB    	LD	HL,UNACNT
0874   E882 35          	DEC	(HL)
0875   E883             	
0876   E883             	; INCREMENT THE SECTOR
0877   E883 ED 5B C8 EB 	LD	DE,(UNASEC)
0878   E887 13          	INC	DE
0879   E888 ED 53 C8 EB 	LD	(UNASEC),DE
0880   E88C             	
0881   E88C             	; CHECK FOR END OF TRACK
0882   E88C 2A CB EB    	LD	HL,(UNASPT)
0883   E88F AF          	XOR	A
0884   E890 ED 52       	SBC	HL,DE
0885   E892 C0          	RET	NZ
0886   E893             	
0887   E893             	; HANDLE END OF TRACK
0888   E893 22 C8 EB    	LD	(UNASEC),HL	; SECTOR BACK TO 0 (NOTE: HL=0 AT THIS POINT)
0889   E896 2A C6 EB    	LD	HL,(UNATRK)	; GET CURRENT TRACK
0890   E899 23          	INC	HL		; BUMP IT
0891   E89A 22 C6 EB    	LD	(UNATRK),HL	; SAVE IT
0892   E89D             	
0893   E89D C9          	RET
0894   E89E~            #ELSE
0895   E89E~            ;
0896   E89E~            ;__________________________________________________________________________________________________
0897   E89E~            ;
0898   E89E~            ; (DE)BLOCKING READ/WRITE ROUTINE.  MANAGES PHYSICAL DISK BUFFER AND CALLS
0899   E89E~            ; PHYSICAL READ/WRITE ROUTINES APPROPRIATELY.
0900   E89E~            ;
0901   E89E~            BLKRW:
0902   E89E~            #IF DSKTRACE
0903   E89E~            	CALL	PRTDSKOP	; *DEBUG*
0904   E89E~            #ENDIF
0905   E89E~            
0906   E89E~            	CALL	BLK_XLT		; SECTOR XLAT: SEK... -> XLT...
0907   E89E~            	CALL	BLK_CMP		; IN BUFFER?
0908   E89E~            	JR	Z,BLKRW1	; YES, BYPASS READ
0909   E89E~            	CALL	BLK_SAV		; SAVE XLAT VALUES: XLT... -> HST...
0910   E89E~            	LD	A,FALSE		; ASSUME FAILURE, INVALIDATE BUFFER
0911   E89E~            	LD	(HSTACT),A	; SAVE IT
0912   E89E~            	CALL	DSK_READ	; READ PHYSICAL SECTOR INTO BUFFER
0913   E89E~            	RET	NZ		; BAIL OUT ON ERROR
0914   E89E~            
0915   E89E~            BLKRW1:
0916   E89E~            	LD	A,(DSKOP)	; GET PENDING OPERATION
0917   E89E~            	CP	DOP_WRITE	; IS IT A WRITE?
0918   E89E~            	JR	Z,BLKRW2	; YES, GO TO WRITE ROUTINE
0919   E89E~            
0920   E89E~            	CALL	BLK_DEBLOCK	; EXTRACT DATA FROM BLOCK
0921   E89E~            	XOR	A		; NO ERROR
0922   E89E~            	RET			; ALL DONE
0923   E89E~            	
0924   E89E~            BLKRW2:
0925   E89E~            	CALL	BLK_BLOCK	; INSERT DATA INTO BLOCK
0926   E89E~            	CALL	DSK_WRITE	; WRITE PHYSICAL SECTOR FROM BUFFER
0927   E89E~            	RET	NZ		; BAIL OUT ON ERROR
0928   E89E~            	
0929   E89E~            	LD	A,TRUE		; BUFFER IS NOW VALID
0930   E89E~            	LD	(HSTACT),A	; SAVE IT
0931   E89E~            	
0932   E89E~            	XOR	A		; ALL IS WELL, SET RETURN CODE 0
0933   E89E~            	RET			; RETURN
0934   E89E             #ENDIF
0935   E89E             ;
0936   E89E             ;__________________________________________________________________________________________________
0937   E89E             ;
0938   E89E             ; TRANSLATE FROM CP/M DSK/TRK/SEC TO PHYSICAL
0939   E89E             ; SEK... -> XLT...
0940   E89E             ;
0941   E89E             BLK_XLT:
0942   E89E             	; FIRST, DO A BYTE COPY OF SEK... TO XLT...
0943   E89E 21 A4 EB    	LD	HL,SEK
0944   E8A1 11 AF EB    	LD	DE,XLT
0945   E8A4 01 0B 00    	LD	BC,XLTSIZ
0946   E8A7 ED B0       	LDIR
0947   E8A9             
0948   E8A9             	; NOW UPDATE XLTSEC BASED ON (DE)BLOCKING FACTOR (ALWAYS 4:1)
0949   E8A9 ED 4B A7 EB 	LD	BC,(SEKSEC)		; SECTOR IS FACTORED DOWN (4:1) DUE TO BLOCKING
0950   E8AD CB 38       	SRL	B			; 16 BIT RIGHT SHIFT TWICE TO DIVIDE BY 4
0951   E8AF CB 19       	RR	C
0952   E8B1 CB 38       	SRL	B
0953   E8B3 CB 19       	RR	C
0954   E8B5 ED 43 B2 EB 	LD	(XLTSEC),BC
0955   E8B9             
0956   E8B9 C9          	RET
0957   E8BA             ;
0958   E8BA             ;__________________________________________________________________________________________________
0959   E8BA             ;
0960   E8BA             ; SAVE RESULTS OF TRANSLATION: XLT... -> HST...
0961   E8BA             ; IMPLICITLY SETS HSTACT TO TRUE!
0962   E8BA             ;
0963   E8BA             BLK_SAV:
0964   E8BA 21 AF EB    	LD	HL,XLT
0965   E8BD 11 BA EB    	LD	DE,HST
0966   E8C0 01 0B 00    	LD	BC,XLTSIZ
0967   E8C3 ED B0       	LDIR
0968   E8C5 C9          	RET
0969   E8C6             ;
0970   E8C6             ;__________________________________________________________________________________________________
0971   E8C6             ;
0972   E8C6             ; COMPARE RESULTS OF TRANSLATION TO CURRENT BUF (XLT... TO HST...)
0973   E8C6             ; NOTE THAT HSTACT IS COMPARED TO XLTACT IMPLICITLY!  XLTACT IS ALWAYS TRUE, SO
0974   E8C6             ; HSTACT MUST BE TRUE FOR COMPARE TO SUCCEED.
0975   E8C6             ;
0976   E8C6             BLK_CMP:
0977   E8C6 21 AF EB    	LD	HL,XLT
0978   E8C9 11 BA EB    	LD	DE,HST
0979   E8CC 06 0B       	LD	B,XLTSIZ
0980   E8CE             BLK_CMPLOOP:
0981   E8CE 1A          	LD	A,(DE)
0982   E8CF BE          	CP	(HL)
0983   E8D0 C0          	RET	NZ			; BAD COMPARE, RETURN WITH NZ
0984   E8D1 23          	INC	HL
0985   E8D2 13          	INC	DE
0986   E8D3 10 F9       	DJNZ	BLK_CMPLOOP
0987   E8D5 C9          	RET				; RETURN WITH Z
0988   E8D6             ;
0989   E8D6             ;__________________________________________________________________________________________________
0990   E8D6             ;
0991   E8D6             ; BLOCK DATA - INSERT CPM DMA BUF INTO PROPER PART OF PHYSICAL SECTOR BUFFER
0992   E8D6             ;
0993   E8D6             BLK_BLOCK:
0994   E8D6~            #IF (PLATFORM == PLT_UNA)
0995   E8D6~            	CALL	BLK_SETUP
0996   E8D6~            	EX	DE,HL
0997   E8D6~            	LD	BC,128
0998   E8D6~            	LDIR
0999   E8D6~            	RET
1000   E8D6             #ELSE
1001   E8D6 06 F3       	LD	B,BF_SYSXCPY	; HBIOS FUNC: SYSTEM EXTENDED COPY
1002   E8D8 1E 8E       	LD	E,BID_USR	; E=SRC=USER BANK=TPA
1003   E8DA 16 8D       	LD	D,BID_BIOS	; D=DEST=HBIOS
1004   E8DC CF          	RST	08		; SET BANKS FOR INTERBANK COPY
1005   E8DD CD 03 E9    	CALL	BLK_SETUP	; SETUP SOURCE AND DESTINATION
1006   E8E0 06 F2       	LD	B,BF_SYSCPY	; HBIOS FUNC: SYSTEM COPY
1007   E8E2 EB          	EX	DE,HL		; SWAP HL/DE FOR BLOCK OPERATION
1008   E8E3 DD E5       	PUSH	IX		; SAVE IX
1009   E8E5 DD 21 80 00 	LD	IX,128		; DMA BUFFER SIZE
1010   E8E9 CF          	RST	08		; DO IT
1011   E8EA DD E1       	POP	IX		; RESTORE IX
1012   E8EC C9          	RET
1013   E8ED             #ENDIF
1014   E8ED             ;
1015   E8ED             ;__________________________________________________________________________________________________
1016   E8ED             ;
1017   E8ED             ; DEBLOCK DATA - EXTRACT DESIRED CPM DMA BUF FROM PHYSICAL SECTOR BUFFER
1018   E8ED             ;
1019   E8ED             BLK_DEBLOCK:
1020   E8ED~            #IF (PLATFORM == PLT_UNA)
1021   E8ED~            	CALL	BLK_SETUP
1022   E8ED~            	LD	BC,128
1023   E8ED~            	LDIR
1024   E8ED~            	RET
1025   E8ED             #ELSE
1026   E8ED 06 F3       	LD	B,BF_SYSXCPY	; HBIOS FUNC: SYSTEM EXTENDED COPY
1027   E8EF 1E 8D       	LD	E,BID_BIOS	; C=SRC=HBIOS
1028   E8F1 16 8E       	LD	D,BID_USR	; B=DEST=USER BANK=TPA
1029   E8F3 CF          	RST	08		; DO IT
1030   E8F4 CD 03 E9    	CALL	BLK_SETUP	; SETUP SOURCE AND DESTINATION
1031   E8F7 06 F2       	LD	B,BF_SYSCPY	; HBIOS FUNC: SYSTEM COPY
1032   E8F9 DD E5       	PUSH	IX		; SAVE IX
1033   E8FB DD 21 80 00 	LD	IX,128		; DMA BUFFER SIZE
1034   E8FF CF          	RST	08		; DO IT
1035   E900 DD E1       	POP	IX		; RESTORE IX
1036   E902 C9          	RET
1037   E903             #ENDIF
1038   E903             ;
1039   E903             ;__________________________________________________________________________________________________
1040   E903             ;
1041   E903             ; SETUP SOURCE AND DESTINATION POINTERS FOR BLOCK COPY OPERATION
1042   E903             ; AT EXIT, HL = ADDRESS OF DESIRED BLOCK IN SECTOR BUFFER, DE = DMA
1043   E903             ;
1044   E903             BLK_SETUP:	
1045   E903 ED 4B A7 EB 	LD		BC,(SEKSEC)
1046   E907 79          	LD		A,C
1047   E908 E6 03       	AND		3		; A = INDEX OF CPM BUF IN SEC BUF
1048   E90A 0F          	RRCA				; MULTIPLY BY 64
1049   E90B 0F          	RRCA
1050   E90C 5F          	LD		E,A		; INTO LOW ORDER BYTE OF DESTINATION
1051   E90D 16 00       	LD		D,0		; HIGH ORDER BYTE IS ZERO
1052   E90F 2A A2 EB    	LD		HL,(BUFADR)	; HL = START OF SEC BUF
1053   E912 19          	ADD		HL,DE		; ADD IN COMPUTED OFFSET
1054   E913 19          	ADD		HL,DE		; HL NOW = INDEX * 128 (SOURCE)
1055   E914 ED 5B 9F EB 	LD		DE,(DMAADR)	; DE = DESTINATION = DMA BUF
1056   E918 C9          	RET
1057   E919             ;
1058   E919             ;==================================================================================================
1059   E919             ; PHYSICAL DISK INTERFACE
1060   E919             ;==================================================================================================
1061   E919             ;
1062   E919             ; LOOKUP DISK INFORMATION BASED ON CPM DRIVE IN C
1063   E919             ; ON RETURN, D=DEVICE/UNIT, E=SLICE, HL=DPH ADDRESS
1064   E919             ;
1065   E919             DSK_GETINF:
1066   E919 2A 3B E6    	LD	HL,(DRVMAPADR)	; HL := START OF UNA DRIVE MAP
1067   E91C 2B          	DEC	HL		; POINT TO DRIVE COUNT
1068   E91D 79          	LD	A,C		; A := CPM DRIVE
1069   E91E BE          	CP	(HL)		; COMPARE TO NUMBER OF DRIVES CONFIGURED
1070   E91F 30 14       	JR	NC,DSK_GETINF1	; IF OUT OF RANGE, GO TO ERROR RETURN
1071   E921 23          	INC	HL		; POINT TO START OF DRIVE MAP
1072   E922             ;
1073   E922 07          	RLCA			; MULTIPLY A BY 4...
1074   E923 07          	RLCA			; TO USE AS OFFSET INTO ???? MAP
1075   E924 CD 0B EB    	CALL	ADDHLA		; ADD OFFSET
1076   E927 56          	LD	D,(HL)		; D := DEVICE/UNIT
1077   E928 23          	INC	HL		; BUMP TO SLICE
1078   E929 5E          	LD	E,(HL)		; E := SLICE
1079   E92A 23          	INC	HL		; POINT TO DPH LSB
1080   E92B 7E          	LD	A,(HL)		; A := DPH LSB
1081   E92C 23          	INC	HL		; POINT TO DPH MSB
1082   E92D 66          	LD	H,(HL)		; H := DPH MSB
1083   E92E 6F          	LD	L,A		; L := DPH LSB
1084   E92F 7C          	LD	A,H		; TEST FOR INVALID DPH
1085   E930 B5          	OR	L		; ... BY CHECKING FOR ZERO VALUE
1086   E931 28 02       	JR	Z,DSK_GETINF1	; HANDLE ZERO DPH, DRIVE IS INVALID
1087   E933 AF          	XOR	A		; SET SUCCESS
1088   E934 C9          	RET
1089   E935             ;
1090   E935             DSK_GETINF1:	; ERROR RETURN
1091   E935 AF          	XOR	A
1092   E936 67          	LD	H,A
1093   E937 6F          	LD	L,A
1094   E938 57          	LD	D,A
1095   E939 5F          	LD	E,A
1096   E93A 3C          	INC	A
1097   E93B C9          	RET
1098   E93C             ;
1099   E93C             ;
1100   E93C             ;
1101   E93C             DSK_SELECT:
1102   E93C 43          	LD	B,E		; SAVE E IN B FOR NOW
1103   E93D CD 19 E9    	CALL	DSK_GETINF	; GET D=DEVICE/UNIT, E=SLICE, HL=DPH ADDRESS
1104   E940 C0          	RET	NZ		; RETURN IF INVALID DRIVE (A=1, NZ SET, HL=0)
1105   E941 C5          	PUSH	BC		; WE NEED  B LATER, SAVE ON STACK
1106   E942             ;
1107   E942             	; SAVE ALL THE NEW STUFF
1108   E942 79          	LD	A,C		; A := CPM DRIVE NO
1109   E943 32 A4 EB    	LD	(SEKDSK),A	; SAVE IT
1110   E946 7A          	LD	A,D		; A := DEVICE/UNIT
1111   E947 32 A9 EB    	LD	(SEKDU),A	; SAVE DEVICE/UNIT
1112   E94A 22 AA EB    	LD	(SEKDPH),HL	; SAVE DPH POINTER
1113   E94D             ;
1114   E94D             	; UPDATE OFFSET FOR ACTIVE SLICE
1115   E94D             	; A TRACK IS ASSUMED TO BE 16 SECTORS
1116   E94D             	; THE OFFSET REPRESENTS THE NUMBER OF BLOCKS * 256
1117   E94D             	;   TO USE AS THE OFFSET
1118   E94D 26 41       	LD	H,65		; H = TRACKS PER SLICE, E = SLICE NO
1119   E94F CD 10 EB    	CALL	MULT8		; HL := H * E (TOTAL TRACK OFFSET)
1120   E952 22 AC EB    	LD	(SEKOFF),HL	; SAVE NEW TRACK OFFSET
1121   E955             ;
1122   E955             	; RESTORE DE TO BC (FOR ACCESS TO DRIVE LOGIN BIT)
1123   E955 C1          	POP	BC		; GET ORIGINAL E INTO B
1124   E956             ;
1125   E956             #IF (PLATFORM != PLT_UNA)
1126   E956             ;
1127   E956             	; CHECK IF THIS IS LOGIN, IF NOT, BYPASS MEDIA DETECTION
1128   E956             	; FIX: WHAT IF PREVIOUS MEDIA DETECTION FAILED???
1129   E956 CB 40       	BIT	0,B		; TEST DRIVE LOGIN BIT
1130   E958 20 20       	JR	NZ,DSK_SELECT2	; BYPASS MEDIA DETECTION
1131   E95A             ;
1132   E95A             	; DETERMINE MEDIA IN DRIVE
1133   E95A 3A A9 EB    	LD	A,(SEKDU)	; GET DEVICE/UNIT
1134   E95D 4F          	LD	C,A		; STORE IN C
1135   E95E 06 13       	LD	B,BF_DIOMED	; DRIVER FUNCTION = DISK MEDIA
1136   E960 CF          	RST	08
1137   E961 B7          	OR	A		; SET FLAGS
1138   E962 21 00 00    	LD	HL,0		; ASSUME FAILURE
1139   E965 C8          	RET	Z		; BAIL OUT IF NO MEDIA
1140   E966             ;
1141   E966             	; A HAS MEDIA ID, SET HL TO CORRESPONDING DPBMAP ENTRY
1142   E966 21 51 E6    	LD	HL,DPBMAP	; HL = DPBMAP
1143   E969 07          	RLCA			; DPBMAP ENTRIES ARE 2 BYTES EACH
1144   E96A CD 0B EB    	CALL	ADDHLA		; ADD OFFSET TO HL
1145   E96D             ;
1146   E96D             	; LOOKUP THE ACTUAL DPB ADDRESS NOW
1147   E96D 5E          	LD	E,(HL)		; DEREFERENCE HL...
1148   E96E 23          	INC	HL		; INTO DE...
1149   E96F 56          	LD	D,(HL)		; DE = ADDRESS OF DESIRED DPB
1150   E970             ;	
1151   E970             	; PLUG DPB INTO THE ACTIVE DPH
1152   E970 2A AA EB    	LD	HL,(SEKDPH)
1153   E973 01 0A 00    	LD	BC,10		; OFFSET OF DPB IN DPH
1154   E976 09          	ADD	HL,BC		; HL := DPH.DPB
1155   E977 73          	LD	(HL),E		; SET LSB OF DPB IN DPH
1156   E978 23          	INC	HL		; BUMP TO MSB
1157   E979 72          	LD	(HL),D		; SET MSB OF DPB IN DPH
1158   E97A             #ENDIF
1159   E97A             ;
1160   E97A             DSK_SELECT2:
1161   E97A 2A AA EB    	LD	HL,(SEKDPH)	; HL = DPH ADDRESS FOR CP/M	
1162   E97D AF          	XOR	A		; FLAG SUCCESS
1163   E97E C9          	RET			; NORMAL RETURN
1164   E97F             ;
1165   E97F             ;
1166   E97F             ;
1167   E97F             DSK_STATUS:
1168   E97F~            #IF (PLATFORM == PLT_UNA)
1169   E97F~            	XOR	A		; ASSUME OK FOR NOW
1170   E97F~            	RET			; RETURN
1171   E97F             #ELSE
1172   E97F             	; C HAS CPM DRIVE, LOOKUP DEVICE/UNIT AND CHECK FOR INVALID DRIVE
1173   E97F CD 19 E9    	CALL	DSK_GETINF	; B = DEVICE/UNIT
1174   E982 C0          	RET	NZ		; INVALID DRIVE ERROR
1175   E983             	
1176   E983             	; VALID DRIVE, DISPATCH TO DRIVER
1177   E983 4A          	LD	C,D		; C := DEVICE/UNIT
1178   E984 06 12       	LD	B,BF_DIOST	; B := FUNCTION: STATUS
1179   E986 CF          	RST	08
1180   E987 C9          	RET
1181   E988             #ENDIF
1182   E988             ;
1183   E988             ;
1184   E988             ;
1185   E988             DSK_READ:
1186   E988             	; SET B = FUNCTION: READ
1187   E988 06 10       	LD	B,BF_DIORD
1188   E98A 18 04       	JR	DSK_IO
1189   E98C             ;
1190   E98C             ;
1191   E98C             ;
1192   E98C             DSK_WRITE:
1193   E98C             	; SET B = FUNCTION: WRITE
1194   E98C 06 11       	LD	B,BF_DIOWR
1195   E98E 18 00       	JR	DSK_IO
1196   E990             ;
1197   E990             ;
1198   E990             ;
1199   E990~            #IF (PLATFORM == PLT_UNA)
1200   E990~            
1201   E990~            DSK_IO:
1202   E990~            DSK_IO1:
1203   E990~            	PUSH	BC
1204   E990~            	LD	DE,(HSTTRK)	; GET TRACK INTO HL
1205   E990~            	LD	B,4		; PREPARE TO LEFT SHIFT BY 4 BITS
1206   E990~            DSK_IO2:
1207   E990~            	SLA	E		; SHIFT DE LEFT BY 4 BITS
1208   E990~            	RL	D
1209   E990~            	DJNZ	DSK_IO2		; LOOP TILL ALL BITS DONE
1210   E990~            	LD	A,(HSTSEC)	; GET THE SECTOR INTO A
1211   E990~            	AND	$0F		; GET RID OF TOP NIBBLE
1212   E990~            	OR	E		; COMBINE WITH E
1213   E990~            	LD	E,A		; BACK IN E
1214   E990~            	LD	HL,0		; HL:DE NOW HAS SLICE RELATIVE LBA
1215   E990~            	; APPLY OFFSET NOW
1216   E990~            	; OFFSET IS EXPRESSED AS NUMBER OF BLOCKS * 256 TO OFFSET!
1217   E990~            	LD	A,(HSTOFF)	; LSB OF SLICE OFFSET TO A
1218   E990~            	ADD	A,D		; ADD WITH D
1219   E990~            	LD	D,A		; PUT IT BACK IN D
1220   E990~            	LD	A,(HSTOFF+1)	; MSB OF SLICE OFFSET TO A
1221   E990~            	CALL	ADDHLA		; ADD OFFSET
1222   E990~            	POP	BC		; RECOVER FUNCTION IN B
1223   E990~            	LD	A,(HSTDU)	; GET THE DEVICE/UNIT VALUE
1224   E990~            	LD	C,A		; PUT IT IN C
1225   E990~            	; DISPATCH TO DRIVER
1226   E990~            	PUSH	BC
1227   E990~            	EX	DE,HL		; DE:HL NOW HAS LBA
1228   E990~            	LD	B,C		; UNIT TO B
1229   E990~            	LD	C,$41		; UNA SET LBA
1230   E990~            	RST	08		; CALL UNA
1231   E990~            	CALL	NZ,PANIC
1232   E990~            	POP	BC		; RECOVER B=FUNC, C=UNIT
1233   E990~            	LD	E,C		; UNIT TO E
1234   E990~            	LD	C,B		; FUNC TO C
1235   E990~            	LD	B,E		; UNIT TO B
1236   E990~            	LD	DE,(BUFADR)	; SET BUFFER ADDRESS
1237   E990~            	LD	HL,1		; 1 SECTOR
1238   E990~            
1239   E990~            	RST	08
1240   E990~            	CALL	NZ,PANIC
1241   E990~            	XOR	A		; SET FLAGS BASED ON RESULT
1242   E990~            	RET
1243   E990~            
1244   E990             #ELSE
1245   E990             
1246   E990             DSK_IO:
1247   E990 3A BF EB    	LD	A,(HSTDU)	; GET ACTIVE DEVICE/UNIT BYTE
1248   E993 E6 F0       	AND	$F0		; ISOLATE DEVICE PORTION
1249   E995 FE 10       	CP	DIODEV_FD	; FLOPPY?
1250   E997 20 13       	JR	NZ,DSK_IO1	; NO, USE LBA HANDLING
1251   E999             	; SET HL=TRACK (ADD IN TRACK OFFSET)
1252   E999 ED 5B C2 EB 	LD	DE,(HSTOFF)	; DE = TRACK OFFSET FOR LU SUPPORT
1253   E99D 2A BB EB    	LD	HL,(HSTTRK)	; HL = TRACK #
1254   E9A0 19          	ADD	HL,DE		; APPLY OFFSET FOR ACTIVE SLICE
1255   E9A1             	; SET DE=SECTOR
1256   E9A1 ED 5B BD EB 	LD	DE,(HSTSEC)	; DE = SECTOR #
1257   E9A5             	; SET C = DEVICE/UNIT
1258   E9A5 3A BF EB    	LD	A,(HSTDU)	; LOAD DEVICE/UNIT VALUE
1259   E9A8 4F          	LD	C,A		; SAVE IN C
1260   E9A9             	; DISPATCH TO DRIVER
1261   E9A9 CF          	RST	08
1262   E9AA B7          	OR	A		; SET FLAGS BASED ON RESULT
1263   E9AB C9          	RET
1264   E9AC             	; NEW LBA HANDLING
1265   E9AC             	; COERCE TRACK/SECTOR INTO HL:DE AS 0000:TTTS
1266   E9AC             DSK_IO1:
1267   E9AC C5          	PUSH	BC
1268   E9AD ED 5B BB EB 	LD	DE,(HSTTRK)	; GET TRACK INTO HL
1269   E9B1 06 04       	LD	B,4		; PREPARE TO LEFT SHIFT BY 4 BITS
1270   E9B3             DSK_IO2:
1271   E9B3 CB 23       	SLA	E		; SHIFT DE LEFT BY 4 BITS
1272   E9B5 CB 12       	RL	D
1273   E9B7 10 FA       	DJNZ	DSK_IO2		; LOOP TILL ALL BITS DONE
1274   E9B9 3A BD EB    	LD	A,(HSTSEC)	; GET THE SECTOR INTO A
1275   E9BC E6 0F       	AND	$0F		; GET RID OF TOP NIBBLE
1276   E9BE B3          	OR	E		; COMBINE WITH E
1277   E9BF 5F          	LD	E,A		; BACK IN E
1278   E9C0 21 00 00    	LD	HL,0		; HL:DE NOW HAS SLICE RELATIVE LBA
1279   E9C3             	; APPLY OFFSET NOW
1280   E9C3             	; OFFSET IS EXPRESSED AS NUMBER OF BLOCKS * 256 TO OFFSET!
1281   E9C3 3A C2 EB    	LD	A,(HSTOFF)	; LSB OF SLICE OFFSET TO A
1282   E9C6 82          	ADD	A,D		; ADD WITH D
1283   E9C7 57          	LD	D,A		; PUT IT BACK IN D
1284   E9C8 3A C3 EB    	LD	A,(HSTOFF+1)	; MSB OF SLICE OFFSET TO A
1285   E9CB CD 0B EB    	CALL	ADDHLA		; ADD OFFSET
1286   E9CE C1          	POP	BC		; RECOVER FUNCTION IN B
1287   E9CF 3A BF EB    	LD	A,(HSTDU)	; GET THE DEVICE/UNIT VALUE
1288   E9D2 4F          	LD	C,A		; PUT IT IN C
1289   E9D3             	; DISPATCH TO DRIVER
1290   E9D3 CF          	RST	08
1291   E9D4 B7          	OR	A		; SET FLAGS BASED ON RESULT
1292   E9D5 C9          	RET
1293   E9D6             
1294   E9D6             #ENDIF
1295   E9D6             ;
1296   E9D6             ;==================================================================================================
1297   E9D6             ; UTILITY FUNCTIONS
1298   E9D6             ;==================================================================================================
1299   E9D6             ;
1300   E9D6             #DEFINE	CIOMODE_CBIOS
1301   E9D6             ORG_UTIL	.EQU	$
1302   E9D6             #INCLUDE "util.asm"
0001+  E9D6             ;
0002+  E9D6             ;==================================================================================================
0003+  E9D6             ; UTILITY FUNCTIONS
0004+  E9D6             ;==================================================================================================
0005+  E9D6             ;
0006+  E9D6             ;
0007+  E9D6             CHR_CR		.EQU	0DH
0008+  E9D6             CHR_LF		.EQU	0AH
0009+  E9D6             CHR_BS		.EQU	08H
0010+  E9D6             CHR_ESC		.EQU	1BH
0011+  E9D6             ;
0012+  E9D6             ;__________________________________________________________________________________________________
0013+  E9D6             ;
0014+  E9D6             ; UTILITY PROCS TO PRINT SINGLE CHARACTERS WITHOUT TRASHING ANY REGISTERS
0015+  E9D6             ;
0016+  E9D6             PC_SPACE:
0017+  E9D6 F5          	PUSH	AF
0018+  E9D7 3E 20       	LD	A,' '
0019+  E9D9 18 3C       	JR	PC_PRTCHR
0020+  E9DB             
0021+  E9DB             PC_PERIOD:
0022+  E9DB F5          	PUSH	AF
0023+  E9DC 3E 2E       	LD	A,'.'
0024+  E9DE 18 37       	JR	PC_PRTCHR
0025+  E9E0             
0026+  E9E0             PC_COLON:
0027+  E9E0 F5          	PUSH	AF
0028+  E9E1 3E 3A       	LD	A,':'
0029+  E9E3 18 32       	JR	PC_PRTCHR
0030+  E9E5             
0031+  E9E5             PC_COMMA:
0032+  E9E5 F5          	PUSH	AF
0033+  E9E6 3E 2C       	LD	A,','
0034+  E9E8 18 2D       	JR	PC_PRTCHR
0035+  E9EA             
0036+  E9EA             PC_LBKT:
0037+  E9EA F5          	PUSH	AF
0038+  E9EB 3E 5B       	LD	A,'['
0039+  E9ED 18 28       	JR	PC_PRTCHR
0040+  E9EF             
0041+  E9EF             PC_RBKT:
0042+  E9EF F5          	PUSH	AF
0043+  E9F0 3E 5D       	LD	A,']'
0044+  E9F2 18 23       	JR	PC_PRTCHR
0045+  E9F4             
0046+  E9F4             PC_LT:
0047+  E9F4 F5          	PUSH	AF
0048+  E9F5 3E 3C       	LD	A,'<'
0049+  E9F7 18 1E       	JR	PC_PRTCHR
0050+  E9F9             
0051+  E9F9             PC_GT:
0052+  E9F9 F5          	PUSH	AF
0053+  E9FA 3E 3E       	LD	A,'>'
0054+  E9FC 18 19       	JR	PC_PRTCHR
0055+  E9FE             
0056+  E9FE             PC_LPAREN:
0057+  E9FE F5          	PUSH	AF
0058+  E9FF 3E 28       	LD	A,'('
0059+  EA01 18 14       	JR	PC_PRTCHR
0060+  EA03             
0061+  EA03             PC_RPAREN:
0062+  EA03 F5          	PUSH	AF
0063+  EA04 3E 29       	LD	A,')'
0064+  EA06 18 0F       	JR	PC_PRTCHR
0065+  EA08             
0066+  EA08             PC_ASTERISK:
0067+  EA08 F5          	PUSH	AF
0068+  EA09 3E 2A       	LD	A,'*'
0069+  EA0B 18 0A       	JR	PC_PRTCHR
0070+  EA0D             
0071+  EA0D             PC_CR:
0072+  EA0D F5          	PUSH	AF
0073+  EA0E 3E 0D       	LD	A,CHR_CR
0074+  EA10 18 05       	JR	PC_PRTCHR
0075+  EA12             
0076+  EA12             PC_LF:
0077+  EA12 F5          	PUSH	AF
0078+  EA13 3E 0A       	LD	A,CHR_LF
0079+  EA15 18 00       	JR	PC_PRTCHR
0080+  EA17             
0081+  EA17             PC_PRTCHR:
0082+  EA17 CD B6 EA    	CALL	COUT
0083+  EA1A F1          	POP	AF
0084+  EA1B C9          	RET
0085+  EA1C             
0086+  EA1C             NEWLINE:
0087+  EA1C CD 0D EA    	CALL	PC_CR
0088+  EA1F CD 12 EA    	CALL	PC_LF
0089+  EA22 C9          	RET
0090+  EA23             ;
0091+  EA23             ; PRINT THE HEX BYTE VALUE IN A
0092+  EA23             ;
0093+  EA23             PRTHEXBYTE:
0094+  EA23 F5          	PUSH	AF
0095+  EA24 D5          	PUSH	DE
0096+  EA25 CD 3E EA    	CALL	HEXASCII
0097+  EA28 7A          	LD	A,D
0098+  EA29 CD B6 EA    	CALL	COUT
0099+  EA2C 7B          	LD	A,E
0100+  EA2D CD B6 EA    	CALL	COUT
0101+  EA30 D1          	POP	DE
0102+  EA31 F1          	POP	AF
0103+  EA32 C9          	RET
0104+  EA33             ;
0105+  EA33             ; PRINT THE HEX WORD VALUE IN BC
0106+  EA33             ;
0107+  EA33             PRTHEXWORD:
0108+  EA33 F5          	PUSH	AF
0109+  EA34 78          	LD	A,B
0110+  EA35 CD 23 EA    	CALL	PRTHEXBYTE
0111+  EA38 79          	LD	A,C
0112+  EA39 CD 23 EA    	CALL	PRTHEXBYTE
0113+  EA3C F1          	POP	AF
0114+  EA3D C9          	RET
0115+  EA3E             ;
0116+  EA3E             ; CONVERT BINARY VALUE IN A TO ASCII HEX CHARACTERS IN DE
0117+  EA3E             ;
0118+  EA3E             HEXASCII:
0119+  EA3E 57          	LD	D,A
0120+  EA3F CD 4D EA    	CALL	HEXCONV
0121+  EA42 5F          	LD	E,A
0122+  EA43 7A          	LD	A,D
0123+  EA44 07          	RLCA
0124+  EA45 07          	RLCA
0125+  EA46 07          	RLCA
0126+  EA47 07          	RLCA
0127+  EA48 CD 4D EA    	CALL	HEXCONV
0128+  EA4B 57          	LD	D,A
0129+  EA4C C9          	RET
0130+  EA4D             ;
0131+  EA4D             ; CONVERT LOW NIBBLE OF A TO ASCII HEX
0132+  EA4D             ;
0133+  EA4D             HEXCONV:
0134+  EA4D E6 0F       	AND	0FH	     ;LOW NIBBLE ONLY
0135+  EA4F C6 90       	ADD	A,90H
0136+  EA51 27          	DAA	
0137+  EA52 CE 40       	ADC	A,40H
0138+  EA54 27          	DAA	
0139+  EA55 C9          	RET	
0140+  EA56             ;
0141+  EA56             ; OUTPUT A '$' TERMINATED STRING
0142+  EA56             ;
0143+  EA56             WRITESTR:
0144+  EA56 F5          	PUSH	AF
0145+  EA57             WRITESTR1:
0146+  EA57 1A          	LD	A,(DE)
0147+  EA58 FE 24       	CP	'$'			; TEST FOR STRING TERMINATOR
0148+  EA5A CA 64 EA    	JP	Z,WRITESTR2
0149+  EA5D CD B6 EA    	CALL	COUT
0150+  EA60 13          	INC	DE
0151+  EA61 C3 57 EA    	JP	WRITESTR1
0152+  EA64             WRITESTR2:
0153+  EA64 F1          	POP	AF
0154+  EA65 C9          	RET
0155+  EA66             ;
0156+  EA66             ; PANIC: TRY TO DUMP MACHINE STATE AND HALT
0157+  EA66             ;
0158+  EA66             PANIC:
0159+  EA66 E5          	PUSH	HL
0160+  EA67 D5          	PUSH	DE
0161+  EA68 C5          	PUSH	BC
0162+  EA69 F5          	PUSH	AF
0163+  EA6A 11 D7 EA    	LD	DE,STR_PANIC
0164+  EA6D CD 56 EA    	CALL	WRITESTR
0165+  EA70 11 EC EA    	LD	DE,STR_AF
0166+  EA73 CD 56 EA    	CALL	WRITESTR
0167+  EA76 C1          	POP	BC		; AF
0168+  EA77 CD 33 EA    	CALL	PRTHEXWORD
0169+  EA7A 11 F1 EA    	LD	DE,STR_BC
0170+  EA7D CD 56 EA    	CALL	WRITESTR
0171+  EA80 C1          	POP	BC		; BC
0172+  EA81 CD 33 EA    	CALL	PRTHEXWORD
0173+  EA84 11 F6 EA    	LD	DE,STR_DE
0174+  EA87 CD 56 EA    	CALL	WRITESTR
0175+  EA8A C1          	POP	BC		; DE
0176+  EA8B CD 33 EA    	CALL	PRTHEXWORD
0177+  EA8E 11 FB EA    	LD	DE,STR_HL
0178+  EA91 CD 56 EA    	CALL	WRITESTR
0179+  EA94 C1          	POP	BC		; HL
0180+  EA95 CD 33 EA    	CALL	PRTHEXWORD
0181+  EA98 11 00 EB    	LD	DE,STR_PC
0182+  EA9B CD 56 EA    	CALL	WRITESTR
0183+  EA9E C1          	POP	BC		; PC
0184+  EA9F CD 33 EA    	CALL	PRTHEXWORD
0185+  EAA2 11 05 EB    	LD	DE,STR_SP
0186+  EAA5 CD 56 EA    	CALL	WRITESTR
0187+  EAA8 21 00 00    	LD	HL,0
0188+  EAAB 39          	ADD	HL,SP		; SP
0189+  EAAC 44          	LD	B,H
0190+  EAAD 4D          	LD	C,L
0191+  EAAE CD 33 EA    	CALL	PRTHEXWORD
0192+  EAB1             	
0193+  EAB1 FF          	RST	38
0194+  EAB2             	
0195+  EAB2 76          	HALT
0196+  EAB3             	
0197+  EAB3 C3 00 00    	JP	0
0198+  EAB6             ;
0199+  EAB6             ;==================================================================================================
0200+  EAB6             ; CONSOLE CHARACTER I/O HELPER ROUTINES (REGISTERS PRESERVED)
0201+  EAB6             ;==================================================================================================
0202+  EAB6             ;
0203+  EAB6             ; OUTPUT CHARACTER FROM A
0204+  EAB6             COUT:
0205+  EAB6 F5          	PUSH	AF
0206+  EAB7 C5          	PUSH	BC
0207+  EAB8 D5          	PUSH	DE
0208+  EAB9 E5          	PUSH	HL
0209+  EABA 4F          	LD	C,A
0210+  EABB CD 0C E6    	CALL	CBIOS_CONOUT
0211+  EABE E1          	POP	HL
0212+  EABF D1          	POP	DE
0213+  EAC0 C1          	POP	BC
0214+  EAC1 F1          	POP	AF
0215+  EAC2 C9          	RET
0216+  EAC3             ;
0217+  EAC3             ; INPUT CHARACTER TO A
0218+  EAC3             ;
0219+  EAC3             CIN:
0220+  EAC3 C5          	PUSH	BC
0221+  EAC4 D5          	PUSH	DE
0222+  EAC5 E5          	PUSH	HL
0223+  EAC6 CD 09 E6    	CALL	CBIOS_CONIN
0224+  EAC9 E1          	POP	HL
0225+  EACA D1          	POP	DE
0226+  EACB C1          	POP	BC
0227+  EACC C9          	RET
0228+  EACD             ;
0229+  EACD             ; RETURN INPUT STATUS IN A (0 = NO CHAR, !=0 CHAR WAITING)
0230+  EACD             ;
0231+  EACD             CST:
0232+  EACD C5          	PUSH	BC
0233+  EACE D5          	PUSH	DE
0234+  EACF E5          	PUSH	HL
0235+  EAD0 CD 06 E6    	CALL	CBIOS_CONST
0236+  EAD3 E1          	POP	HL
0237+  EAD4 D1          	POP	DE
0238+  EAD5 C1          	POP	BC
0239+  EAD6 C9          	RET
0240+  EAD7             ;
0241+  EAD7 0D 0A 0D 0A STR_PANIC	.DB	"\r\n\r\n>>> FATAL ERROR:$"
0241+  EADB 3E 3E 3E 20 
0241+  EADF 46 41 54 41 
0241+  EAE3 4C 20 45 52 
0241+  EAE7 52 4F 52 3A 
0241+  EAEB 24 
0242+  EAEC 20 41 46 3D STR_AF		.DB	" AF=$"
0242+  EAF0 24 
0243+  EAF1 20 42 43 3D STR_BC		.DB	" BC=$"
0243+  EAF5 24 
0244+  EAF6 20 44 45 3D STR_DE		.DB	" DE=$"
0244+  EAFA 24 
0245+  EAFB 20 48 4C 3D STR_HL		.DB	" HL=$"
0245+  EAFF 24 
0246+  EB00 20 50 43 3D STR_PC		.DB	" PC=$"
0246+  EB04 24 
0247+  EB05 20 53 50 3D STR_SP		.DB	" SP=$"
0247+  EB09 24 
0248+  EB0A             ;
0249+  EB0A             ; INDIRECT JUMP TO ADDRESS IN HL
0250+  EB0A             ;
0251+  EB0A             ;   MOSTLY USEFUL TO PERFORM AN INDIRECT CALL LIKE:
0252+  EB0A             ;     LD	HL,xxxx
0253+  EB0A             ;     CALL	JPHL
0254+  EB0A             ;
0255+  EB0A E9          JPHL:	JP	(HL)
0256+  EB0B             ;
0257+  EB0B             ; ADD HL,A
0258+  EB0B             ;
0259+  EB0B             ;   A REGISTER IS DESTROYED!
0260+  EB0B             ;
0261+  EB0B             
0262+  EB0B             ADDHLA:
0263+  EB0B 85          	ADD	A,L
0264+  EB0C 6F          	LD	L,A
0265+  EB0D D0          	RET	NC
0266+  EB0E 24          	INC	H
0267+  EB0F C9          	RET
0268+  EB10             ;
0269+  EB10             ; MULTIPLY 8-BIT VALUES
0270+  EB10             ; IN:  MULTIPLY H BY E
0271+  EB10             ; OUT: HL = RESULT, E = 0, B = 0
0272+  EB10             ;
0273+  EB10             MULT8:
0274+  EB10 16 00       	LD D,0
0275+  EB12 6A          	LD L,D
0276+  EB13 06 08       	LD B,8
0277+  EB15             MULT8_LOOP:
0278+  EB15 29          	ADD HL,HL
0279+  EB16 30 01       	JR NC,MULT8_NOADD
0280+  EB18 19          	ADD HL,DE
0281+  EB19             MULT8_NOADD:
0282+  EB19 10 FA       	DJNZ MULT8_LOOP
0283+  EB1B C9          	RET
0284+  EB1C             ;
0285+  EB1C             ; FILL MEMORY AT HL WITH VALUE A, LENGTH IN BC, ALL REGS USED
0286+  EB1C             ; LENGTH *MSUT* BE GREATER THAN 1 FOR PROPER OPERATION!!!
0287+  EB1C             ;
0288+  EB1C             FILL:
0289+  EB1C 54          	LD	D,H		; SET DE TO HL
0290+  EB1D 5D          	LD	E,L		; SO DESTINATION EQUALS SOURCE
0291+  EB1E 77          	LD	(HL),A		; FILL THE FIRST BYTE WITH DESIRED VALUE
0292+  EB1F 13          	INC	DE		; INCREMENT DESTINATION
0293+  EB20 0B          	DEC	BC		; DECREMENT THE COUNT
0294+  EB21 ED B0       	LDIR			; DO THE REST
0295+  EB23 C9          	RET			; RETURN
0296+  EB24             ;
0297+  EB24             ; SET A BIT IN BYTE ARRAY AT HL, INDEX IN A
0298+  EB24             ;
0299+  EB24             BITSET:
0300+  EB24 CD 36 EB    	CALL	BITLOC		; LOCATE THE BIT
0301+  EB27 B6          	OR	(HL)		; SET THE SPECIFIED BIT
0302+  EB28 77          	LD	(HL),A		; SAVE IT
0303+  EB29 C9          	RET			; RETURN
0304+  EB2A             ;
0305+  EB2A             ; CLEAR A BIT IN BYTE ARRAY AT HL, INDEX IN A
0306+  EB2A             ;
0307+  EB2A             BITCLR:
0308+  EB2A CD 36 EB    	CALL	BITLOC		; LOCATE THE BIT
0309+  EB2D 2F          	CPL			; INVERT ALL BITS
0310+  EB2E A6          	AND	(HL)		; CLEAR SPECIFIED BIT
0311+  EB2F 77          	LD	(HL),A		; SAVE IT
0312+  EB30 C9          	RET			; RETURN
0313+  EB31             ;
0314+  EB31             ; GET VALUE OF A BIT IN BYTE ARRAY AT HL, INDEX IN A
0315+  EB31             ;
0316+  EB31             BITTST:
0317+  EB31 CD 36 EB    	CALL	BITLOC		; LOCATE THE BIT
0318+  EB34 A6          	AND	(HL)		; SET Z FLAG BASED ON BIT
0319+  EB35 C9          	RET			; RETURN
0320+  EB36             ;
0321+  EB36             ; LOCATE A BIT IN BYTE ARRAY AT HL, INDEX IN A
0322+  EB36             ; RETURN WITH HL POINTING TO BYTE AND A WITH MASK FOR SPECIFIC BIT
0323+  EB36             ;
0324+  EB36             BITLOC:
0325+  EB36 F5          	PUSH	AF		; SAVE BIT INDEX
0326+  EB37 CB 3F       	SRL	A		; DIVIDE BY 8 TO GET BYTE INDEX
0327+  EB39 CB 3F       	SRL	A		; "
0328+  EB3B CB 3F       	SRL	A		; "
0329+  EB3D 4F          	LD	C,A		; MOVE TO BC
0330+  EB3E 06 00       	LD	B,0		; "
0331+  EB40 09          	ADD	HL,BC		; HL NOW POINTS TO BYTE CONTAINING BIT
0332+  EB41 F1          	POP	AF		; RECOVER A (INDEX)
0333+  EB42 E6 07       	AND	$07		; ISOLATE REMAINDER, Z SET IF ZERO
0334+  EB44 47          	LD	B,A		; SETUP SHIFT COUNTER
0335+  EB45 3E 01       	LD	A,1		; SETUP A WITH MASK
0336+  EB47 C8          	RET	Z		; DONE IF ZERO
0337+  EB48             BITLOC1:
0338+  EB48 CB 27       	SLA	A		; SHIFT
0339+  EB4A 10 FC       	DJNZ	BITLOC1		; LOOP AS NEEDED
0340+  EB4C C9          	RET			; DONE
0341+  EB4D             ;
0342+  EB4D             ; PRINT VALUE OF A IN DECIMAL WITH LEADING ZERO SUPPRESSION
0343+  EB4D             ;
0344+  EB4D             PRTDECB:
0345+  EB4D E5          	PUSH	HL
0346+  EB4E F5          	PUSH	AF
0347+  EB4F 6F          	LD	L,A
0348+  EB50 26 00       	LD	H,0
0349+  EB52 CD 58 EB    	CALL	PRTDEC
0350+  EB55 F1          	POP	AF
0351+  EB56 E1          	POP	HL
0352+  EB57 C9          	RET
0353+  EB58             ;
0354+  EB58             ; PRINT VALUE OF HL IN DECIMAL WITH LEADING ZERO SUPPRESSION
0355+  EB58             ;
0356+  EB58             PRTDEC:
0357+  EB58 C5          	PUSH	BC
0358+  EB59 D5          	PUSH	DE
0359+  EB5A E5          	PUSH	HL
0360+  EB5B 1E 30       	LD	E,'0'
0361+  EB5D 01 F0 D8    	LD	BC,-10000
0362+  EB60 CD 7F EB    	CALL	PRTDEC1
0363+  EB63 01 18 FC    	LD	BC,-1000
0364+  EB66 CD 7F EB    	CALL	PRTDEC1
0365+  EB69 01 9C FF    	LD	BC,-100
0366+  EB6C CD 7F EB    	CALL	PRTDEC1
0367+  EB6F 0E F6       	LD	C,-10
0368+  EB71 CD 7F EB    	CALL	PRTDEC1
0369+  EB74 1E 00       	LD	E,0
0370+  EB76 0E FF       	LD	C,-1
0371+  EB78 CD 7F EB    	CALL	PRTDEC1
0372+  EB7B E1          	POP	HL
0373+  EB7C D1          	POP	DE
0374+  EB7D C1          	POP	BC
0375+  EB7E C9          	RET
0376+  EB7F             PRTDEC1:
0377+  EB7F 3E 2F       	LD	A,'0' - 1
0378+  EB81             PRTDEC2:
0379+  EB81 3C          	INC	A
0380+  EB82 09          	ADD	HL,BC
0381+  EB83 38 FC       	JR	C,PRTDEC2
0382+  EB85 ED 42       	SBC	HL,BC
0383+  EB87 BB          	CP	E
0384+  EB88 28 05       	JR	Z,PRTDEC3
0385+  EB8A 1E 00       	LD	E,0
0386+  EB8C CD B6 EA    	CALL	COUT
0387+  EB8F             PRTDEC3:
0388+  EB8F C9          	RET
0389+  EB90             ;
0390+  EB90             ;==================================================================================================
0391+  EB90             ; DATA
0392+  EB90             ;==================================================================================================
0393+  EB90             ;
0394+  EB90 3C 45 4D 50 STR_EMPTY	.TEXT	"<EMPTY>$"
0394+  EB94 54 59 3E 24 
1303   EB98             SIZ_UTIL	.EQU	$ - ORG_UTIL
1304   EB98             		.ECHO	"UTIL occupies "
1305   EB98             		.ECHO	SIZ_UTIL
1306   EB98             		.ECHO	" bytes.\n"
1307   EB98             ;
1308   EB98             ;==================================================================================================
1309   EB98             ; DIAGNOSTICS
1310   EB98             ;==================================================================================================
1311   EB98             ;
1312   EB98~            #IF DSKTRACE
1313   EB98~            ;__________________________________________________________________________________________________
1314   EB98~            PRTSELDSK:
1315   EB98~            	CALL	NEWLINE
1316   EB98~            	PUSH	BC
1317   EB98~            	PUSH	DE
1318   EB98~            	LD	B,E
1319   EB98~            	LD	DE,STR_SELDSK
1320   EB98~            	CALL	WRITESTR
1321   EB98~            	CALL	PC_SPACE
1322   EB98~            	LD	DE,STR_DSK
1323   EB98~            	LD	A,C
1324   EB98~            	CALL	PRTHEXBYTE
1325   EB98~            	CALL	PC_SPACE
1326   EB98~            	CALL	PC_LBKT
1327   EB98~            	LD	A,B
1328   EB98~            	CALL	PRTHEXBYTE
1329   EB98~            	CALL	PC_RBKT
1330   EB98~            	POP	DE
1331   EB98~            	POP	BC
1332   EB98~            	RET
1333   EB98~            ;
1334   EB98~            ;__________________________________________________________________________________________________
1335   EB98~            PRTHOME:
1336   EB98~            	CALL	NEWLINE
1337   EB98~            	LD	DE,STR_HOME
1338   EB98~            	CALL	WRITESTR
1339   EB98~            	RET
1340   EB98~            ;
1341   EB98~            ;__________________________________________________________________________________________________
1342   EB98~            PRTDSKOP:
1343   EB98~            
1344   EB98~            	LD	(XSTKSAV),SP
1345   EB98~            	LD	SP,XSTK
1346   EB98~            	
1347   EB98~            	CALL	NEWLINE
1348   EB98~            	LD	A,(DSKOP)
1349   EB98~            	LD	DE,STR_READ
1350   EB98~            	CP	DOP_READ
1351   EB98~            	CALL	Z,WRITESTR
1352   EB98~            	LD	DE,STR_WRITE
1353   EB98~            	CP	DOP_WRITE
1354   EB98~            	CALL	Z,WRITESTR
1355   EB98~            	LD	A,C
1356   EB98~            	CALL	Z,PRTHEXBYTE
1357   EB98~            	LD	DE,STR_DSK
1358   EB98~            	CALL	WRITESTR
1359   EB98~            	LD	A,(SEKDSK)
1360   EB98~            	CALL	PRTHEXBYTE
1361   EB98~            	LD	DE,STR_TRK
1362   EB98~            	CALL	WRITESTR
1363   EB98~            	LD	BC,(SEKTRK)
1364   EB98~            	CALL	PRTHEXWORD
1365   EB98~            	LD	DE,STR_SEC
1366   EB98~            	CALL	WRITESTR
1367   EB98~            	LD	BC,(SEKSEC)
1368   EB98~            	CALL	PRTHEXWORD
1369   EB98~            	
1370   EB98~            	LD	SP,(XSTKSAV)
1371   EB98~            
1372   EB98~            	RET
1373   EB98~            
1374   EB98~            	RET
1375   EB98~            	
1376   EB98~            XSTKSAV	.DW	0
1377   EB98~            	.FILL	$20
1378   EB98~            XSTK	.EQU	$
1379   EB98~            ;
1380   EB98~            STR_SELDSK	.DB	"SELDSK$"
1381   EB98~            STR_HOME	.DB	"HOME$"
1382   EB98~            STR_READ	.DB	"READ$"
1383   EB98~            STR_WRITE	.DB	"WRITE$"
1384   EB98~            STR_DSK		.DB	" DSK=$"
1385   EB98~            STR_TRK		.DB	" TRK=$"
1386   EB98~            STR_SEC		.DB	" SEC=$"
1387   EB98~            ;
1388   EB98             #ENDIF
1389   EB98             ;
1390   EB98             ;==================================================================================================
1391   EB98             ; DATA
1392   EB98             ;==================================================================================================
1393   EB98             ;
1394   EB98             ;STR_READONLY	.DB 	"\r\nCBIOS Err: Read Only Drive$"
1395   EB98             ;STR_STALE	.DB 	"\r\nCBIOS Err: Stale Drive$"
1396   EB98             ;
1397   EB98 00 00       SECADR		.DW 	0		; ADDRESS OF SECTOR IN ROM/RAM PAGE
1398   EB9A 00          DEFDRIVE	.DB	0		; DEFAULT DRIVE
1399   EB9B 00 70       CCPBUF		.DW	$7000		; ADDRESS OF CCP BUF IN BIOS BANK
1400   EB9D             ;
1401   EB9D             ; DOS DISK VARIABLES
1402   EB9D             ;
1403   EB9D 00          DSKOP:		.DB	0		; DISK OPERATION (DOP_READ/DOP_WRITE)
1404   EB9E 00          WRTYPE:		.DB 	0		; WRITE TYPE (0=NORMAL, 1=DIR (FORCE), 2=FIRST RECORD OF BLOCK)
1405   EB9F 00 00       DMAADR:		.DW 	0		; DIRECT MEMORY ADDRESS
1406   EBA1 00          HSTWRT:		.DB	0		; TRUE = BUFFER IS DIRTY
1407   EBA2 00 7C       BUFADR:		.DW	$8000-$0400	; ADDRESS OF PHYSICAL SECTOR BUFFER (DEFAULT MATCHES HBIOS)
1408   EBA4             ;
1409   EBA4             ; DISK I/O REQUEST PENDING
1410   EBA4             ;
1411   EBA4             SEK:
1412   EBA4 00          SEKDSK:		.DB 	0		; DISK NUMBER 0-15
1413   EBA5 00 00       SEKTRK:		.DW 	0		; TWO BYTES FOR TRACK # (LOGICAL)
1414   EBA7 00 00       SEKSEC:		.DW 	0		; TWO BYTES FOR SECTOR # (LOGICAL)
1415   EBA9 00          SEKDU:		.DB 	0		; DEVICE/UNIT
1416   EBAA 00 00       SEKDPH:		.DW	0		; ADDRESS OF ACTIVE (SELECTED) DPH
1417   EBAC 00 00       SEKOFF:		.DW	0		; TRACK OFFSET IN EFFECT FOR LU
1418   EBAE 01          SEKACT:		.DB	TRUE		; ALWAYS TRUE!
1419   EBAF             ;
1420   EBAF             ; RESULT OF CPM TO PHYSICAL TRANSLATION
1421   EBAF             ;
1422   EBAF             XLT:
1423   EBAF 00          XLTDSK		.DB	0
1424   EBB0 00 00       XLTTRK		.DW	0
1425   EBB2 00 00       XLTSEC		.DW	0
1426   EBB4 00          XLTDU		.DB	0
1427   EBB5 00 00       XLTDPH		.DW	0
1428   EBB7 00 00       XLTOFF:		.DW	0
1429   EBB9 01          XLTACT		.DB	TRUE		; ALWAYS TRUE!
1430   EBBA             ;
1431   EBBA             XLTSIZ		.EQU	$ - XLT
1432   EBBA             ;
1433   EBBA             ; DSK/TRK/SEC IN BUFFER (VALID WHEN HSTACT=TRUE)
1434   EBBA             ;
1435   EBBA             HST:
1436   EBBA 00          HSTDSK		.DB	0		; DISK IN BUFFER
1437   EBBB 00 00       HSTTRK		.DW	0		; TRACK IN BUFFER
1438   EBBD 00 00       HSTSEC		.DW	0		; SECTOR IN BUFFER
1439   EBBF 00          HSTDU		.DB	0		; DEVICE/UNIT IN BUFFER
1440   EBC0 00 00       HSTDPH		.DW	0		; CURRENT DPH ADDRESS
1441   EBC2 00 00       HSTOFF		.DW	0		; TRACK OFFSET IN EFFECT FOR LU
1442   EBC4 00          HSTACT		.DB	0		; TRUE = BUFFER HAS VALID DATA
1443   EBC5             ;
1444   EBC5             ; SEQUENTIAL WRITE TRACKING FOR UNALLOCATED BLOCK
1445   EBC5             ;
1446   EBC5             UNA:
1447   EBC5 00          UNADSK:		.DB 	0		; DISK NUMBER 0-15
1448   EBC6 00 00       UNATRK:		.DW 	0		; TWO BYTES FOR TRACK # (LOGICAL)
1449   EBC8 00 00       UNASEC:		.DW 	0		; TWO BYTES FOR SECTOR # (LOGICAL)
1450   EBCA             ;
1451   EBCA             UNASIZ		.EQU	$ - UNA
1452   EBCA             ;
1453   EBCA 00          UNACNT:		.DB	0		; COUNT DOWN UNALLOCATED RECORDS IN BLOCK
1454   EBCB 00 00       UNASPT:		.DW	0		; SECTORS PER TRACK
1455   EBCD             ;
1456   EBCD             ;==================================================================================================
1457   EBCD             ; DISK CONTROL STRUCTURES (DPB, DPH)
1458   EBCD             ;==================================================================================================
1459   EBCD             ;
1460   EBCD             RAMBLKS		.EQU	(((BID_RAMDN - BID_RAMD0 + 1) * 32) / 2)
1461   EBCD             CKS_RAM		.EQU	0			; CKS: 0 FOR NON-REMOVABLE MEDIA
1462   EBCD             ALS_RAM		.EQU	((RAMBLKS + 7) / 8)	; ALS: BLKS / 8 (ROUNDED UP)
1463   EBCD             ;
1464   EBCD             ROMBLKS		.EQU	(((BID_ROMDN - BID_ROMD0 + 1) * 32) / 2)
1465   EBCD             CKS_ROM		.EQU	0			; CKS: 0 FOR NON-REMOVABLE MEDIA
1466   EBCD             ALS_ROM		.EQU	((ROMBLKS + 7) / 8)	; ALS: BLKS / 8 (ROUNDED UP)
1467   EBCD             ;
1468   EBCD             CKS_FD		.EQU	64			; CKS: DIR ENT / 4 = 256 / 4 = 64
1469   EBCD             ALS_FD		.EQU	128			; ALS: BLKS / 8 = 1024 / 8 = 128
1470   EBCD             ;
1471   EBCD             CKS_HD		.EQU	0			; CKS: 0 FOR NON-REMOVABLE MEDIA
1472   EBCD             ALS_HD		.EQU	256			; ALS: BLKS / 8 = 2048 / 8 = 256 (ROUNDED UP)
1473   EBCD             ;
1474   EBCD             ;
1475   EBCD             ; DISK PARAMETER BLOCKS
1476   EBCD             ;
1477   EBCD             ; BLS		BSH	BLM	EXM (DSM<256)	EXM (DSM>255)
1478   EBCD             ; ----------	---	---	-------------	-------------
1479   EBCD             ; 1,024		3	7	0		N/A
1480   EBCD             ; 2,048 	4	15	1		0
1481   EBCD             ; 4,096 	5	31	3		1
1482   EBCD             ; 8,192 	6	63	7		3
1483   EBCD             ; 16,384 	7	127	15		7
1484   EBCD             ;
1485   EBCD             ; AL0/1: EACH BIT SET ALLOCATES A BLOCK OF DIR ENTRIES.  EACH DIR ENTRY
1486   EBCD             ;        IS 32 BYTES.  BIT COUNT = (((DRM + 1) * 32) / BLS)
1487   EBCD             ;
1488   EBCD             ; CKS = (DIR ENT / 4), ZERO FOR NON-REMOVABLE MEDIA
1489   EBCD             ;
1490   EBCD             ; ALS = TOTAL BLKS (DSM + 1) / 8
1491   EBCD             ;__________________________________________________________________________________________________
1492   EBCD             ;
1493   EBCD             ; ROM DISK: 64 SECS/TRK (LOGICAL), 128 BYTES/SEC
1494   EBCD             ; BLOCKSIZE (BLS) = 2K, DIRECTORY ENTRIES = 256
1495   EBCD             ; ROM DISK SIZE = TOTAL ROM - 32K RESERVED FOR SYSTEM USE
1496   EBCD             ;
1497   EBCD 00 00       	.DW	CKS_ROM
1498   EBCF 18 00       	.DW	ALS_ROM
1499   EBD1 10          	.DB	(2048 / 128)	; RECORDS PER BLOCK (BLS / 128)
1500   EBD2             DPB_ROM:
1501   EBD2 40 00       	.DW  	64		; SPT: SECTORS PER TRACK
1502   EBD4 04          	.DB  	4		; BSH: BLOCK SHIFT FACTOR
1503   EBD5 0F          	.DB  	15		; BLM: BLOCK MASK
1504   EBD6             #IF ((ROMBLKS - 1) < 256)
1505   EBD6 01          	.DB  	1		; EXM: EXTENT MASK
1506   EBD7~            #ELSE
1507   EBD7~            	.DB  	0		; EXM: EXTENT MASK
1508   EBD7             #ENDIF
1509   EBD7 BF 00       	.DW	ROMBLKS - 1	; DSM: TOTAL STORAGE IN BLOCKS - 1
1510   EBD9 FF 00       	.DW  	255		; DRM: DIR ENTRIES - 1 = 255
1511   EBDB F0          	.DB  	11110000B	; AL0: DIR BLK BIT MAP, FIRST BYTE
1512   EBDC 00          	.DB  	00000000B	; AL1: DIR BLK BIT MAP, SECOND BYTE
1513   EBDD 00 00       	.DW  	0		; CKS: ZERO FOR NON-REMOVABLE MEDIA
1514   EBDF 00 00       	.DW  	0		; OFF: ROM DISK HAS NO SYSTEM AREA
1515   EBE1             ;__________________________________________________________________________________________________
1516   EBE1             ;
1517   EBE1             ; RAM DISK: 64 SECS/TRK, 128 BYTES/SEC
1518   EBE1             ; BLOCKSIZE (BLS) = 2K, DIRECTORY ENTRIES = 256
1519   EBE1             ; RAM DISK SIZE = TOTAL RAM - 64K RESERVED FOR SYSTEM USE
1520   EBE1             ;
1521   EBE1 00 00       	.DW	CKS_RAM
1522   EBE3 18 00       	.DW	ALS_RAM
1523   EBE5 10          	.DB	(2048 / 128)	; RECORDS PER BLOCK (BLS / 128)
1524   EBE6             DPB_RAM:
1525   EBE6 40 00       	.DW  	64		; SPT: SECTORS PER TRACK
1526   EBE8 04          	.DB  	4		; BSH: BLOCK SHIFT FACTOR
1527   EBE9 0F          	.DB  	15		; BLM: BLOCK MASK
1528   EBEA             #IF ((RAMBLKS - 1) < 256)
1529   EBEA 01          	.DB  	1		; EXM: EXTENT MASK
1530   EBEB~            #ELSE
1531   EBEB~            	.DB  	0		; EXM: EXTENT MASK
1532   EBEB             #ENDIF
1533   EBEB BF 00       	.DW	RAMBLKS - 1	; DSM: TOTAL STORAGE IN BLOCKS - 1
1534   EBED FF 00       	.DW  	255		; DRM: DIR ENTRIES - 1 = 255
1535   EBEF F0          	.DB  	11110000B	; AL0: DIR BLK BIT MAP, FIRST BYTE
1536   EBF0 00          	.DB  	00000000B	; AL1: DIR BLK BIT MAP, SECOND BYTE
1537   EBF1 00 00       	.DW  	0		; CKS: ZERO FOR NON-REMOVABLE MEDIA
1538   EBF3 00 00       	.DW  	0		; OFF: RESERVED TRACKS = 0 TRK
1539   EBF5             ;__________________________________________________________________________________________________
1540   EBF5             ;
1541   EBF5             ; 4MB RAM FLOPPY DRIVE, 32 TRKS, 1024 SECS/TRK, 128 BYTES/SEC
1542   EBF5             ; BLOCKSIZE (BLS) = 2K, DIRECTORY ENTRIES = 256
1543   EBF5             ; SEC/TRK ENGINEERED SO THAT AFTER DEBLOCKING, SECTOR NUMBER OCCUPIES 1 BYTE (0-255)
1544   EBF5             ;
1545   EBF5 00 00       	.DW	CKS_HD
1546   EBF7 00 01       	.DW	ALS_HD
1547   EBF9 10          	.DB	(2048 / 128)	; RECORDS PER BLOCK (BLS / 128)
1548   EBFA             DPB_RF:
1549   EBFA 00 04       	.DW  	1024		; SPT: SECTORS PER TRACK
1550   EBFC 04          	.DB  	4		; BSH: BLOCK SHIFT FACTOR
1551   EBFD 0F          	.DB  	15		; BLM: BLOCK MASK
1552   EBFE 00          	.DB  	0		; EXM: EXTENT MASK
1553   EBFF FF 07       	.DW  	2047		; DSM: TOTAL STORAGE IN BLOCKS - 1 BLK = (4MB / 2K BLS) - 1 = 2047
1554   EC01 FF 00       	.DW  	255		; DRM: DIR ENTRIES - 1 = 256 - 1 = 255
1555   EC03 F0          	.DB  	11110000B	; AL0: DIR BLK BIT MAP, FIRST BYTE
1556   EC04 00          	.DB  	00000000B	; AL1: DIR BLK BIT MAP, SECOND BYTE
1557   EC05 00 00       	.DW  	0		; CKS: ZERO FOR NON-REMOVABLE MEDIA
1558   EC07 00 00       	.DW  	0		; OFF: RESERVED TRACKS = 0 TRK
1559   EC09             ;__________________________________________________________________________________________________
1560   EC09             ;
1561   EC09             ; GENERIC HARD DISK DRIVE (8MB DATA SPACE + 128K RESERVED SPACE)
1562   EC09             ;   LOGICAL: 1040 TRKS (16 RESERVED), 64 SECS/TRK, 128 BYTES/SEC
1563   EC09             ;   PHYSICAL: 65 CYLS (1 RESERVED), 16 HEADS/CYL, 16 SECS/TRK, 512 BYTES/SEC
1564   EC09             ;   BLOCKSIZE (BLS) = 4K, DIRECTORY ENTRIES = 512
1565   EC09             ;
1566   EC09 00 00       	.DW	CKS_HD
1567   EC0B 00 01       	.DW	ALS_HD
1568   EC0D 20          	.DB	(4096 / 128)	; RECORDS PER BLOCK (BLS / 128)
1569   EC0E             DPB_HD:
1570   EC0E 40 00       	.DW  	64		; SPT: SECTORS PER TRACK
1571   EC10 05          	.DB  	5		; BSH: BLOCK SHIFT FACTOR
1572   EC11 1F          	.DB  	31		; BLM: BLOCK MASK
1573   EC12 01          	.DB  	1		; EXM: EXTENT MASK
1574   EC13 FF 07       	.DW  	2047		; DSM: TOTAL STORAGE IN BLOCKS - 1 = (8MB / 4K BLS) - 1 = 2047
1575   EC15 FF 01       	.DW  	511		; DRM: DIR ENTRIES - 1 = 512 - 1 = 511
1576   EC17 F0          	.DB  	11110000B	; AL0: DIR BLK BIT MAP, FIRST BYTE
1577   EC18 00          	.DB  	00000000B	; AL1: DIR BLK BIT MAP, SECOND BYTE
1578   EC19 00 00       	.DW  	0		; CKS: DIRECTORY CHECK VECTOR SIZE = 256 / 4
1579   EC1B 10 00       	.DW  	16		; OFF: RESERVED TRACKS = 16 TRKS * (16 TRKS * 16 HEADS * 16 SECS * 512 BYTES) = 128K
1580   EC1D             ;__________________________________________________________________________________________________
1581   EC1D             ;
1582   EC1D             ; IBM 720KB 3.5" FLOPPY DRIVE, 80 TRKS, 36 SECS/TRK, 512 BYTES/SEC
1583   EC1D             ; BLOCKSIZE (BLS) = 2K, DIRECTORY ENTRIES = 128
1584   EC1D             ;
1585   EC1D 40 00       	.DW	CKS_FD
1586   EC1F 80 00       	.DW	ALS_FD
1587   EC21 10          	.DB	(2048 / 128)	; RECORDS PER BLOCK (BLS / 128)
1588   EC22             DPB_FD720:
1589   EC22 24 00       	.DW  	36		; SPT: SECTORS PER TRACK
1590   EC24 04          	.DB  	4		; BSH: BLOCK SHIFT FACTOR
1591   EC25 0F          	.DB  	15		; BLM: BLOCK MASK
1592   EC26 00          	.DB  	0		; EXM: EXTENT MASK
1593   EC27 5E 01       	.DW  	350		; DSM: TOTAL STORAGE IN BLOCKS - 1 BLK = ((720K - 18K OFF) / 2K BLS) - 1 = 350
1594   EC29 7F 00       	.DW  	127		; DRM: DIR ENTRIES - 1 = 128 - 1 = 127
1595   EC2B C0          	.DB  	11000000B	; AL0: DIR BLK BIT MAP, FIRST BYTE
1596   EC2C 00          	.DB  	00000000B	; AL1: DIR BLK BIT MAP, SECOND BYTE
1597   EC2D 20 00       	.DW  	32		; CKS: DIRECTORY CHECK VECTOR SIZE = 128 / 4
1598   EC2F 04 00       	.DW  	4		; OFF: RESERVED TRACKS = 4 TRKS * (512 B/SEC * 36 SEC/TRK) = 18K
1599   EC31             ;__________________________________________________________________________________________________
1600   EC31             ;
1601   EC31             ; IBM 1.44MB 3.5" FLOPPY DRIVE, 80 TRKS, 72 SECS/TRK, 512 BYTES/SEC
1602   EC31             ; BLOCKSIZE (BLS) = 2K, DIRECTORY ENTRIES = 256
1603   EC31             ;
1604   EC31 40 00       	.DW	CKS_FD
1605   EC33 80 00       	.DW	ALS_FD
1606   EC35 10          	.DB	(2048 / 128)	; RECORDS PER BLOCK (BLS / 128)
1607   EC36             DPB_FD144:
1608   EC36 48 00       	.DW  	72		; SPT: SECTORS PER TRACK
1609   EC38 04          	.DB  	4		; BSH: BLOCK SHIFT FACTOR
1610   EC39 0F          	.DB  	15		; BLM: BLOCK MASK
1611   EC3A 00          	.DB  	0		; EXM: EXTENT MASK
1612   EC3B C6 02       	.DW  	710		; DSM: TOTAL STORAGE IN BLOCKS - 1 BLK = ((1,440K - 18K OFF) / 2K BLS) - 1 = 710
1613   EC3D FF 00       	.DW  	255		; DRM: DIR ENTRIES - 1 = 256 - 1 = 255
1614   EC3F F0          	.DB  	11110000B	; AL0: DIR BLK BIT MAP, FIRST BYTE
1615   EC40 00          	.DB  	00000000B	; AL1: DIR BLK BIT MAP, SECOND BYTE
1616   EC41 40 00       	.DW  	64		; CKS: DIRECTORY CHECK VECTOR SIZE = 256 / 4
1617   EC43 02 00       	.DW  	2		; OFF: RESERVED TRACKS = 2 TRKS * (512 B/SEC * 72 SEC/TRK) = 18K
1618   EC45             ;__________________________________________________________________________________________________
1619   EC45             ;
1620   EC45             ; IBM 360KB 5.25" FLOPPY DRIVE, 40 TRKS, 9 SECS/TRK, 512 BYTES/SEC
1621   EC45             ; BLOCKSIZE (BLS) = 2K, DIRECTORY ENTRIES = 128
1622   EC45             ;
1623   EC45 40 00       	.DW	CKS_FD
1624   EC47 80 00       	.DW	ALS_FD
1625   EC49 10          	.DB	(2048 / 128)	; RECORDS PER BLOCK (BLS / 128)
1626   EC4A             DPB_FD360:
1627   EC4A 24 00       	.DW  	36		; SPT: SECTORS PER TRACK
1628   EC4C 04          	.DB  	4		; BSH: BLOCK SHIFT FACTOR
1629   EC4D 0F          	.DB  	15		; BLM: BLOCK MASK
1630   EC4E 01          	.DB  	1		; EXM: EXTENT MASK
1631   EC4F AA 00       	.DW  	170		; DSM: TOTAL STORAGE IN BLOCKS - 1 BLK = ((360K - 18K OFF) / 2K BLS) - 1 = 170
1632   EC51 7F 00       	.DW  	127		; DRM: DIR ENTRIES - 1 = 128 - 1 = 127
1633   EC53 F0          	.DB  	11110000B	; AL0: DIR BLK BIT MAP, FIRST BYTE
1634   EC54 00          	.DB  	00000000B	; AL1: DIR BLK BIT MAP, SECOND BYTE
1635   EC55 20 00       	.DW  	32		; CKS: DIRECTORY CHECK VECTOR SIZE = 128 / 4
1636   EC57 04 00       	.DW  	4		; OFF: RESERVED TRACKS = 4 TRKS * (512 B/SEC * 36 SEC/TRK) = 18K
1637   EC59             ;__________________________________________________________________________________________________
1638   EC59             ;
1639   EC59             ; IBM 1.20MB 5.25" FLOPPY DRIVE, 80 TRKS, 15 SECS/TRK, 512 BYTES/SEC
1640   EC59             ; BLOCKSIZE (BLS) = 2K, DIRECTORY ENTRIES = 256
1641   EC59             ;
1642   EC59 40 00       	.DW	CKS_FD
1643   EC5B 80 00       	.DW	ALS_FD
1644   EC5D 10          	.DB	(2048 / 128)	; RECORDS PER BLOCK (BLS / 128)
1645   EC5E             DPB_FD120:
1646   EC5E 3C 00       	.DW  	60		; SPT: SECTORS PER TRACK
1647   EC60 04          	.DB  	4		; BSH: BLOCK SHIFT FACTOR
1648   EC61 0F          	.DB  	15		; BLM: BLOCK MASK
1649   EC62 00          	.DB  	0		; EXM: EXTENT MASK
1650   EC63 4F 02       	.DW  	591		; DSM: TOTAL STORAGE IN BLOCKS - 1 BLK = ((1,200K - 15K OFF) / 2K BLS) - 1 = 591
1651   EC65 FF 00       	.DW  	255		; DRM: DIR ENTRIES - 1 = 256 - 1 = 255
1652   EC67 F0          	.DB  	11110000B	; AL0: DIR BLK BIT MAP, FIRST BYTE
1653   EC68 00          	.DB  	00000000B	; AL1: DIR BLK BIT MAP, SECOND BYTE
1654   EC69 40 00       	.DW  	64		; CKS: DIRECTORY CHECK VECTOR SIZE = 256 / 4
1655   EC6B 02 00       	.DW  	2		; OFF: RESERVED TRACKS = 2 TRKS * (512 B/SEC * 60 SEC/TRK) = 15K
1656   EC6D             ;__________________________________________________________________________________________________
1657   EC6D             ;
1658   EC6D             ; IBM 1.11MB 8" FLOPPY DRIVE, 77 TRKS, 15 SECS/TRK, 512 BYTES/SEC
1659   EC6D             ; BLOCKSIZE (BLS) = 2K, DIRECTORY ENTRIES = 256
1660   EC6D             ;
1661   EC6D 40 00       	.DW	CKS_FD
1662   EC6F 80 00       	.DW	ALS_FD
1663   EC71 10          	.DB	(2048 / 128)	; RECORDS PER BLOCK (BLS / 128)
1664   EC72             DPB_FD111:
1665   EC72 3C 00       	.DW  	60		; SPT: SECTORS PER TRACK
1666   EC74 04          	.DB  	4		; BSH: BLOCK SHIFT FACTOR
1667   EC75 0F          	.DB  	15		; BLM: BLOCK MASK
1668   EC76 00          	.DB  	0		; EXM: EXTENT MASK
1669   EC77 39 02       	.DW  	569		; DSM: TOTAL STORAGE IN BLOCKS - 1 BLK = ((1,155K - 15K OFF) / 2K BLS) - 1 = 569
1670   EC79 FF 00       	.DW  	255		; DRM: DIR ENTRIES - 1 = 256 - 1 = 255
1671   EC7B F0          	.DB  	11110000B	; AL0: DIR BLK BIT MAP, FIRST BYTE
1672   EC7C 00          	.DB  	00000000B	; AL1: DIR BLK BIT MAP, SECOND BYTE
1673   EC7D 40 00       	.DW  	64		; CKS: DIRECTORY CHECK VECTOR SIZE = 256 / 4
1674   EC7F 02 00       	.DW  	2		; OFF: RESERVED TRACKS = 2 TRKS * (512 B/SEC * 60 SEC/TRK) = 15K
1675   EC81             ;
1676   EC81~            #IF (PLATFORM == PLT_UNA)
1677   EC81~            SECBUF	.FILL	512,0	; PHYSICAL DISK SECTOR BUFFER
1678   EC81             #ENDIF
1679   EC81             ;
1680   EC81             ;==================================================================================================
1681   EC81             ; CBIOS BUFFERS
1682   EC81             ;==================================================================================================
1683   EC81             ;
1684   EC81             ;BUFFERS:
1685   EC81             ;
1686   EC81             BUFPOOL	.EQU	$		; START OF BUFFER POOL
1687   EC81             ;
1688   EC81             ;==================================================================================================
1689   EC81             ; COLD BOOT INITIALIZATION
1690   EC81             ;
1691   EC81             ; THIS CODE IS PLACED IN THE BDOS BUFFER AREA TO CONSERVE SPACE.  SINCE
1692   EC81             ; COLD BOOT DOES NO DISK IO, SO THIS IS SAFE.
1693   EC81             ;
1694   EC81             ;==================================================================================================
1695   EC81             ;
1696   EC81 00 00 00 00 	.FILL	16 * 4,0		; RESERVED FOR DRVMAP TABLE
1696   EC85 00 00 00 00 
1696   EC89 00 00 00 00 
1696   EC8D 00 00 00 00 
1696   EC91 00 00 00 00 
1696   EC95 00 00 00 00 
1696   EC99 00 00 00 00 
1696   EC9D 00 00 00 00 
1696   ECA1 00 00 00 00 
1696   ECA5 00 00 00 00 
1696   ECA9 00 00 00 00 
1696   ECAD 00 00 00 00 
1696   ECB1 00 00 00 00 
1696   ECB5 00 00 00 00 
1696   ECB9 00 00 00 00 
1696   ECBD 00 00 00 00 
1697   ECC1 00 00 00 00 	.FILL	16 * 16,0		; RESERVED FOR DPH TABLE
1697   ECC5 00 00 00 00 
1697   ECC9 00 00 00 00 
1697   ECCD 00 00 00 00 
1697   ECD1 00 00 00 00 
1697   ECD5 00 00 00 00 
1697   ECD9 00 00 00 00 
1697   ECDD 00 00 00 00 
1697   ECE1 00 00 00 00 
1697   ECE5 00 00 00 00 
1697   ECE9 00 00 00 00 
1697   ECED 00 00 00 00 
1697   ECF1 00 00 00 00 
1697   ECF5 00 00 00 00 
1697   ECF9 00 00 00 00 
1697   ECFD 00 00 00 00 
1697   ED01 00 00 00 00 
1697   ED05 00 00 00 00 
1697   ED09 00 00 00 00 
1697   ED0D 00 00 00 00 
1697   ED11 00 00 00 00 
1697   ED15 00 00 00 00 
1697   ED19 00 00 00 00 
1697   ED1D 00 00 00 00 
1697   ED21 00 00 00 00 
1697   ED25 00 00 00 00 
1697   ED29 00 00 00 00 
1697   ED2D 00 00 00 00 
1697   ED31 00 00 00 00 
1697   ED35 00 00 00 00 
1697   ED39 00 00 00 00 
1697   ED3D 00 00 00 00 
1697   ED41 00 00 00 00 
1697   ED45 00 00 00 00 
1697   ED49 00 00 00 00 
1697   ED4D 00 00 00 00 
1697   ED51 00 00 00 00 
1697   ED55 00 00 00 00 
1697   ED59 00 00 00 00 
1697   ED5D 00 00 00 00 
1697   ED61 00 00 00 00 
1697   ED65 00 00 00 00 
1697   ED69 00 00 00 00 
1697   ED6D 00 00 00 00 
1697   ED71 00 00 00 00 
1697   ED75 00 00 00 00 
1697   ED79 00 00 00 00 
1697   ED7D 00 00 00 00 
1697   ED81 00 00 00 00 
1697   ED85 00 00 00 00 
1697   ED89 00 00 00 00 
1697   ED8D 00 00 00 00 
1697   ED91 00 00 00 00 
1697   ED95 00 00 00 00 
1697   ED99 00 00 00 00 
1697   ED9D 00 00 00 00 
1697   EDA1 00 00 00 00 
1697   EDA5 00 00 00 00 
1697   EDA9 00 00 00 00 
1697   EDAD 00 00 00 00 
1697   EDB1 00 00 00 00 
1697   EDB5 00 00 00 00 
1697   EDB9 00 00 00 00 
1697   EDBD 00 00 00 00 
1698   EDC1             ;
1699   EDC1             INIT:
1700   EDC1             	; THIS INIT CODE WILL BE OVERLAID, SO WE ARE GOING
1701   EDC1             	; TO MODIFY THE BOOT ENTRY POINT TO CAUSE A PANIC
1702   EDC1             	; TO EASILY IDENTIFY IF SOMETHING TRIES TO INVOKE
1703   EDC1             	; THE BOOT ENTRY POINT AFTER INIT IS DONE.
1704   EDC1 3E CD       	LD	A,$CD			; "CALL" INSTRUCTION
1705   EDC3 32 65 E6    	LD	(BOOT),A		; STORE IT BOOT ENTRY POINT
1706   EDC6 21 66 EA    	LD	HL,PANIC		; ADDRESS OF PANIC ROUTINE
1707   EDC9 22 66 E6    	LD	(BOOT+1),HL		; STORE IT AT BOOT ENTRY + 1
1708   EDCC             	
1709   EDCC~            #IF (PLATFORM == PLT_UNA)
1710   EDCC~            	; MAKE SURE UNA EXEC PAGE IS ACTIVE
1711   EDCC~            	LD	BC,$01FB		; UNA FUNC = SET BANK
1712   EDCC~            	LD	DE,BID_USR		; SWITCH BACK TO EXEC BANK
1713   EDCC~            	CALL	$FFFD			; DO IT (RST 08 NOT SAFE HERE)
1714   EDCC~            
1715   EDCC~            	; INSTALL UNA INVOCATION VECTOR FOR RST 08
1716   EDCC~            	LD	A,$C3			; JP INSTRUCTION
1717   EDCC~            	LD	(8),A			; STORE AT 0x0008
1718   EDCC~            	LD	HL,($FFFE)		; UNA ENTRY VECTOR
1719   EDCC~            	LD	(9),HL			; STORE AT 0x0009
1720   EDCC             #ELSE
1721   EDCC             	; MAKE SURE USER BANK IS ACTIVE
1722   EDCC 06 F0       	LD	B,BF_SYSSETBNK
1723   EDCE 0E 8E       	LD	C,BID_USR
1724   EDD0 CD F0 FF    	CALL	$FFF0
1725   EDD3             	
1726   EDD3             	; INSTALL HBIOS INVOCATION VECTOR FOR RST 08
1727   EDD3 3E C3       	LD	A,$C3			; JP INSTRUCTION
1728   EDD5 32 08 00    	LD	(8),A			; STORE AT 0x0008
1729   EDD8 2A F1 FF    	LD	HL,($FFF1)		; HBIOS ENTRY VECTOR
1730   EDDB 22 09 00    	LD	(9),HL			; STORE AT 0x0009
1731   EDDE             #ENDIF
1732   EDDE             
1733   EDDE             	; PARAMETER INITIALIZATION
1734   EDDE 3E 00       	LD	A,DEFIOBYTE		; LOAD DEFAULT IOBYTE
1735   EDE0 32 03 00    	LD	(IOBYTE),A		; STORE IT
1736   EDE3             
1737   EDE3             #IF ((PLATFORM != PLT_N8) & (PLATFORM != PLT_MK4) & (PLATFORM != PLT_S100) & (PLATFORM != PLT_UNA))
1738   EDE3 DB 70       	IN	A,(RTC)			; RTC PORT, BIT 6 HAS STATE OF CONFIG JUMPER
1739   EDE5 CB 77       	BIT	6,A			; BIT 6 HAS CONFIG JUMPER STATE
1740   EDE7 3E 00       	LD	A,DEFIOBYTE		; ASSUME WE WANT DEFAULT IOBYTE VALUE
1741   EDE9 20 02       	JR	NZ,INIT1		; IF BIT6=1, NOT SHORTED, CONTINUE WITH DEFAULT
1742   EDEB 3E 00       	LD	A,ALTIOBYTE		; LOAD ALT IOBYTE VALUE
1743   EDED             INIT1:	
1744   EDED 32 03 00    	LD	(IOBYTE),A		; SET THE ACTIVE IOBYTE
1745   EDF0             #ENDIF
1746   EDF0             
1747   EDF0             	; INIT DEFAULT DRIVE TO A: FOR NOW
1748   EDF0 AF          	XOR	A			; ZERO
1749   EDF1 32 9A EB    	LD	(DEFDRIVE),A		; STORE IT
1750   EDF4             	
1751   EDF4             	; STARTUP MESSAGE
1752   EDF4 CD 1C EA    	CALL	NEWLINE			; FORMATTING
1753   EDF7 11 51 EE    	LD	DE,STR_BANNER		; POINT TO BANNER
1754   EDFA CD 56 EA    	CALL	WRITESTR		; DISPLAY IT
1755   EDFD CD 1C EA    	CALL	NEWLINE			; FORMATTING
1756   EE00             
1757   EE00~            #IF (PLATFORM == PLT_UNA)
1758   EE00~            	; SAVE COMMAND PROCESSOR IMAGE TO MALLOCED CACHE IN UNA BIOS PAGE
1759   EE00~            	LD	C,$F7		; UNA MALLOC
1760   EE00~            	LD	DE,CCP_SIZ	; SIZE OF CCP
1761   EE00~            	RST	08		; DO IT
1762   EE00~            	CALL	NZ,PANIC	; BIG PROBLEM
1763   EE00~            	LD	(CCPBUF),HL	; SAVE THE ADDRESS (IN BIOS MEM)
1764   EE00~            
1765   EE00~            	LD	BC,$01FB	; UNA FUNC = SET BANK
1766   EE00~            	LD	DE,BID_BIOS	; UBIOS_PAGE (SEE PAGES.INC)
1767   EE00~            	RST	08		; DO IT
1768   EE00~            	PUSH	DE		; SAVE PREVIOUS BANK
1769   EE00~            
1770   EE00~            	LD	HL,CPM_LOC	; ADDRESS IN HI MEM OF CCP
1771   EE00~            	LD	DE,(CCPBUF)	; ADDRESS OF CCP BUF IN BIOS MEM
1772   EE00~            	LD	BC,CCP_SIZ	; SIZE OF CCP
1773   EE00~            	LDIR			; DO IT
1774   EE00~            
1775   EE00~            	LD	BC,$01FB	; UNA FUNC = SET BANK
1776   EE00~            	POP	DE		; RECOVER OPERATING BANK
1777   EE00~            	RST	08		; DO IT
1778   EE00             #ELSE
1779   EE00             	; SAVE COMMAND PROCESSOR TO DEDICATED CACHE IN RAM BANK 1
1780   EE00 06 F3       	LD	B,BF_SYSXCPY	; HBIOS FUNC: SYSTEM EXTENDED COPY
1781   EE02 1E 8E       	LD	E,BID_USR	; E = SRC BANK = USR BANK = TPA
1782   EE04 16 8D       	LD	D,BID_BIOS	; D = DEST BANK = HB BANK
1783   EE06 CF          	RST	08		; DO IT
1784   EE07 06 F2       	LD	B,BF_SYSCPY	; HBIOS FUNC: SYSTEM COPY
1785   EE09 21 00 D0    	LD	HL,CPM_LOC	; COPY FROM CCP LOCATION IN USR BANK
1786   EE0C ED 5B 9B EB 	LD	DE,(CCPBUF)	; TO FIXED LOCATION IN HB BANK
1787   EE10 DD 21 00 08 	LD	IX,CCP_SIZ	; COPY CONTENTS OF COMMAND PROCESSOR
1788   EE14 CF          	RST	08		; DO IT
1789   EE15             #ENDIF
1790   EE15             
1791   EE15             	; DISK SYSTEM INITIALIZATION
1792   EE15 CD C2 E7    	CALL	BLKRES		; RESET DISK (DE)BLOCKING ALGORITHM
1793   EE18 CD 84 EE    	CALL	MD_INIT		; INITIALIZE MEMORY DISK DRIVER (RAM/ROM)
1794   EE1B CD B2 EE    	CALL	DRV_INIT	; INITIALIZE DRIVE MAP
1795   EE1E CD 00 EF    	CALL	DPH_INIT	; INITIALIZE DPH TABLE AND BUFFERS
1796   EE21 CD 1C EA    	CALL	NEWLINE		; FORMATTING
1797   EE24             ;
1798   EE24             	; DISPLAY FREE MEMORY
1799   EE24 11 A8 F0    	LD	DE,STR_LDR	; FORMATTING
1800   EE27 CD 56 EA    	CALL	WRITESTR	; AND PRINT IT
1801   EE2A 21 00 FE    	LD	HL,CBIOS_END	; SUBTRACT HIGH WATER
1802   EE2D ED 5B 8C F0 	LD	DE,(BUFTOP)	; ... FROM TOP OF CBIOS
1803   EE31 B7          	OR	A		; ... WITH CF CLEAR
1804   EE32 ED 52       	SBC	HL,DE		; ... SO HL GETS BYTES FREE
1805   EE34 CD 58 EB    	CALL	PRTDEC		; PRINT IT
1806   EE37 11 6A EE    	LD	DE,STR_MEMFREE	; ADD DESCRIPTION
1807   EE3A CD 56 EA    	CALL	WRITESTR	; AND PRINT IT
1808   EE3D             ;
1809   EE3D 3A 9A EB    	LD	A,(DEFDRIVE)	; GET DEFAULT DRIVE
1810   EE40 32 04 00    	LD	(CDISK),A	; ... AND SETUP CDISK
1811   EE43             ;
1812   EE43             	; SETUP AUTOSTART COMMAND
1813   EE43 21 4F EE    	LD	HL,CMD		; ADDRESS OF STARTUP COMMAND
1814   EE46 11 07 D0    	LD	DE,CCP_LOC + 7	; START OF COMMAND BUFFER IN CCP
1815   EE49 01 02 00    	LD	BC,CMDLEN	; LENGTH OF AUTOSTART COMMAND
1816   EE4C ED B0       	LDIR			; INSTALL IT
1817   EE4E             ;
1818   EE4E C9          	RET
1819   EE4F             ;
1820   EE4F 01          CMD	.DB	CMDLEN - 1
1821   EE50             #IFDEF AUTOCMD
1822   EE50             	.TEXT	AUTOCMD
1823   EE50             #ENDIF
1824   EE50 00          	.DB	0
1825   EE51             CMDLEN	.EQU	$ - CMD
1826   EE51             ;
1827   EE51 43 50 2F 4D STR_BANNER	.DB	OSLBL, " CBIOS v", BIOSVER, "$"
1827   EE55 2D 38 30 20 
1827   EE59 32 2E 32 20 
1827   EE5D 43 42 49 4F 
1827   EE61 53 20 76 32 
1827   EE65 2E 37 2E 30 
1827   EE69 24 
1828   EE6A 20 44 69 73 STR_MEMFREE	.DB	" Disk Buffer Bytes Free\r\n$"
1828   EE6E 6B 20 42 75 
1828   EE72 66 66 65 72 
1828   EE76 20 42 79 74 
1828   EE7A 65 73 20 46 
1828   EE7E 72 65 65 0D 
1828   EE82 0A 24 
1829   EE84             ;
1830   EE84             ;
1831   EE84             ;__________________________________________________________________________________________________
1832   EE84             MD_INIT:
1833   EE84             ;
1834   EE84~            #IF (PLATFORM == PLT_UNA)
1835   EE84~            ;
1836   EE84~            ; INITIALIZE RAM DISK BY FILLING DIRECTORY WITH 'E5' BYTES
1837   EE84~            ; FILL FIRST 8K OF RAM DISK TRACK 1 WITH 'E5'
1838   EE84~            ;
1839   EE84~            #IF (CLRRAMDISK != CLR_NEVER)
1840   EE84~            	LD	BC,$01FB		; UNA FUNC = SET BANK
1841   EE84~            	LD	DE,BID_RAMD0		; FIRST BANK OF RAM DISK
1842   EE84~            	CALL	$FFFD			; DO IT (RST 08 NOT SAFE HERE)
1843   EE84~            
1844   EE84~            #IF (CLRRAMDISK == CLR_AUTO)
1845   EE84~            	; CHECK FIRST 32 DIRECTORY ENTRIES.  IF ANY START WITH AN INVALID
1846   EE84~            	; VALUE, INIT THE RAM DISK.  VALID ENTRIES ARE E5 (EMPTY ENTRY) OR
1847   EE84~            	; 0-15 (USER NUMBER).
1848   EE84~            	LD	HL,0
1849   EE84~            	LD	DE,32
1850   EE84~            	LD	B,32
1851   EE84~            CLRRAM0:
1852   EE84~            	LD	A,(HL)
1853   EE84~            	CP	$E5
1854   EE84~            	JR	Z,CLRRAM1		; E5 IS VALID
1855   EE84~            	CP	16
1856   EE84~            	JR	C,CLRRAM1		; 0-15 IS ALSO VALID
1857   EE84~            	JR	CLRRAM2			; INVALID ENTRY! JUMP TO INIT
1858   EE84~            CLRRAM1:
1859   EE84~            	ADD	HL,DE			; LOOP FOR 32 ENTRIES
1860   EE84~            	DJNZ	CLRRAM0
1861   EE84~            ;	JR	CLRRAM2			; *DEBUG*
1862   EE84~            	JR	CLRRAM3			; ALL ENTRIES VALID, BYPASS INIT
1863   EE84~            CLRRAM2:
1864   EE84~            #ENDIF
1865   EE84~            	LD	BC,$01FB		; UNA FUNC = SET BANK
1866   EE84~            	LD	DE,BID_USR		; SWITCH BACK TO EXEC BANK FOR WRITESTR
1867   EE84~            	CALL	$FFFD			; DO IT (RST 08 NOT SAFE HERE)
1868   EE84~            
1869   EE84~            	LD	DE,STR_INITRAMDISK	; RAM DISK INIT MESSAGE
1870   EE84~            	CALL	WRITESTR		; DISPLAY IT
1871   EE84~            
1872   EE84~            	LD	BC,$01FB		; UNA FUNC = SET BANK
1873   EE84~            	LD	DE,BID_RAMD0		; FIRST BANK OF RAM DISK
1874   EE84~            	CALL	$FFFD			; DO IT (RST 08 NOT SAFE HERE)
1875   EE84~            
1876   EE84~            	LD	HL,0			; SOURCE ADR FOR FILL
1877   EE84~            	LD	BC,$2000		; LENGTH OF FILL IS 8K
1878   EE84~            	LD	A,$E5			; FILL VALUE
1879   EE84~            	CALL	FILL			; DO IT
1880   EE84~            CLRRAM3:
1881   EE84~            	LD	BC,$01FB		; UNA FUNC = SET BANK
1882   EE84~            	LD	DE,BID_USR		; SWITCH BACK TO EXEC BANK
1883   EE84~            	CALL	$FFFD			; DO IT (RST 08 NOT SAFE HERE)
1884   EE84~            
1885   EE84~            #ENDIF
1886   EE84~            
1887   EE84             #ELSE
1888   EE84             ;
1889   EE84             ; INITIALIZE RAM DISK BY FILLING DIRECTORY WITH 'E5' BYTES
1890   EE84             ; FILL FIRST 8K OF RAM DISK TRACK 1 WITH 'E5'
1891   EE84             ;
1892   EE84             #IF (CLRRAMDISK != CLR_NEVER)
1893   EE84 06 F0       	LD	B,BF_SYSSETBNK		; HBIOS FUNC: SET BANK
1894   EE86 0E 80       	LD	C,BID_RAMD0		; FIRST BANK OF RAM DISK
1895   EE88 CD F0 FF    	CALL	$FFF0			; DO IT (RST 08 NOT SAFE)
1896   EE8B             
1897   EE8B~            #IF (CLRRAMDISK == CLR_AUTO)
1898   EE8B~            	; CHECK FIRST 32 DIRECTORY ENTRIES.  IF ANY START WITH AN INVALID
1899   EE8B~            	; VALUE, INIT THE RAM DISK.  VALID ENTRIES ARE E5 (EMPTY ENTRY) OR
1900   EE8B~            	; 0-15 (USER NUMBER).
1901   EE8B~            	LD	HL,0
1902   EE8B~            	LD	DE,32
1903   EE8B~            	LD	B,32
1904   EE8B~            CLRRAM0:
1905   EE8B~            	LD	A,(HL)
1906   EE8B~            	CP	$E5
1907   EE8B~            	JR	Z,CLRRAM1		; E5 IS VALID
1908   EE8B~            	CP	16
1909   EE8B~            	JR	C,CLRRAM1		; 0-15 IS ALSO VALID
1910   EE8B~            	JR	CLRRAM2			; INVALID ENTRY! JUMP TO INIT
1911   EE8B~            CLRRAM1:
1912   EE8B~            	ADD	HL,DE			; LOOP FOR 32 ENTRIES
1913   EE8B~            	DJNZ	CLRRAM0
1914   EE8B~            ;	JR	CLRRAM2			; *DEBUG*
1915   EE8B~            	JR	CLRRAM3			; ALL ENTRIES VALID, BYPASS INIT
1916   EE8B~            CLRRAM2:
1917   EE8B             #ENDIF
1918   EE8B 06 F0       	LD	B,BF_SYSSETBNK		; HBIOS FUNC: SET BANK
1919   EE8D 0E 8E       	LD	C,BID_USR		; SWITCH BACK TO USR BANK
1920   EE8F CD F0 FF    	CALL	$FFF0			; DO IT (RST 08 NOT SAFE)
1921   EE92 11 90 F0    	LD	DE,STR_INITRAMDISK	; RAM DISK INIT MESSAGE
1922   EE95 CD 56 EA    	CALL	WRITESTR		; DISPLAY IT
1923   EE98 06 F0       	LD	B,BF_SYSSETBNK		; HBIOS FUNC: SET BANK
1924   EE9A 0E 80       	LD	C,BID_RAMD0		; SWITCH BACK TO FIRST BANK
1925   EE9C CD F0 FF    	CALL	$FFF0			; DO IT (RST 08 NOT SAFE)
1926   EE9F 21 00 00    	LD	HL,0			; SOURCE ADR FOR FILL
1927   EEA2 01 00 20    	LD	BC,$2000		; LENGTH OF FILL IS 8K
1928   EEA5 3E E5       	LD	A,$E5			; FILL VALUE
1929   EEA7 CD 1C EB    	CALL	FILL			; DO IT
1930   EEAA             CLRRAM3:
1931   EEAA 06 F0       	LD	B,BF_SYSSETBNK		; HBIOS FUNC: SET BANK
1932   EEAC 0E 8E       	LD	C,BID_USR		; USR BANK (TPA)
1933   EEAE CD F0 FF    	CALL	$FFF0			; DO IT (RST 08 NOT SAFE)
1934   EEB1             #ENDIF
1935   EEB1             ;
1936   EEB1             #ENDIF
1937   EEB1             ;
1938   EEB1 C9          	RET
1939   EEB2             ;
1940   EEB2             ;
1941   EEB2             ;__________________________________________________________________________________________________
1942   EEB2~            #IF (PLATFORM == PLT_UNA)
1943   EEB2~            ;
1944   EEB2~            DRV_INIT:
1945   EEB2~            ;
1946   EEB2~            ; PERFORM UBIOS SPECIFIC INITIALIZATION
1947   EEB2~            ; BUILD DRVMAP BASED ON AVAILABLE UBIOS DISK DEVICE LIST
1948   EEB2~            ;
1949   EEB2~            	; GET BOOT DEVICE/UNIT/LU INFO
1950   EEB2~            	LD	BC,$00FC		; UNA FUNC: GET BOOTSTRAP HISTORY
1951   EEB2~            	RST	08			; CALL UNA
1952   EEB2~            	LD	D,L			; SAVE L AS DEVICE/UNIT
1953   EEB2~            	LD	E,0			; LU IS ZERO
1954   EEB2~            	LD	(BOOTVOL),DE		; D -> DEVICE/UNIT, E -> LU
1955   EEB2~            ;
1956   EEB2~            ; PERFORM UNA BIOS SPECIFIC INITIALIZATION
1957   EEB2~            ; UPDATE DRVMAP BASED ON AVAILABLE UNA UNITS
1958   EEB2~            ;
1959   EEB2~            	; SETUP THE DRVMAP STRUCTURE
1960   EEB2~            	LD	HL,(BUFTOP)		; GET CURRENT BUFFER TOP
1961   EEB2~            	INC	HL			; SKIP 1 BYTE FOR ENTRY COUNT PREFIX
1962   EEB2~            	LD	(DRVMAPADR),HL		; SAVE AS DRIVE MAP ADDRESS
1963   EEB2~            	LD	(BUFTOP),HL		; ... AND AS NEW BUFTOP
1964   EEB2~            ;
1965   EEB2~            	LD	B,0			; START WITH UNIT 0
1966   EEB2~            ;
1967   EEB2~            DRV_INIT1:	; LOOP THRU ALL UNITS AVAILABLE
1968   EEB2~            	LD	C,$48			; UNA FUNC: GET DISK TYPE
1969   EEB2~            	LD	L,0			; PRESET UNIT COUNT TO ZERO
1970   EEB2~            	CALL	$FFFD			; CALL UNA, B IS ASSUMED TO BE UNTOUCHED!!!
1971   EEB2~            	LD	A,L			; UNIT COUNT TO A
1972   EEB2~            	OR	A			; PAST END?
1973   EEB2~            	JR	Z,DRV_INIT2		; WE ARE DONE
1974   EEB2~            	PUSH	BC			; SAVE UNIT
1975   EEB2~            	CALL	DRV_INIT3		; PROCESS THE UNIT
1976   EEB2~            	POP	BC			; RESTORE UNIT
1977   EEB2~            	INC	B			; NEXT UNIT
1978   EEB2~            	JR	DRV_INIT1		; LOOP
1979   EEB2~            ;
1980   EEB2~            DRV_INIT2:	; FINALIZE THE DRIVE MAP
1981   EEB2~            	RET				; DONE
1982   EEB2~            ;
1983   EEB2~            DRV_INIT3:	; PROCESS CURRENT UNIT (SEE UNA PROTOIDS.INC)
1984   EEB2~            	LD	A,D			; MOVE DISK TYPE TO A
1985   EEB2~            ;	CALL	PC_LBKT			; *DEBUG*
1986   EEB2~            ;	CALL	PRTHEXBYTE		; *DEBUG*
1987   EEB2~            ;	CALL	PC_RBKT			; *DEBUG*
1988   EEB2~            ;
1989   EEB2~            	CALL	DRV_INIT4		; MAKE A DRIVE MAP ENTRY
1990   EEB2~            	LD	A,D			; LOAD DRIVE TYPE
1991   EEB2~            	CP	$40			; RAM/ROM?
1992   EEB2~            	RET	Z			; DONE IF SO
1993   EEB2~            ;	CP	$??			; FLOPPY DRIVE?
1994   EEB2~            ;	RET	Z			; DONE IF SO
1995   EEB2~            	CALL	DRV_INIT4		; ANOTHER ENTRY FOR HARD DISK
1996   EEB2~            	LD	A,1			; BUT WITH SLICE VALUE OF 1
1997   EEB2~            	INC	HL			; BUMP TO SLICE POSITION
1998   EEB2~            	LD	(HL),A			; SAVE IT
1999   EEB2~            	RET				; DONE
2000   EEB2~            ;
2001   EEB2~            DRV_INIT4:
2002   EEB2~            	; ALLOCATE SPACE IN DRVMAP
2003   EEB2~            	PUSH	BC			; SAVE INCOMING UNIT NUM
2004   EEB2~            	LD	BC,4			; 4 BYTES PER ENTRY
2005   EEB2~            	CALL	ALLOC			; ALLOCATE
2006   EEB2~            	CALL	NZ,PANIC		; SHOULD NEVER ERROR HERE
2007   EEB2~            	PUSH	BC			; MOVE MEM PTR
2008   EEB2~            	POP	HL			; ... TO HL
2009   EEB2~            	POP	BC			; RECOVER UNIT NUM
2010   EEB2~            	LD	(HL),B			; SAVE IT IN FIRST BYTE OF DRV MAP ENTRY
2011   EEB2~            	PUSH	HL			; SAVE HL
2012   EEB2~            	LD	HL,(DRVMAPADR)		; POINT TO DRIVE MAP
2013   EEB2~            	DEC	HL			; BACK TO ENTRY COUNT
2014   EEB2~            	INC	(HL)			; INCREMENT THE ENTRY COUNT
2015   EEB2~            	POP	HL			; RECOVER HL
2016   EEB2~            	RET				; DONE
2017   EEB2~            ;
2018   EEB2             #ELSE
2019   EEB2             ;
2020   EEB2             DRV_INIT:
2021   EEB2             ;
2022   EEB2             ; PERFORM HBIOS SPECIFIC INITIALIZATION
2023   EEB2             ; BUILD DRVMAP BASED ON AVAILABLE HBIOS DISK DEVICE LIST
2024   EEB2             ;
2025   EEB2             	; GET BOOT DEVICE/UNIT/LU INFO
2026   EEB2 06 F4       	LD	B,BF_SYSATTR		; HBIOS FUNC: GET/SET ATTR
2027   EEB4 0E 00       	LD	C,AID_BOOTVOL		; ATTRIB ID FOR BOOT DEVICE
2028   EEB6 CF          	RST	08			; GET THE VALUE
2029   EEB7 ED 53 8E F0 	LD	(BOOTVOL),DE		; D -> DEVICE/UNIT, E -> LU
2030   EEBB             ;
2031   EEBB             	; SETUP THE DRVMAP STRUCTURE
2032   EEBB 2A 8C F0    	LD	HL,(BUFTOP)		; GET CURRENT BUFFER TOP
2033   EEBE 23          	INC	HL			; SKIP 1 BYTE FOR ENTRY COUNT PREFIX
2034   EEBF 22 3B E6    	LD	(DRVMAPADR),HL		; SAVE AS DRVMAP ADDRESS
2035   EEC2 22 8C F0    	LD	(BUFTOP),HL		; AND AS NEW BUFTOP
2036   EEC5             ;
2037   EEC5             	; SETUP TO LOOP THROUGH AVAILABLE DEVICES
2038   EEC5 06 1A       	LD	B,BF_DIODEVCNT		; HBIOS FUNC: DEVICE COUNT
2039   EEC7 CF          	RST	08			; CALL HBIOS, DEVICE COUNT TO B
2040   EEC8 78          	LD	A,B			; COUNT TO A
2041   EEC9 B7          	OR	A			; SET FLAGS
2042   EECA C8          	RET	Z			; HANDLE ZERO DEVICES (ALBEIT POORLY)
2043   EECB 0E 00       	LD	C,0			; USE C AS DEVICE LIST INDEX
2044   EECD             ;
2045   EECD             DRV_INIT1:	; DEVICE ENUMERATION LOOP
2046   EECD C5          	PUSH	BC			; PRESERVE LOOP CONTROL
2047   EECE 06 1B       	LD	B,BF_DIODEVINF		; HBIOS FUNC: DEVICE INFO
2048   EED0 CF          	RST	08			; CALL HBIOS, DEVICE/UNIT TO C
2049   EED1 CD D9 EE    	CALL	DRV_INIT3		; MAKE DRIVE MAP ENTRY(S)
2050   EED4 C1          	POP	BC			; RESTORE LOOP CONTROL
2051   EED5 0C          	INC	C			; INCREMENT LIST INDEX
2052   EED6 10 F5       	DJNZ	DRV_INIT1		; LOOP AS NEEDED
2053   EED8 C9          	RET				; FINISHED
2054   EED9             ;
2055   EED9             DRV_INIT3:	; PROCESS DEVICE/UNIT
2056   EED9 79          	LD	A,C			; DEVICE/UNIT TO A
2057   EEDA F5          	PUSH	AF			; SAVE DEVICE/UNIT
2058   EEDB CD EA EE    	CALL	DRV_INIT4		; MAKE A DRIVE MAP ENTRY
2059   EEDE F1          	POP	AF			; RESTORE DEVICE/UNIT
2060   EEDF FE 30       	CP	DIODEV_IDE		; FIRST SLICE CAPABLE DEVICE?
2061   EEE1 D8          	RET	C			; DONE IF NOT SLICE WORTHY
2062   EEE2 CD EA EE    	CALL	DRV_INIT4		; MAKE ANOTHER ENTRY IF HARD DISK
2063   EEE5 3E 01       	LD	A,1			; ... BUT WITH SLICE = 1
2064   EEE7 23          	INC	HL			; BUMP TO SLICE POSITION
2065   EEE8 77          	LD	(HL),A			; SAVE IT
2066   EEE9 C9          	RET				; DONE
2067   EEEA             ;
2068   EEEA             DRV_INIT4:	; MAKE A DRIVE MAP ENTRY
2069   EEEA             	; ALLOCATE SPACE FOR ENTRY
2070   EEEA F5          	PUSH	AF			; SAVE INCOMING DEVICE/UNIT
2071   EEEB 01 04 00    	LD	BC,4			; 4 BYTES PER ENTRY
2072   EEEE CD DE EF    	CALL	ALLOC			; ALLOCATE SPACE
2073   EEF1 C4 66 EA    	CALL	NZ,PANIC		; SHOULD NEVER ERROR HERE
2074   EEF4 C5          	PUSH	BC			; MOVE MEM PTR
2075   EEF5 E1          	POP	HL			; ... TO HL
2076   EEF6 F1          	POP	AF			; RECOVER DEVICE/UNIT
2077   EEF7 77          	LD	(HL),A			; SAVE IT IN FIRST BYTE OF DRVMAP
2078   EEF8 E5          	PUSH	HL			; SAVE ENTRY PTR
2079   EEF9 2A 3B E6    	LD	HL,(DRVMAPADR)		; POINT TO DRIVE MAP
2080   EEFC 2B          	DEC	HL			; BACKUP TO ENTRY COUNT
2081   EEFD 34          	INC	(HL)			; INCREMENT THE ENTRY COUNT
2082   EEFE E1          	POP	HL			; RECOVER ENTRY POINTER
2083   EEFF C9          	RET				; DONE
2084   EF00             ;
2085   EF00             #ENDIF
2086   EF00             ;
2087   EF00             ;
2088   EF00             ;__________________________________________________________________________________________________
2089   EF00             ;
2090   EF00             DPH_INIT:
2091   EF00             ;
2092   EF00             ; ITERATE THROUGH DRIVE MAP TO BUILD DPH ENTRIES DYNAMICALLY
2093   EF00             ;
2094   EF00 11 AE F0    	LD	DE,STR_DPHINIT	; POINT TO MSG
2095   EF03 CD 56 EA    	CALL	WRITESTR	; DISPLAY IT
2096   EF06 CD 1C EA    	CALL	NEWLINE		; FORMATTING
2097   EF09             ;
2098   EF09             	; ALLOCATE DPH POOL SPACE BASED ON DRIVE COUNT
2099   EF09 2A 3B E6    	LD	HL,(DRVMAPADR)	; LOAD DRIVE MAP POINTER
2100   EF0C 2B          	DEC	HL		; BACKUP TO ENTRY COUNT
2101   EF0D 7E          	LD	A,(HL)		; GET THE ENTRY COUNT
2102   EF0E 6F          	LD	L,A		; PUT DRIVE COUNT
2103   EF0F 26 00       	LD	H,0		; ... INTO HL
2104   EF11 29          	ADD	HL,HL		; MULTIPLY
2105   EF12 29          	ADD	HL,HL		; ... BY SIZE
2106   EF13 29          	ADD	HL,HL		; ... OF DPH (16)
2107   EF14 29          	ADD	HL,HL		; ... FOR TOTAL SIZE
2108   EF15 E5          	PUSH	HL		; MOVE POOL SIZE
2109   EF16 C1          	POP	BC		; ... INTO BC FOR MEM ALLOC
2110   EF17 CD DE EF    	CALL	ALLOC		; ALLOCATE THE SPACE
2111   EF1A C4 66 EA    	CALL	NZ,PANIC	; SHOULD NEVER ERROR
2112   EF1D             ;
2113   EF1D             	; SET DPHTOP TO START OF ALLOCATED SPACE
2114   EF1D C5          	PUSH	BC		; MOVE MEM POINTER
2115   EF1E E1          	POP	HL		; ... TO HL
2116   EF1F 22 88 F0    	LD	(DPHTOP),HL	; ... AND SAVE IN DPHTOP
2117   EF22             ;
2118   EF22             	; ALLOCATE DIRECTORY BUFFER
2119   EF22 01 80 00    	LD	BC,128		; SIZE OF DIRECTORY BUFFER
2120   EF25 CD DE EF    	CALL	ALLOC		; ALLOCATE THE SPACE
2121   EF28 C4 66 EA    	CALL	NZ,PANIC	; SHOULD NEVER ERROR
2122   EF2B C5          	PUSH	BC		; MOVE MEM POINTER
2123   EF2C E1          	POP	HL		; ... TO HL
2124   EF2D 22 8A F0    	LD	(DIRBUF),HL	; ... AND SAVE IN DIRBUF
2125   EF30             ;
2126   EF30             	; SETUP FOR DPH BUILD LOOP
2127   EF30 2A 3B E6    	LD	HL,(DRVMAPADR)	; POINT TO DRIVE MAP
2128   EF33 2B          	DEC	HL		; BACKUP TO ENTRY COUNT
2129   EF34 46          	LD	B,(HL)		; LOOP DRVCNT TIMES
2130   EF35 0E 00       	LD	C,0		; DRIVE INDEX
2131   EF37 23          	INC	HL		; BUMP TO START OF DRIVE MAP
2132   EF38             ;
2133   EF38             DPH_INIT1:
2134   EF38             	; DISPLAY DRIVE LETTER
2135   EF38 79          	LD	A,C		; LOAD DRIVE INDEX
2136   EF39 C6 41       	ADD	A,'A'		; MAKE IT A DISPLAY LETTER
2137   EF3B 11 A8 F0    	LD	DE,STR_LDR	; LEADER STRING
2138   EF3E CD 56 EA    	CALL	WRITESTR	; DISPLAY IT
2139   EF41 CD B6 EA    	CALL	COUT		; DISPLAY DRIVE LETTER
2140   EF44 CD E0 E9    	CALL	PC_COLON	; DISPLAY COLON
2141   EF47 3E 3D       	LD	A,'='		; SEPARATOR
2142   EF49 CD B6 EA    	CALL	COUT		; DISPLAY IT
2143   EF4C             	; SETUP FOR DPH BUILD ROUTINE INCLUDING DPH BLOCK ALLOCATION
2144   EF4C 56          	LD	D,(HL)		; D := DEV/UNIT
2145   EF4D 23          	INC	HL		; BUMP
2146   EF4E 5E          	LD	E,(HL)		; E := SLICE
2147   EF4F 23          	INC	HL		; BUMP
2148   EF50 CD 0E F0    	CALL	PRTDUS		; PRINT DEVICE/UNIT/SLICE
2149   EF53 7A          	LD	A,D		; A := DEV/UNIT
2150   EF54 E5          	PUSH	HL		; SAVE DRIVE MAP POINTER
2151   EF55 F5          	PUSH	AF		; SAVE DEV/UNIT
2152   EF56             	; MATCH AND SAVE DEFAULT DRIVE BASED ON BOOT DEVICE/UNIT/SLICE
2153   EF56 21 8F F0    	LD	HL,BOOTVOL + 1	; POINT TO BOOT DEVICE/UNIT
2154   EF59 7A          	LD	A,D		; LOAD CURRENT DEVICE/UNIT
2155   EF5A BE          	CP	(HL)		; MATCH?
2156   EF5B 20 09       	JR	NZ,DPH_INIT1A	; BYPASS IF NOT BOOT DEVICE/UNIT
2157   EF5D 2B          	DEC	HL		; POINT TO BOOT SLICE
2158   EF5E 7B          	LD	A,E		; LOAD CURRENT SLICE
2159   EF5F BE          	CP	(HL)		; MATCH?
2160   EF60 20 04       	JR	NZ,DPH_INIT1A	; BYPASS IF NOT BOOT SLICE
2161   EF62 79          	LD	A,C		; LOAD THE CURRENT DRIVE NUM
2162   EF63 32 9A EB    	LD	(DEFDRIVE),A	; SAVE AS DEFAULT
2163   EF66             DPH_INIT1A:	
2164   EF66 F1          	POP	AF		; RESTORE DEV/UNIT
2165   EF67 ED 5B 88 F0 	LD	DE,(DPHTOP)	; GET ADDRESS OF NEXT DPH
2166   EF6B D5          	PUSH	DE		; ... AND SAVE IT
2167   EF6C             	; INVOKE THE DPH BUILD ROUTINE
2168   EF6C C5          	PUSH	BC		; SAVE LOOP CONTROL
2169   EF6D CD 8A EF    	CALL	MAKDPH		; MAKE THE DPH AT DE, DEV/UNIT IN A
2170   EF70             	;CALL	NZ,PANIC	; FOR NOW, PANIC ON ANY ERROR
2171   EF70 C1          	POP	BC		; RESTORE LOOP CONTROL
2172   EF71             	; STORE THE DPH POINTER IN DRIVE MAP
2173   EF71 D1          	POP	DE		; RESTORE DPH ADDRESS TO DE
2174   EF72 E1          	POP	HL		; RESTORE DRIVE MAP POINTER TO HL
2175   EF73 28 03       	JR	Z,DPH_INIT2	; IF MAKDPH OK, CONTINUE
2176   EF75 11 00 00    	LD	DE,0		; ... OTHERWISE ZERO OUT THE DPH POINTER
2177   EF78             DPH_INIT2:
2178   EF78 73          	LD	(HL),E		; SAVE DPH POINTER
2179   EF79 23          	INC	HL		; ... IN
2180   EF7A 72          	LD	(HL),D		; ... DRIVE MAP
2181   EF7B 23          	INC	HL		; AND BUMP TO START OF NEXT ENTRY
2182   EF7C             	; UPDATE DPH ALLOCATION TOP
2183   EF7C 3E 10       	LD	A,16		; SIZE OF A DPH ENTRY
2184   EF7E EB          	EX	DE,HL		; HL := DPH POINTER
2185   EF7F CD 0B EB    	CALL	ADDHLA		; CALC NEW DPHTOP
2186   EF82 22 88 F0    	LD	(DPHTOP),HL	; SAVE IT
2187   EF85             	; HANDLE THE NEXT DRIVE MAP ENTRY
2188   EF85 EB          	EX	DE,HL		; HL := NEXT DRIVE MAP ENTRY
2189   EF86 0C          	INC	C		; NEXT DRIVE
2190   EF87 10 AF       	DJNZ	DPH_INIT1	; LOOP AS NEEDED
2191   EF89 C9          	RET			; DONE
2192   EF8A             ;
2193   EF8A             MAKDPH:
2194   EF8A             ;
2195   EF8A             ; MAKE A DPH AT ADDRESS IN DE FOR DEV/UNIT IN A
2196   EF8A             ;
2197   EF8A D5          	PUSH	DE		; SAVE INCOMING DPH ADDRESS
2198   EF8B             ;
2199   EF8B~            #IF (PLATFORM == PLT_UNA)
2200   EF8B~            ;
2201   EF8B~            	LD	B,A		; UNIT NUM TO B
2202   EF8B~            	LD	C,$48		; UNA FUNC: GET DISK TYPE
2203   EF8B~            	CALL	$FFFD		; CALL UNA
2204   EF8B~            	LD	A,D		; MOVE DISK TYPE TO A
2205   EF8B~            ;
2206   EF8B~            	; DERIVE DPB ADDRESS BASED ON DISK TYPE
2207   EF8B~            	CP	$40		; RAM/ROM DRIVE?
2208   EF8B~            	JR	Z,MAKDPH0	; HANDLE RAM/ROM DRIVE IF SO
2209   EF8B~            ;	CP	$??		; FLOPPY DRIVE?
2210   EF8B~            ;	JR	Z,XXXXX		; HANDLE FLOPPY
2211   EF8B~            	LD	DE,DPB_HD	; ASSUME HARD DISK
2212   EF8B~            	JR	MAKDPH1		; CONTINUE
2213   EF8B~            ;
2214   EF8B~            MAKDPH0:	; HANDLE RAM/ROM
2215   EF8B~            	LD	C,$45		; UNA FUNC: GET DISK INFO
2216   EF8B~            	LD	DE,$9000	; 512 BYTE BUFFER *** FIX!!! ***
2217   EF8B~            	CALL	$FFFD		; CALL UNA
2218   EF8B~            	BIT	7,B		; TEST RAM DRIVE BIT
2219   EF8B~            	LD	DE,DPB_ROM	; ASSUME ROM
2220   EF8B~            	JR	Z,MAKDPH1	; NOT SET, ROM DRIVE, CONTINUE
2221   EF8B~            	LD	DE,DPB_RAM	; OTHERWISE, MUST BE RAM DRIVE
2222   EF8B~            	JR	MAKDPH1		; CONTINUE
2223   EF8B~            ;
2224   EF8B             #ELSE
2225   EF8B             ;
2226   EF8B             	; DETERMINE APPROPRIATE DPB
2227   EF8B 11 D2 EB    	LD	DE,DPB_ROM	; ASSUME ROM
2228   EF8E FE 00       	CP	DIODEV_MD+0	; ROM?
2229   EF90 28 1C       	JR	Z,MAKDPH1	; YES, JUMP AHEAD
2230   EF92 11 E6 EB    	LD	DE,DPB_RAM	; ASSUME ROM
2231   EF95 FE 01       	CP	DIODEV_MD+1	; ROM?
2232   EF97 28 15       	JR	Z,MAKDPH1	; YES, JUMP AHEAD
2233   EF99 E6 F0       	AND	$F0		; IGNORE UNIT NIBBLE NOW
2234   EF9B 11 36 EC    	LD	DE,DPB_FD144	; ASSUME FLOPPY
2235   EF9E FE 10       	CP	DIODEV_FD	; FLOPPY?
2236   EFA0 28 0C       	JR	Z,MAKDPH1	; YES, JUMP AHEAD
2237   EFA2 11 FA EB    	LD	DE,DPB_RF	; ASSUME RAM FLOPPY
2238   EFA5 FE 20       	CP	DIODEV_RF	; RAM FLOPPY?
2239   EFA7 28 05       	JR	Z,MAKDPH1	; YES, JUMP AHEAD
2240   EFA9 11 0E EC    	LD	DE,DPB_HD	; EVERYTHING ELSE IS ASSUMED TO BE HARD DISK
2241   EFAC 18 00       	JR	MAKDPH1		; JUMP AHEAD
2242   EFAE             ;
2243   EFAE             #ENDIF
2244   EFAE             ;
2245   EFAE             MAKDPH1:
2246   EFAE             ;
2247   EFAE             	; BUILD THE DPH
2248   EFAE E1          	POP	HL		; HL := START OF DPH
2249   EFAF 3E 08       	LD	A,8		; SIZE OF DPH RESERVED AREA
2250   EFB1 CD 0B EB    	CALL	ADDHLA		; LEAVE IT ALONE (ZERO FILLED)
2251   EFB4             	
2252   EFB4 ED 4B 8A F0 	LD	BC,(DIRBUF)	; ADDRESS OF DIRBUF
2253   EFB8 71          	LD	(HL),C		; PLUG DIRBUF
2254   EFB9 23          	INC	HL		; ... INTO DPH
2255   EFBA 70          	LD	(HL),B		; ... AND BUMP
2256   EFBB 23          	INC	HL		; ... TO NEXT DPH ENTRY
2257   EFBC             
2258   EFBC 73          	LD	(HL),E		; PLUG DPB ADDRESS
2259   EFBD 23          	INC	HL		; ... INTO DPH
2260   EFBE 72          	LD	(HL),D		; ... AND BUMP
2261   EFBF 23          	INC	HL		; ... TO NEXT ENTRY
2262   EFC0 1B          	DEC	DE		; POINT
2263   EFC1 1B          	DEC	DE		; ... TO START
2264   EFC2 1B          	DEC	DE		; ... OF
2265   EFC3 1B          	DEC	DE		; ... DPB
2266   EFC4 1B          	DEC	DE		; ... PREFIX DATA (CKS & ALS BUF SIZES)
2267   EFC5 CD C9 EF    	CALL	MAKDPH2		; HANDLE CKS BUF, THEN FALL THRU FOR ALS BUF
2268   EFC8 C0          	RET	NZ		; BAIL OUT ON ERROR
2269   EFC9             MAKDPH2:
2270   EFC9 EB          	EX	DE,HL		; POINT HL TO CKS/ALS SIZE ADR
2271   EFCA 4E          	LD	C,(HL)		; BC := CKS/ALS SIZE
2272   EFCB 23          	INC	HL		; ... AND BUMP
2273   EFCC 46          	LD	B,(HL)		; ... PAST
2274   EFCD 23          	INC	HL		; ... CKS/ALS SIZE
2275   EFCE EB          	EX	DE,HL		; BC AND HL ROLES RESTORED
2276   EFCF 78          	LD	A,B		; CHECK TO SEE
2277   EFD0 B1          	OR	C		; ... IF BC IS ZERO
2278   EFD1 28 05       	JR	Z,MAKDPH3	; IF ZERO, BYPASS ALLOC, USE ZERO FOR ADDRESS
2279   EFD3 CD DE EF    	CALL	ALLOC		; ALLOC BC BYTES, ADDRESS RETURNED IN BC
2280   EFD6 20 26       	JR	NZ,ERR_BUFOVF	; HANDLE OVERFLOW ERROR
2281   EFD8             MAKDPH3:
2282   EFD8 71          	LD	(HL),C		; SAVE CKS/ALS BUF
2283   EFD9 23          	INC	HL		; ... ADDRESS IN
2284   EFDA 70          	LD	(HL),B		; ... DPH AND BUMP
2285   EFDB 23          	INC	HL		; ... TO NEXT DPH ENTRY	
2286   EFDC AF          	XOR	A		; SIGNAL SUCCESS
2287   EFDD C9          	RET
2288   EFDE             ;
2289   EFDE             ALLOC:
2290   EFDE             ;
2291   EFDE             ; ALLOCATE BC BYTES FROM BUF POOL, RETURN STARTING
2292   EFDE             ; ADDRESS IN BC.  LEAVE ALL OTHER REGS ALONE EXCEPT A
2293   EFDE             ; Z FOR SUCCESS, NZ FOR FAILURE
2294   EFDE             ;
2295   EFDE D5          	PUSH	DE		; SAVE ORIGINAL DE
2296   EFDF E5          	PUSH	HL		; SAVE ORIGINAL HL
2297   EFE0 2A 8C F0    	LD	HL,(BUFTOP)	; HL := CURRENT BUFFER TOP
2298   EFE3 E5          	PUSH	HL		; SAVE AS START OF NEW BUFFER
2299   EFE4 C5          	PUSH	BC		; GET BYTE COUNT
2300   EFE5 D1          	POP	DE		; ... INTO DE
2301   EFE6 19          	ADD	HL,DE		; ADD IT TO BUFFER TOP
2302   EFE7 3E FF       	LD	A,$FF		; ASSUME OVERFLOW FAILURE
2303   EFE9 38 0E       	JR	C,ALLOC1	; IF OVERFLOW, BYPASS WITH A == $FF
2304   EFEB E5          	PUSH	HL		; SAVE IT
2305   EFEC 11 00 02    	LD	DE,$10000 - CBIOS_END	; SETUP DE FOR OVERFLOW TEST
2306   EFEF 19          	ADD	HL,DE		; CHECK FOR OVERFLOW
2307   EFF0 E1          	POP	HL		; RECOVER HL
2308   EFF1 3E FF       	LD	A,$FF		; ASSUME FAILURE
2309   EFF3 38 04       	JR	C,ALLOC1	; IF OVERFLOW, CONTINUE WITH A == $FF
2310   EFF5 22 8C F0    	LD	(BUFTOP),HL	; SAVE NEW TOP
2311   EFF8 3C          	INC	A		; SIGNAL SUCCESS
2312   EFF9             ;
2313   EFF9             ALLOC1:
2314   EFF9 C1          	POP	BC		; BUF START ADDRESS TO BC
2315   EFFA E1          	POP	HL		; RESTORE ORIGINAL HL
2316   EFFB D1          	POP	DE		; RESTORE ORIGINAL DE
2317   EFFC B7          	OR	A		; SIGNAL SUCCESS
2318   EFFD C9          	RET
2319   EFFE             ;
2320   EFFE             ERR_BUFOVF:
2321   EFFE 11 C8 F0    	LD	DE,STR_BUFOVF
2322   F001 18 05       	JR	ERR
2323   F003             ;
2324   F003             ERR_INVMED:
2325   F003 11 E5 F0    	LD	DE,STR_INVMED
2326   F006 18 00       	JR	ERR
2327   F008             ;
2328   F008             ERR:
2329   F008 CD 56 EA    	CALL	WRITESTR
2330   F00B F6 FF       	OR	$FF
2331   F00D C9          	RET
2332   F00E             ;
2333   F00E             PRTDUS:
2334   F00E             ;
2335   F00E             ; PRINT THE DEVICE/UNIT/SLICE INFO
2336   F00E             ; ON INPUT D HAS DEVICE/UNIT, E HAS SLICE
2337   F00E             ; DESTROY NO REGISTERS OTHER THAN A
2338   F00E             ;
2339   F00E~            #IF (PLATFORM == PLT_UNA)
2340   F00E~            ;
2341   F00E~            	PUSH	BC		; PRESERVE BC
2342   F00E~            	PUSH	DE		; PRESERVE DE
2343   F00E~            	PUSH	HL		; PRESERVE HL
2344   F00E~            	
2345   F00E~            	LD	B,D		; B := UNIT
2346   F00E~            	LD	C,$48		; UNA FUNC: GET DISK TYPE
2347   F00E~            	CALL	$FFFD		; CALL UNA
2348   F00E~            	LD	A,D		; DISK TYPE TO A
2349   F00E~            	
2350   F00E~            	CP	$40
2351   F00E~            	JR	Z,PRTDUS1	; IF SO, HANDLE RAM/ROM
2352   F00E~            	
2353   F00E~            	LD	DE,DEVIDE	; IDE STRING
2354   F00E~            	CP	$41		; IDE?
2355   F00E~            	JR	Z,PRTDUSX	; IF YES, PRINT
2356   F00E~            	LD	DE,DEVPPIDE	; PPIDE STRING
2357   F00E~            	CP	$42		; PPIDE?
2358   F00E~            	JR	Z,PRTDUSX	; IF YES, PRINT
2359   F00E~            	LD	DE,DEVSD	; SD STRING
2360   F00E~            	CP	$43		; SD?
2361   F00E~            	JR	Z,PRTDUSX	; IF YES, PRINT
2362   F00E~            	LD	DE,DEVDSD	; DSD STRING
2363   F00E~            	CP	$44		; DSD?
2364   F00E~            	JR	Z,PRTDUSX	; IF YES, PRINT
2365   F00E~            
2366   F00E~            	LD	DE,DEVUNK	; OTHERWISE, UNKNOWN
2367   F00E~            	JR	PRTDUSX		; PRINT IT
2368   F00E~            
2369   F00E~            PRTDUS1:
2370   F00E~            	LD	C,$45		; UNA FUNC: GET DISK INFO
2371   F00E~            	LD	DE,$9000	; 512 BYTE BUFFER *** FIX!!! ***
2372   F00E~            	CALL	$FFFD		; CALL UNA
2373   F00E~            	BIT	7,B		; TEST RAM DRIVE BIT
2374   F00E~            	LD	DE,DEVROM	; ASSUME ROM
2375   F00E~            	JR	Z,PRTDUSX	; IF SO, DISPLAY ROM
2376   F00E~            	LD	DE,DEVRAM	; ELSE RAM
2377   F00E~            	JR	Z,PRTDUSX	; DO IT
2378   F00E~            
2379   F00E~            PRTDUSX:
2380   F00E~            	CALL	WRITESTR	; PRINT DEVICE NAME
2381   F00E~            	POP	HL		; RECOVER HL
2382   F00E~            	POP	DE		; RECOVER DE
2383   F00E~            	POP	BC		; RECOVER BC
2384   F00E~            	LD	A,D		; LOAD DEVICE/UNIT
2385   F00E~            	CALL	PRTDECB		; PRINT IT
2386   F00E~            	CALL	PC_COLON	; FORMATTING
2387   F00E~            	LD	A,E		; LOAD SLICE
2388   F00E~            	CALL	PRTDECB		; PRINT IT
2389   F00E~            	RET
2390   F00E~            ;
2391   F00E~            DEVRAM		.DB	"RAM$"
2392   F00E~            DEVROM		.DB	"ROM$"
2393   F00E~            DEVIDE		.DB	"IDE$"
2394   F00E~            DEVPPIDE	.DB	"PPIDE$"
2395   F00E~            DEVSD		.DB	"SD$"
2396   F00E~            DEVDSD		.DB	"DSD$"
2397   F00E~            DEVUNK		.DB	"UNK$"
2398   F00E~            ;
2399   F00E             #ELSE
2400   F00E             ;
2401   F00E D5          	PUSH	DE		; PRESERVE DE
2402   F00F E5          	PUSH	HL		; PRESERVE HL
2403   F010 7A          	LD	A,D		; LOAD DEVICE/UNIT
2404   F011 0F          	RRCA			; ROTATE DEVICE
2405   F012 0F          	RRCA			; ... BITS
2406   F013 0F          	RRCA			; ... INTO
2407   F014 0F          	RRCA			; ... LOWEST 4 BITS
2408   F015 E6 0F       	AND	$0F		; ISOLATE DEVICE BITS
2409   F017 87          	ADD	A,A		; MULTIPLE BY TWO FOR WORD TABLE
2410   F018 21 35 F0    	LD	HL,DEVTBL	; POINT TO START OF DEVICE NAME TABLE
2411   F01B CD 0B EB    	CALL	ADDHLA		; ADD A TO HL TO POINT TO TABLE ENTRY
2412   F01E 7E          	LD	A,(HL)		; DEREFERENCE HL TO LOC OF DEVICE NAME STRING
2413   F01F 23          	INC	HL		; ...
2414   F020 56          	LD	D,(HL)		; ...
2415   F021 5F          	LD	E,A		; ...
2416   F022 CD 56 EA    	CALL	WRITESTR	; PRINT THE DEVICE NMEMONIC
2417   F025 E1          	POP	HL		; RECOVER HL
2418   F026 D1          	POP	DE		; RECOVER DE
2419   F027 7A          	LD	A,D		; LOAD DEVICE/UNIT
2420   F028 E6 0F       	AND	$0F		; ISOLATE UNIT
2421   F02A CD 4D EB    	CALL	PRTDECB		; PRINT IT
2422   F02D CD E0 E9    	CALL	PC_COLON	; FORMATTING
2423   F030 7B          	LD	A,E		; LOAD SLICE
2424   F031 CD 4D EB    	CALL	PRTDECB		; PRINT IT
2425   F034 C9          	RET
2426   F035             ;
2427   F035             DEVTBL:	; DEVICE TABLE
2428   F035 59 F0 5C F0 	.DW	DEV00, DEV01, DEV02, DEV03
2428   F039 5F F0 64 F0 
2429   F03D 68 F0 6E F0 	.DW	DEV04, DEV05, DEV06, DEV07
2429   F041 74 F0 77 F0 
2430   F045 7D F0 83 F0 	.DW	DEV08, DEV09, DEV10, DEV11
2430   F049 55 F0 55 F0 
2431   F04D 55 F0 55 F0 	.DW	DEV12, DEV13, DEV14, DEV15
2431   F051 55 F0 55 F0 
2432   F055             ;
2433   F055 3F 3F 3F 24 DEVUNK	.DB	"???$"
2434   F059 4D 44 24    DEV00	.DB	"MD$"
2435   F05C 46 44 24    DEV01	.DB	"FD$"
2436   F05F 52 41 4D 46 DEV02	.DB	"RAMF$"
2436   F063 24 
2437   F064 49 44 45 24 DEV03	.DB	"IDE$"
2438   F068 41 54 41 50 DEV04	.DB	"ATAPI$"
2438   F06C 49 24 
2439   F06E 50 50 49 44 DEV05	.DB	"PPIDE$"
2439   F072 45 24 
2440   F074 53 44 24    DEV06	.DB	"SD$"
2441   F077 50 52 50 53 DEV07	.DB	"PRPSD$"
2441   F07B 44 24 
2442   F07D 50 50 50 53 DEV08	.DB	"PPPSD$"
2442   F081 44 24 
2443   F083 48 44 53 4B DEV09	.DB	"HDSK$"
2443   F087 24 
2444   F088             DEV10	.EQU	DEVUNK
2445   F088             DEV11	.EQU	DEVUNK
2446   F088             DEV12	.EQU	DEVUNK
2447   F088             DEV13	.EQU	DEVUNK
2448   F088             DEV14	.EQU	DEVUNK
2449   F088             DEV15	.EQU	DEVUNK
2450   F088             ;
2451   F088             #ENDIF
2452   F088             ;
2453   F088 00 00       DPHTOP		.DW	0		; CURRENT TOP OF DPH POOL
2454   F08A 00 00       DIRBUF		.DW	0		; DIR BUF POINTER
2455   F08C 81 EC       BUFTOP		.DW	BUFPOOL		; CURRENT TOP OF BUF POOL
2456   F08E 00 00       BOOTVOL		.DW			; BOOT VOLUME, MSB=BOOT DEVICE/UNIT, LSB=BOOT LU
2457   F090             ;
2458   F090 0D 0A 46 6F STR_INITRAMDISK	.DB	"\r\nFormatting RAMDISK...$"
2458   F094 72 6D 61 74 
2458   F098 74 69 6E 67 
2458   F09C 20 52 41 4D 
2458   F0A0 44 49 53 4B 
2458   F0A4 2E 2E 2E 24 
2459   F0A8 0D 0A 20 20 STR_LDR		.DB	"\r\n   $"
2459   F0AC 20 24 
2460   F0AE 0D 0A 0D 0A STR_DPHINIT	.DB	"\r\n\r\nConfiguring Drives...$"
2460   F0B2 43 6F 6E 66 
2460   F0B6 69 67 75 72 
2460   F0BA 69 6E 67 20 
2460   F0BE 44 72 69 76 
2460   F0C2 65 73 2E 2E 
2460   F0C6 2E 24 
2461   F0C8 20 2A 2A 2A STR_BUFOVF	.DB	" *** Insufficient Memory ***$"
2461   F0CC 20 49 6E 73 
2461   F0D0 75 66 66 69 
2461   F0D4 63 69 65 6E 
2461   F0D8 74 20 4D 65 
2461   F0DC 6D 6F 72 79 
2461   F0E0 20 2A 2A 2A 
2461   F0E4 24 
2462   F0E5 20 2A 2A 2A STR_INVMED	.DB	" *** Invalid Device ID ***$"
2462   F0E9 20 49 6E 76 
2462   F0ED 61 6C 69 64 
2462   F0F1 20 44 65 76 
2462   F0F5 69 63 65 20 
2462   F0F9 49 44 20 2A 
2462   F0FD 2A 2A 24 
2463   F100             ;
2464   F100             ;==================================================================================================
2465   F100             ;
2466   F100             ;==================================================================================================
2467   F100             ;
2468   F100 00 00 00 00 	.FILL	CBIOS_END - $,$00
2468   F104 00 00 00 00 
2468   F108 00 00 00 00 
2468   F10C 00 00 00 00 
2468   F110 00 00 00 00 
2468   F114 00 00 00 00 
2468   F118 00 00 00 00 
2468   F11C 00 00 00 00 
2468   F120 00 00 00 00 
2468   F124 00 00 00 00 
2468   F128 00 00 00 00 
2468   F12C 00 00 00 00 
2468   F130 00 00 00 00 
2468   F134 00 00 00 00 
2468   F138 00 00 00 00 
2468   F13C 00 00 00 00 
2468   F140 00 00 00 00 
2468   F144 00 00 00 00 
2468   F148 00 00 00 00 
2468   F14C 00 00 00 00 
2468   F150 00 00 00 00 
2468   F154 00 00 00 00 
2468   F158 00 00 00 00 
2468   F15C 00 00 00 00 
2468   F160 00 00 00 00 
2468   F164 00 00 00 00 
2468   F168 00 00 00 00 
2468   F16C 00 00 00 00 
2468   F170 00 00 00 00 
2468   F174 00 00 00 00 
2468   F178 00 00 00 00 
2468   F17C 00 00 00 00 
2468   F180 00 00 00 00 
2468   F184 00 00 00 00 
2468   F188 00 00 00 00 
2468   F18C 00 00 00 00 
2468   F190 00 00 00 00 
2468   F194 00 00 00 00 
2468   F198 00 00 00 00 
2468   F19C 00 00 00 00 
2468   F1A0 00 00 00 00 
2468   F1A4 00 00 00 00 
2468   F1A8 00 00 00 00 
2468   F1AC 00 00 00 00 
2468   F1B0 00 00 00 00 
2468   F1B4 00 00 00 00 
2468   F1B8 00 00 00 00 
2468   F1BC 00 00 00 00 
2468   F1C0 00 00 00 00 
2468   F1C4 00 00 00 00 
2468   F1C8 00 00 00 00 
2468   F1CC 00 00 00 00 
2468   F1D0 00 00 00 00 
2468   F1D4 00 00 00 00 
2468   F1D8 00 00 00 00 
2468   F1DC 00 00 00 00 
2468   F1E0 00 00 00 00 
2468   F1E4 00 00 00 00 
2468   F1E8 00 00 00 00 
2468   F1EC 00 00 00 00 
2468   F1F0 00 00 00 00 
2468   F1F4 00 00 00 00 
2468   F1F8 00 00 00 00 
2468   F1FC 00 00 00 00 
2468   F200 00 00 00 00 
2468   F204 00 00 00 00 
2468   F208 00 00 00 00 
2468   F20C 00 00 00 00 
2468   F210 00 00 00 00 
2468   F214 00 00 00 00 
2468   F218 00 00 00 00 
2468   F21C 00 00 00 00 
2468   F220 00 00 00 00 
2468   F224 00 00 00 00 
2468   F228 00 00 00 00 
2468   F22C 00 00 00 00 
2468   F230 00 00 00 00 
2468   F234 00 00 00 00 
2468   F238 00 00 00 00 
2468   F23C 00 00 00 00 
2468   F240 00 00 00 00 
2468   F244 00 00 00 00 
2468   F248 00 00 00 00 
2468   F24C 00 00 00 00 
2468   F250 00 00 00 00 
2468   F254 00 00 00 00 
2468   F258 00 00 00 00 
2468   F25C 00 00 00 00 
2468   F260 00 00 00 00 
2468   F264 00 00 00 00 
2468   F268 00 00 00 00 
2468   F26C 00 00 00 00 
2468   F270 00 00 00 00 
2468   F274 00 00 00 00 
2468   F278 00 00 00 00 
2468   F27C 00 00 00 00 
2468   F280 00 00 00 00 
2468   F284 00 00 00 00 
2468   F288 00 00 00 00 
2468   F28C 00 00 00 00 
2468   F290 00 00 00 00 
2468   F294 00 00 00 00 
2468   F298 00 00 00 00 
2468   F29C 00 00 00 00 
2468   F2A0 00 00 00 00 
2468   F2A4 00 00 00 00 
2468   F2A8 00 00 00 00 
2468   F2AC 00 00 00 00 
2468   F2B0 00 00 00 00 
2468   F2B4 00 00 00 00 
2468   F2B8 00 00 00 00 
2468   F2BC 00 00 00 00 
2468   F2C0 00 00 00 00 
2468   F2C4 00 00 00 00 
2468   F2C8 00 00 00 00 
2468   F2CC 00 00 00 00 
2468   F2D0 00 00 00 00 
2468   F2D4 00 00 00 00 
2468   F2D8 00 00 00 00 
2468   F2DC 00 00 00 00 
2468   F2E0 00 00 00 00 
2468   F2E4 00 00 00 00 
2468   F2E8 00 00 00 00 
2468   F2EC 00 00 00 00 
2468   F2F0 00 00 00 00 
2468   F2F4 00 00 00 00 
2468   F2F8 00 00 00 00 
2468   F2FC 00 00 00 00 
2468   F300 00 00 00 00 
2468   F304 00 00 00 00 
2468   F308 00 00 00 00 
2468   F30C 00 00 00 00 
2468   F310 00 00 00 00 
2468   F314 00 00 00 00 
2468   F318 00 00 00 00 
2468   F31C 00 00 00 00 
2468   F320 00 00 00 00 
2468   F324 00 00 00 00 
2468   F328 00 00 00 00 
2468   F32C 00 00 00 00 
2468   F330 00 00 00 00 
2468   F334 00 00 00 00 
2468   F338 00 00 00 00 
2468   F33C 00 00 00 00 
2468   F340 00 00 00 00 
2468   F344 00 00 00 00 
2468   F348 00 00 00 00 
2468   F34C 00 00 00 00 
2468   F350 00 00 00 00 
2468   F354 00 00 00 00 
2468   F358 00 00 00 00 
2468   F35C 00 00 00 00 
2468   F360 00 00 00 00 
2468   F364 00 00 00 00 
2468   F368 00 00 00 00 
2468   F36C 00 00 00 00 
2468   F370 00 00 00 00 
2468   F374 00 00 00 00 
2468   F378 00 00 00 00 
2468   F37C 00 00 00 00 
2468   F380 00 00 00 00 
2468   F384 00 00 00 00 
2468   F388 00 00 00 00 
2468   F38C 00 00 00 00 
2468   F390 00 00 00 00 
2468   F394 00 00 00 00 
2468   F398 00 00 00 00 
2468   F39C 00 00 00 00 
2468   F3A0 00 00 00 00 
2468   F3A4 00 00 00 00 
2468   F3A8 00 00 00 00 
2468   F3AC 00 00 00 00 
2468   F3B0 00 00 00 00 
2468   F3B4 00 00 00 00 
2468   F3B8 00 00 00 00 
2468   F3BC 00 00 00 00 
2468   F3C0 00 00 00 00 
2468   F3C4 00 00 00 00 
2468   F3C8 00 00 00 00 
2468   F3CC 00 00 00 00 
2468   F3D0 00 00 00 00 
2468   F3D4 00 00 00 00 
2468   F3D8 00 00 00 00 
2468   F3DC 00 00 00 00 
2468   F3E0 00 00 00 00 
2468   F3E4 00 00 00 00 
2468   F3E8 00 00 00 00 
2468   F3EC 00 00 00 00 
2468   F3F0 00 00 00 00 
2468   F3F4 00 00 00 00 
2468   F3F8 00 00 00 00 
2468   F3FC 00 00 00 00 
2468   F400 00 00 00 00 
2468   F404 00 00 00 00 
2468   F408 00 00 00 00 
2468   F40C 00 00 00 00 
2468   F410 00 00 00 00 
2468   F414 00 00 00 00 
2468   F418 00 00 00 00 
2468   F41C 00 00 00 00 
2468   F420 00 00 00 00 
2468   F424 00 00 00 00 
2468   F428 00 00 00 00 
2468   F42C 00 00 00 00 
2468   F430 00 00 00 00 
2468   F434 00 00 00 00 
2468   F438 00 00 00 00 
2468   F43C 00 00 00 00 
2468   F440 00 00 00 00 
2468   F444 00 00 00 00 
2468   F448 00 00 00 00 
2468   F44C 00 00 00 00 
2468   F450 00 00 00 00 
2468   F454 00 00 00 00 
2468   F458 00 00 00 00 
2468   F45C 00 00 00 00 
2468   F460 00 00 00 00 
2468   F464 00 00 00 00 
2468   F468 00 00 00 00 
2468   F46C 00 00 00 00 
2468   F470 00 00 00 00 
2468   F474 00 00 00 00 
2468   F478 00 00 00 00 
2468   F47C 00 00 00 00 
2468   F480 00 00 00 00 
2468   F484 00 00 00 00 
2468   F488 00 00 00 00 
2468   F48C 00 00 00 00 
2468   F490 00 00 00 00 
2468   F494 00 00 00 00 
2468   F498 00 00 00 00 
2468   F49C 00 00 00 00 
2468   F4A0 00 00 00 00 
2468   F4A4 00 00 00 00 
2468   F4A8 00 00 00 00 
2468   F4AC 00 00 00 00 
2468   F4B0 00 00 00 00 
2468   F4B4 00 00 00 00 
2468   F4B8 00 00 00 00 
2468   F4BC 00 00 00 00 
2468   F4C0 00 00 00 00 
2468   F4C4 00 00 00 00 
2468   F4C8 00 00 00 00 
2468   F4CC 00 00 00 00 
2468   F4D0 00 00 00 00 
2468   F4D4 00 00 00 00 
2468   F4D8 00 00 00 00 
2468   F4DC 00 00 00 00 
2468   F4E0 00 00 00 00 
2468   F4E4 00 00 00 00 
2468   F4E8 00 00 00 00 
2468   F4EC 00 00 00 00 
2468   F4F0 00 00 00 00 
2468   F4F4 00 00 00 00 
2468   F4F8 00 00 00 00 
2468   F4FC 00 00 00 00 
2468   F500 00 00 00 00 
2468   F504 00 00 00 00 
2468   F508 00 00 00 00 
2468   F50C 00 00 00 00 
2468   F510 00 00 00 00 
2468   F514 00 00 00 00 
2468   F518 00 00 00 00 
2468   F51C 00 00 00 00 
2468   F520 00 00 00 00 
2468   F524 00 00 00 00 
2468   F528 00 00 00 00 
2468   F52C 00 00 00 00 
2468   F530 00 00 00 00 
2468   F534 00 00 00 00 
2468   F538 00 00 00 00 
2468   F53C 00 00 00 00 
2468   F540 00 00 00 00 
2468   F544 00 00 00 00 
2468   F548 00 00 00 00 
2468   F54C 00 00 00 00 
2468   F550 00 00 00 00 
2468   F554 00 00 00 00 
2468   F558 00 00 00 00 
2468   F55C 00 00 00 00 
2468   F560 00 00 00 00 
2468   F564 00 00 00 00 
2468   F568 00 00 00 00 
2468   F56C 00 00 00 00 
2468   F570 00 00 00 00 
2468   F574 00 00 00 00 
2468   F578 00 00 00 00 
2468   F57C 00 00 00 00 
2468   F580 00 00 00 00 
2468   F584 00 00 00 00 
2468   F588 00 00 00 00 
2468   F58C 00 00 00 00 
2468   F590 00 00 00 00 
2468   F594 00 00 00 00 
2468   F598 00 00 00 00 
2468   F59C 00 00 00 00 
2468   F5A0 00 00 00 00 
2468   F5A4 00 00 00 00 
2468   F5A8 00 00 00 00 
2468   F5AC 00 00 00 00 
2468   F5B0 00 00 00 00 
2468   F5B4 00 00 00 00 
2468   F5B8 00 00 00 00 
2468   F5BC 00 00 00 00 
2468   F5C0 00 00 00 00 
2468   F5C4 00 00 00 00 
2468   F5C8 00 00 00 00 
2468   F5CC 00 00 00 00 
2468   F5D0 00 00 00 00 
2468   F5D4 00 00 00 00 
2468   F5D8 00 00 00 00 
2468   F5DC 00 00 00 00 
2468   F5E0 00 00 00 00 
2468   F5E4 00 00 00 00 
2468   F5E8 00 00 00 00 
2468   F5EC 00 00 00 00 
2468   F5F0 00 00 00 00 
2468   F5F4 00 00 00 00 
2468   F5F8 00 00 00 00 
2468   F5FC 00 00 00 00 
2468   F600 00 00 00 00 
2468   F604 00 00 00 00 
2468   F608 00 00 00 00 
2468   F60C 00 00 00 00 
2468   F610 00 00 00 00 
2468   F614 00 00 00 00 
2468   F618 00 00 00 00 
2468   F61C 00 00 00 00 
2468   F620 00 00 00 00 
2468   F624 00 00 00 00 
2468   F628 00 00 00 00 
2468   F62C 00 00 00 00 
2468   F630 00 00 00 00 
2468   F634 00 00 00 00 
2468   F638 00 00 00 00 
2468   F63C 00 00 00 00 
2468   F640 00 00 00 00 
2468   F644 00 00 00 00 
2468   F648 00 00 00 00 
2468   F64C 00 00 00 00 
2468   F650 00 00 00 00 
2468   F654 00 00 00 00 
2468   F658 00 00 00 00 
2468   F65C 00 00 00 00 
2468   F660 00 00 00 00 
2468   F664 00 00 00 00 
2468   F668 00 00 00 00 
2468   F66C 00 00 00 00 
2468   F670 00 00 00 00 
2468   F674 00 00 00 00 
2468   F678 00 00 00 00 
2468   F67C 00 00 00 00 
2468   F680 00 00 00 00 
2468   F684 00 00 00 00 
2468   F688 00 00 00 00 
2468   F68C 00 00 00 00 
2468   F690 00 00 00 00 
2468   F694 00 00 00 00 
2468   F698 00 00 00 00 
2468   F69C 00 00 00 00 
2468   F6A0 00 00 00 00 
2468   F6A4 00 00 00 00 
2468   F6A8 00 00 00 00 
2468   F6AC 00 00 00 00 
2468   F6B0 00 00 00 00 
2468   F6B4 00 00 00 00 
2468   F6B8 00 00 00 00 
2468   F6BC 00 00 00 00 
2468   F6C0 00 00 00 00 
2468   F6C4 00 00 00 00 
2468   F6C8 00 00 00 00 
2468   F6CC 00 00 00 00 
2468   F6D0 00 00 00 00 
2468   F6D4 00 00 00 00 
2468   F6D8 00 00 00 00 
2468   F6DC 00 00 00 00 
2468   F6E0 00 00 00 00 
2468   F6E4 00 00 00 00 
2468   F6E8 00 00 00 00 
2468   F6EC 00 00 00 00 
2468   F6F0 00 00 00 00 
2468   F6F4 00 00 00 00 
2468   F6F8 00 00 00 00 
2468   F6FC 00 00 00 00 
2468   F700 00 00 00 00 
2468   F704 00 00 00 00 
2468   F708 00 00 00 00 
2468   F70C 00 00 00 00 
2468   F710 00 00 00 00 
2468   F714 00 00 00 00 
2468   F718 00 00 00 00 
2468   F71C 00 00 00 00 
2468   F720 00 00 00 00 
2468   F724 00 00 00 00 
2468   F728 00 00 00 00 
2468   F72C 00 00 00 00 
2468   F730 00 00 00 00 
2468   F734 00 00 00 00 
2468   F738 00 00 00 00 
2468   F73C 00 00 00 00 
2468   F740 00 00 00 00 
2468   F744 00 00 00 00 
2468   F748 00 00 00 00 
2468   F74C 00 00 00 00 
2468   F750 00 00 00 00 
2468   F754 00 00 00 00 
2468   F758 00 00 00 00 
2468   F75C 00 00 00 00 
2468   F760 00 00 00 00 
2468   F764 00 00 00 00 
2468   F768 00 00 00 00 
2468   F76C 00 00 00 00 
2468   F770 00 00 00 00 
2468   F774 00 00 00 00 
2468   F778 00 00 00 00 
2468   F77C 00 00 00 00 
2468   F780 00 00 00 00 
2468   F784 00 00 00 00 
2468   F788 00 00 00 00 
2468   F78C 00 00 00 00 
2468   F790 00 00 00 00 
2468   F794 00 00 00 00 
2468   F798 00 00 00 00 
2468   F79C 00 00 00 00 
2468   F7A0 00 00 00 00 
2468   F7A4 00 00 00 00 
2468   F7A8 00 00 00 00 
2468   F7AC 00 00 00 00 
2468   F7B0 00 00 00 00 
2468   F7B4 00 00 00 00 
2468   F7B8 00 00 00 00 
2468   F7BC 00 00 00 00 
2468   F7C0 00 00 00 00 
2468   F7C4 00 00 00 00 
2468   F7C8 00 00 00 00 
2468   F7CC 00 00 00 00 
2468   F7D0 00 00 00 00 
2468   F7D4 00 00 00 00 
2468   F7D8 00 00 00 00 
2468   F7DC 00 00 00 00 
2468   F7E0 00 00 00 00 
2468   F7E4 00 00 00 00 
2468   F7E8 00 00 00 00 
2468   F7EC 00 00 00 00 
2468   F7F0 00 00 00 00 
2468   F7F4 00 00 00 00 
2468   F7F8 00 00 00 00 
2468   F7FC 00 00 00 00 
2468   F800 00 00 00 00 
2468   F804 00 00 00 00 
2468   F808 00 00 00 00 
2468   F80C 00 00 00 00 
2468   F810 00 00 00 00 
2468   F814 00 00 00 00 
2468   F818 00 00 00 00 
2468   F81C 00 00 00 00 
2468   F820 00 00 00 00 
2468   F824 00 00 00 00 
2468   F828 00 00 00 00 
2468   F82C 00 00 00 00 
2468   F830 00 00 00 00 
2468   F834 00 00 00 00 
2468   F838 00 00 00 00 
2468   F83C 00 00 00 00 
2468   F840 00 00 00 00 
2468   F844 00 00 00 00 
2468   F848 00 00 00 00 
2468   F84C 00 00 00 00 
2468   F850 00 00 00 00 
2468   F854 00 00 00 00 
2468   F858 00 00 00 00 
2468   F85C 00 00 00 00 
2468   F860 00 00 00 00 
2468   F864 00 00 00 00 
2468   F868 00 00 00 00 
2468   F86C 00 00 00 00 
2468   F870 00 00 00 00 
2468   F874 00 00 00 00 
2468   F878 00 00 00 00 
2468   F87C 00 00 00 00 
2468   F880 00 00 00 00 
2468   F884 00 00 00 00 
2468   F888 00 00 00 00 
2468   F88C 00 00 00 00 
2468   F890 00 00 00 00 
2468   F894 00 00 00 00 
2468   F898 00 00 00 00 
2468   F89C 00 00 00 00 
2468   F8A0 00 00 00 00 
2468   F8A4 00 00 00 00 
2468   F8A8 00 00 00 00 
2468   F8AC 00 00 00 00 
2468   F8B0 00 00 00 00 
2468   F8B4 00 00 00 00 
2468   F8B8 00 00 00 00 
2468   F8BC 00 00 00 00 
2468   F8C0 00 00 00 00 
2468   F8C4 00 00 00 00 
2468   F8C8 00 00 00 00 
2468   F8CC 00 00 00 00 
2468   F8D0 00 00 00 00 
2468   F8D4 00 00 00 00 
2468   F8D8 00 00 00 00 
2468   F8DC 00 00 00 00 
2468   F8E0 00 00 00 00 
2468   F8E4 00 00 00 00 
2468   F8E8 00 00 00 00 
2468   F8EC 00 00 00 00 
2468   F8F0 00 00 00 00 
2468   F8F4 00 00 00 00 
2468   F8F8 00 00 00 00 
2468   F8FC 00 00 00 00 
2468   F900 00 00 00 00 
2468   F904 00 00 00 00 
2468   F908 00 00 00 00 
2468   F90C 00 00 00 00 
2468   F910 00 00 00 00 
2468   F914 00 00 00 00 
2468   F918 00 00 00 00 
2468   F91C 00 00 00 00 
2468   F920 00 00 00 00 
2468   F924 00 00 00 00 
2468   F928 00 00 00 00 
2468   F92C 00 00 00 00 
2468   F930 00 00 00 00 
2468   F934 00 00 00 00 
2468   F938 00 00 00 00 
2468   F93C 00 00 00 00 
2468   F940 00 00 00 00 
2468   F944 00 00 00 00 
2468   F948 00 00 00 00 
2468   F94C 00 00 00 00 
2468   F950 00 00 00 00 
2468   F954 00 00 00 00 
2468   F958 00 00 00 00 
2468   F95C 00 00 00 00 
2468   F960 00 00 00 00 
2468   F964 00 00 00 00 
2468   F968 00 00 00 00 
2468   F96C 00 00 00 00 
2468   F970 00 00 00 00 
2468   F974 00 00 00 00 
2468   F978 00 00 00 00 
2468   F97C 00 00 00 00 
2468   F980 00 00 00 00 
2468   F984 00 00 00 00 
2468   F988 00 00 00 00 
2468   F98C 00 00 00 00 
2468   F990 00 00 00 00 
2468   F994 00 00 00 00 
2468   F998 00 00 00 00 
2468   F99C 00 00 00 00 
2468   F9A0 00 00 00 00 
2468   F9A4 00 00 00 00 
2468   F9A8 00 00 00 00 
2468   F9AC 00 00 00 00 
2468   F9B0 00 00 00 00 
2468   F9B4 00 00 00 00 
2468   F9B8 00 00 00 00 
2468   F9BC 00 00 00 00 
2468   F9C0 00 00 00 00 
2468   F9C4 00 00 00 00 
2468   F9C8 00 00 00 00 
2468   F9CC 00 00 00 00 
2468   F9D0 00 00 00 00 
2468   F9D4 00 00 00 00 
2468   F9D8 00 00 00 00 
2468   F9DC 00 00 00 00 
2468   F9E0 00 00 00 00 
2468   F9E4 00 00 00 00 
2468   F9E8 00 00 00 00 
2468   F9EC 00 00 00 00 
2468   F9F0 00 00 00 00 
2468   F9F4 00 00 00 00 
2468   F9F8 00 00 00 00 
2468   F9FC 00 00 00 00 
2468   FA00 00 00 00 00 
2468   FA04 00 00 00 00 
2468   FA08 00 00 00 00 
2468   FA0C 00 00 00 00 
2468   FA10 00 00 00 00 
2468   FA14 00 00 00 00 
2468   FA18 00 00 00 00 
2468   FA1C 00 00 00 00 
2468   FA20 00 00 00 00 
2468   FA24 00 00 00 00 
2468   FA28 00 00 00 00 
2468   FA2C 00 00 00 00 
2468   FA30 00 00 00 00 
2468   FA34 00 00 00 00 
2468   FA38 00 00 00 00 
2468   FA3C 00 00 00 00 
2468   FA40 00 00 00 00 
2468   FA44 00 00 00 00 
2468   FA48 00 00 00 00 
2468   FA4C 00 00 00 00 
2468   FA50 00 00 00 00 
2468   FA54 00 00 00 00 
2468   FA58 00 00 00 00 
2468   FA5C 00 00 00 00 
2468   FA60 00 00 00 00 
2468   FA64 00 00 00 00 
2468   FA68 00 00 00 00 
2468   FA6C 00 00 00 00 
2468   FA70 00 00 00 00 
2468   FA74 00 00 00 00 
2468   FA78 00 00 00 00 
2468   FA7C 00 00 00 00 
2468   FA80 00 00 00 00 
2468   FA84 00 00 00 00 
2468   FA88 00 00 00 00 
2468   FA8C 00 00 00 00 
2468   FA90 00 00 00 00 
2468   FA94 00 00 00 00 
2468   FA98 00 00 00 00 
2468   FA9C 00 00 00 00 
2468   FAA0 00 00 00 00 
2468   FAA4 00 00 00 00 
2468   FAA8 00 00 00 00 
2468   FAAC 00 00 00 00 
2468   FAB0 00 00 00 00 
2468   FAB4 00 00 00 00 
2468   FAB8 00 00 00 00 
2468   FABC 00 00 00 00 
2468   FAC0 00 00 00 00 
2468   FAC4 00 00 00 00 
2468   FAC8 00 00 00 00 
2468   FACC 00 00 00 00 
2468   FAD0 00 00 00 00 
2468   FAD4 00 00 00 00 
2468   FAD8 00 00 00 00 
2468   FADC 00 00 00 00 
2468   FAE0 00 00 00 00 
2468   FAE4 00 00 00 00 
2468   FAE8 00 00 00 00 
2468   FAEC 00 00 00 00 
2468   FAF0 00 00 00 00 
2468   FAF4 00 00 00 00 
2468   FAF8 00 00 00 00 
2468   FAFC 00 00 00 00 
2468   FB00 00 00 00 00 
2468   FB04 00 00 00 00 
2468   FB08 00 00 00 00 
2468   FB0C 00 00 00 00 
2468   FB10 00 00 00 00 
2468   FB14 00 00 00 00 
2468   FB18 00 00 00 00 
2468   FB1C 00 00 00 00 
2468   FB20 00 00 00 00 
2468   FB24 00 00 00 00 
2468   FB28 00 00 00 00 
2468   FB2C 00 00 00 00 
2468   FB30 00 00 00 00 
2468   FB34 00 00 00 00 
2468   FB38 00 00 00 00 
2468   FB3C 00 00 00 00 
2468   FB40 00 00 00 00 
2468   FB44 00 00 00 00 
2468   FB48 00 00 00 00 
2468   FB4C 00 00 00 00 
2468   FB50 00 00 00 00 
2468   FB54 00 00 00 00 
2468   FB58 00 00 00 00 
2468   FB5C 00 00 00 00 
2468   FB60 00 00 00 00 
2468   FB64 00 00 00 00 
2468   FB68 00 00 00 00 
2468   FB6C 00 00 00 00 
2468   FB70 00 00 00 00 
2468   FB74 00 00 00 00 
2468   FB78 00 00 00 00 
2468   FB7C 00 00 00 00 
2468   FB80 00 00 00 00 
2468   FB84 00 00 00 00 
2468   FB88 00 00 00 00 
2468   FB8C 00 00 00 00 
2468   FB90 00 00 00 00 
2468   FB94 00 00 00 00 
2468   FB98 00 00 00 00 
2468   FB9C 00 00 00 00 
2468   FBA0 00 00 00 00 
2468   FBA4 00 00 00 00 
2468   FBA8 00 00 00 00 
2468   FBAC 00 00 00 00 
2468   FBB0 00 00 00 00 
2468   FBB4 00 00 00 00 
2468   FBB8 00 00 00 00 
2468   FBBC 00 00 00 00 
2468   FBC0 00 00 00 00 
2468   FBC4 00 00 00 00 
2468   FBC8 00 00 00 00 
2468   FBCC 00 00 00 00 
2468   FBD0 00 00 00 00 
2468   FBD4 00 00 00 00 
2468   FBD8 00 00 00 00 
2468   FBDC 00 00 00 00 
2468   FBE0 00 00 00 00 
2468   FBE4 00 00 00 00 
2468   FBE8 00 00 00 00 
2468   FBEC 00 00 00 00 
2468   FBF0 00 00 00 00 
2468   FBF4 00 00 00 00 
2468   FBF8 00 00 00 00 
2468   FBFC 00 00 00 00 
2468   FC00 00 00 00 00 
2468   FC04 00 00 00 00 
2468   FC08 00 00 00 00 
2468   FC0C 00 00 00 00 
2468   FC10 00 00 00 00 
2468   FC14 00 00 00 00 
2468   FC18 00 00 00 00 
2468   FC1C 00 00 00 00 
2468   FC20 00 00 00 00 
2468   FC24 00 00 00 00 
2468   FC28 00 00 00 00 
2468   FC2C 00 00 00 00 
2468   FC30 00 00 00 00 
2468   FC34 00 00 00 00 
2468   FC38 00 00 00 00 
2468   FC3C 00 00 00 00 
2468   FC40 00 00 00 00 
2468   FC44 00 00 00 00 
2468   FC48 00 00 00 00 
2468   FC4C 00 00 00 00 
2468   FC50 00 00 00 00 
2468   FC54 00 00 00 00 
2468   FC58 00 00 00 00 
2468   FC5C 00 00 00 00 
2468   FC60 00 00 00 00 
2468   FC64 00 00 00 00 
2468   FC68 00 00 00 00 
2468   FC6C 00 00 00 00 
2468   FC70 00 00 00 00 
2468   FC74 00 00 00 00 
2468   FC78 00 00 00 00 
2468   FC7C 00 00 00 00 
2468   FC80 00 00 00 00 
2468   FC84 00 00 00 00 
2468   FC88 00 00 00 00 
2468   FC8C 00 00 00 00 
2468   FC90 00 00 00 00 
2468   FC94 00 00 00 00 
2468   FC98 00 00 00 00 
2468   FC9C 00 00 00 00 
2468   FCA0 00 00 00 00 
2468   FCA4 00 00 00 00 
2468   FCA8 00 00 00 00 
2468   FCAC 00 00 00 00 
2468   FCB0 00 00 00 00 
2468   FCB4 00 00 00 00 
2468   FCB8 00 00 00 00 
2468   FCBC 00 00 00 00 
2468   FCC0 00 00 00 00 
2468   FCC4 00 00 00 00 
2468   FCC8 00 00 00 00 
2468   FCCC 00 00 00 00 
2468   FCD0 00 00 00 00 
2468   FCD4 00 00 00 00 
2468   FCD8 00 00 00 00 
2468   FCDC 00 00 00 00 
2468   FCE0 00 00 00 00 
2468   FCE4 00 00 00 00 
2468   FCE8 00 00 00 00 
2468   FCEC 00 00 00 00 
2468   FCF0 00 00 00 00 
2468   FCF4 00 00 00 00 
2468   FCF8 00 00 00 00 
2468   FCFC 00 00 00 00 
2468   FD00 00 00 00 00 
2468   FD04 00 00 00 00 
2468   FD08 00 00 00 00 
2468   FD0C 00 00 00 00 
2468   FD10 00 00 00 00 
2468   FD14 00 00 00 00 
2468   FD18 00 00 00 00 
2468   FD1C 00 00 00 00 
2468   FD20 00 00 00 00 
2468   FD24 00 00 00 00 
2468   FD28 00 00 00 00 
2468   FD2C 00 00 00 00 
2468   FD30 00 00 00 00 
2468   FD34 00 00 00 00 
2468   FD38 00 00 00 00 
2468   FD3C 00 00 00 00 
2468   FD40 00 00 00 00 
2468   FD44 00 00 00 00 
2468   FD48 00 00 00 00 
2468   FD4C 00 00 00 00 
2468   FD50 00 00 00 00 
2468   FD54 00 00 00 00 
2468   FD58 00 00 00 00 
2468   FD5C 00 00 00 00 
2468   FD60 00 00 00 00 
2468   FD64 00 00 00 00 
2468   FD68 00 00 00 00 
2468   FD6C 00 00 00 00 
2468   FD70 00 00 00 00 
2468   FD74 00 00 00 00 
2468   FD78 00 00 00 00 
2468   FD7C 00 00 00 00 
2468   FD80 00 00 00 00 
2468   FD84 00 00 00 00 
2468   FD88 00 00 00 00 
2468   FD8C 00 00 00 00 
2468   FD90 00 00 00 00 
2468   FD94 00 00 00 00 
2468   FD98 00 00 00 00 
2468   FD9C 00 00 00 00 
2468   FDA0 00 00 00 00 
2468   FDA4 00 00 00 00 
2468   FDA8 00 00 00 00 
2468   FDAC 00 00 00 00 
2468   FDB0 00 00 00 00 
2468   FDB4 00 00 00 00 
2468   FDB8 00 00 00 00 
2468   FDBC 00 00 00 00 
2468   FDC0 00 00 00 00 
2468   FDC4 00 00 00 00 
2468   FDC8 00 00 00 00 
2468   FDCC 00 00 00 00 
2468   FDD0 00 00 00 00 
2468   FDD4 00 00 00 00 
2468   FDD8 00 00 00 00 
2468   FDDC 00 00 00 00 
2468   FDE0 00 00 00 00 
2468   FDE4 00 00 00 00 
2468   FDE8 00 00 00 00 
2468   FDEC 00 00 00 00 
2468   FDF0 00 00 00 00 
2468   FDF4 00 00 00 00 
2468   FDF8 00 00 00 00 
2468   FDFC 00 00 00 00 
2469   FE00             ;
2470   FE00             SLACK	.EQU	(CBIOS_END - BUFPOOL)
2471   FE00             	.ECHO	"CBIOS buffer space: "
2472   FE00             	.ECHO	SLACK
2473   FE00             	.ECHO	" bytes.\n"
2474   FE00             ;
2475   FE00             	.ECHO	"CBIOS total space used: "
2476   FE00             	.ECHO	$ - CBIOS_LOC
2477   FE00             	.ECHO	" bytes.\n"
2478   FE00             ;
2479   FE00             	; PAD OUT AREA RESERVED FOR HBIOS PROXY
2480   FE00 FF FF FF FF 	.FILL	$10000 - $
2480   FE04 FF FF FF FF 
2480   FE08 FF FF FF FF 
2480   FE0C FF FF FF FF 
2480   FE10 FF FF FF FF 
2480   FE14 FF FF FF FF 
2480   FE18 FF FF FF FF 
2480   FE1C FF FF FF FF 
2480   FE20 FF FF FF FF 
2480   FE24 FF FF FF FF 
2480   FE28 FF FF FF FF 
2480   FE2C FF FF FF FF 
2480   FE30 FF FF FF FF 
2480   FE34 FF FF FF FF 
2480   FE38 FF FF FF FF 
2480   FE3C FF FF FF FF 
2480   FE40 FF FF FF FF 
2480   FE44 FF FF FF FF 
2480   FE48 FF FF FF FF 
2480   FE4C FF FF FF FF 
2480   FE50 FF FF FF FF 
2480   FE54 FF FF FF FF 
2480   FE58 FF FF FF FF 
2480   FE5C FF FF FF FF 
2480   FE60 FF FF FF FF 
2480   FE64 FF FF FF FF 
2480   FE68 FF FF FF FF 
2480   FE6C FF FF FF FF 
2480   FE70 FF FF FF FF 
2480   FE74 FF FF FF FF 
2480   FE78 FF FF FF FF 
2480   FE7C FF FF FF FF 
2480   FE80 FF FF FF FF 
2480   FE84 FF FF FF FF 
2480   FE88 FF FF FF FF 
2480   FE8C FF FF FF FF 
2480   FE90 FF FF FF FF 
2480   FE94 FF FF FF FF 
2480   FE98 FF FF FF FF 
2480   FE9C FF FF FF FF 
2480   FEA0 FF FF FF FF 
2480   FEA4 FF FF FF FF 
2480   FEA8 FF FF FF FF 
2480   FEAC FF FF FF FF 
2480   FEB0 FF FF FF FF 
2480   FEB4 FF FF FF FF 
2480   FEB8 FF FF FF FF 
2480   FEBC FF FF FF FF 
2480   FEC0 FF FF FF FF 
2480   FEC4 FF FF FF FF 
2480   FEC8 FF FF FF FF 
2480   FECC FF FF FF FF 
2480   FED0 FF FF FF FF 
2480   FED4 FF FF FF FF 
2480   FED8 FF FF FF FF 
2480   FEDC FF FF FF FF 
2480   FEE0 FF FF FF FF 
2480   FEE4 FF FF FF FF 
2480   FEE8 FF FF FF FF 
2480   FEEC FF FF FF FF 
2480   FEF0 FF FF FF FF 
2480   FEF4 FF FF FF FF 
2480   FEF8 FF FF FF FF 
2480   FEFC FF FF FF FF 
2480   FF00 FF FF FF FF 
2480   FF04 FF FF FF FF 
2480   FF08 FF FF FF FF 
2480   FF0C FF FF FF FF 
2480   FF10 FF FF FF FF 
2480   FF14 FF FF FF FF 
2480   FF18 FF FF FF FF 
2480   FF1C FF FF FF FF 
2480   FF20 FF FF FF FF 
2480   FF24 FF FF FF FF 
2480   FF28 FF FF FF FF 
2480   FF2C FF FF FF FF 
2480   FF30 FF FF FF FF 
2480   FF34 FF FF FF FF 
2480   FF38 FF FF FF FF 
2480   FF3C FF FF FF FF 
2480   FF40 FF FF FF FF 
2480   FF44 FF FF FF FF 
2480   FF48 FF FF FF FF 
2480   FF4C FF FF FF FF 
2480   FF50 FF FF FF FF 
2480   FF54 FF FF FF FF 
2480   FF58 FF FF FF FF 
2480   FF5C FF FF FF FF 
2480   FF60 FF FF FF FF 
2480   FF64 FF FF FF FF 
2480   FF68 FF FF FF FF 
2480   FF6C FF FF FF FF 
2480   FF70 FF FF FF FF 
2480   FF74 FF FF FF FF 
2480   FF78 FF FF FF FF 
2480   FF7C FF FF FF FF 
2480   FF80 FF FF FF FF 
2480   FF84 FF FF FF FF 
2480   FF88 FF FF FF FF 
2480   FF8C FF FF FF FF 
2480   FF90 FF FF FF FF 
2480   FF94 FF FF FF FF 
2480   FF98 FF FF FF FF 
2480   FF9C FF FF FF FF 
2480   FFA0 FF FF FF FF 
2480   FFA4 FF FF FF FF 
2480   FFA8 FF FF FF FF 
2480   FFAC FF FF FF FF 
2480   FFB0 FF FF FF FF 
2480   FFB4 FF FF FF FF 
2480   FFB8 FF FF FF FF 
2480   FFBC FF FF FF FF 
2480   FFC0 FF FF FF FF 
2480   FFC4 FF FF FF FF 
2480   FFC8 FF FF FF FF 
2480   FFCC FF FF FF FF 
2480   FFD0 FF FF FF FF 
2480   FFD4 FF FF FF FF 
2480   FFD8 FF FF FF FF 
2480   FFDC FF FF FF FF 
2480   FFE0 FF FF FF FF 
2480   FFE4 FF FF FF FF 
2480   FFE8 FF FF FF FF 
2480   FFEC FF FF FF FF 
2480   FFF0 FF FF FF FF 
2480   FFF4 FF FF FF FF 
2480   FFF8 FF FF FF FF 
2480   FFFC FF FF FF FF 
2481   10000             ;
2482   10000             	.END
tasm: Number of errors = 0
