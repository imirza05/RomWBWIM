;
;==================================================================================================
; PROPIO DRIVER
;==================================================================================================
;
;
; GLOBAL PARPORTPROP INITIALIZATION
;
PRP_INIT:
	CALL	PRPSD_INIT		; SD CARD INITIALIZATION
	
	RET
;
;==================================================================================================
; PROPIO CONSOLE DRIVER
;==================================================================================================
;
PRPCON_CMD	.EQU	$40	; PROPIO CONSOLE COMMAND PORT (WHEN WRITTEN)
PRPCON_STATUS	.EQU	$40	; PROPIO CONSOLE STATUS PORT (WHEN READ)
PRPCON_DATA	.EQU	$41	; PROPIO CONSOLE DATA PORT (READ=KBD, WRITE=DISPLAY)
;
PRPCON_BUSY	.EQU	$80	; BIT SET WHEN PROPIO CONSOLE INTERFACE IS BUSY
PRPCON_ERR	.EQU	$40	; BIT SET WHEN PROPIO CONSOLE ERROR HAS OCCURRED
PRPCON_KBDRDY	.EQU	$20	; BIT SET WHEN KEYBOARD BUF HAS A BYTE READY (BUF FULL)
PRPCON_DSPRDY	.EQU	$10	; BIT SET WHEN DISPLAY BUF IS READY FOR A BYTE (BUF EMPTY)
;
;
;
PRPCON_DISPATCH:
	LD	A,B			; GET REQUESTED FUNCTION
	AND	$0F			; ISOLATE SUB-FUNCTION
	JR	Z,PRPCON_IN
	DEC	A
	JR	Z,PRPCON_OUT
	DEC	A
	JR	Z,PRPCON_IST
	DEC	A
	JR	Z,PRPCON_OST
	CALL	PANIC
;
;
;
PRPCON_IN:
	CALL	PRPCON_IST		; CHECK FOR CHAR PENDING
	JR	Z,PRPCON_IN		; WAIT FOR IT IF NECESSARY
	IN	A,(PRPCON_DATA)		; READ THE CHAR FROM PROPIO
	LD	E,A
	RET
;
;
;
PRPCON_IST:
	IN	A,(PRPCON_STATUS)	; READ LINE STATUS REGISTER
	AND	PRPCON_KBDRDY | PRPCON_BUSY	; ISOLATE KBDRDY AND BUSY
	SUB	PRPCON_KBDRDY		; KBD RDY BUT NOT BUSY?
	JR	Z,PRPCON_IST1		; YES, GO TO READY LOGIC
	JP	CIO_IDLE
PRPCON_IST1:
	DEC	A			; SET A=$FF TO SIGNAL READY
	RET				; RETURN
;
;
;
PRPCON_OUT:
	CALL	PRPCON_OST		; CHECK FOR OUTPUT READY
	JR	Z,PRPCON_OUT		; WAIT IF NECESSARY
	LD	A,E			; RECOVER THE CHAR TO WRITE
	OUT	(PRPCON_DATA),A		; WRITE THE CHAR TO PROPIO 
	RET
;
PRPCON_OST:
	IN	A,(PRPCON_STATUS)	; READ LINE STATUS REGISTER
	AND	PRPCON_DSPRDY | PRPCON_BUSY	; ISOLATE DSPRDY AND BUSY
	SUB	PRPCON_DSPRDY		; DSP RDY BUT NOT BUSY?
	JR	Z,PRPCON_OST1		; YES, GO TO READY LOGIC
	JP	CIO_IDLE
PRPCON_OST1:
	DEC	A			; SET A=$FF TO SIGNAL READY
	RET				; RETURN
;
;==================================================================================================
;   PRPSD DISK DRIVER
;==================================================================================================
;
; IO PORT ADDRESSES
;
PRPSD_DSKCMD	.EQU	42H
PRPSD_DSKST	.EQU	42H
PRPSD_DSKIO	.EQU	43H
;
PRPSD_CMDRESET	.EQU	10H
PRPSD_CMDINIT	.EQU	20H
PRPSD_CMDREAD	.EQU	30H
PRPSD_CMDPREP	.EQU	40H
PRPSD_CMDWRITE	.EQU	50H
;
PRPSD_STBUSY	.EQU	80H
PRPSD_STERR	.EQU	40H
PRPSD_STOVR	.EQU	20H
PRPSD_STTO	.EQU	10H
;
;
;
PRPSD_DISPATCH:
	LD	A,B			; GET REQUESTED FUNCTION
	AND	$0F
	JR	Z,PRPSD_RD
	DEC	A
	JR	Z,PRPSD_WR
	DEC	A
	JR	Z,PRPSD_ST
	DEC	A
	JR	Z,PRPSD_MED
	CALL	PANIC
;
PRPSD_RD:
	JP	PRPSD_READ
PRPSD_WR:
	JP	PRPSD_WRITE
PRPSD_ST:
	JP	PRPSD_STATUS
PRPSD_MED:
	JP	PRPSD_MEDIA
;
; PRPSD_MEDIA
;
PRPSD_MEDIA:
	; REINITIALIZE THE CARD HERE
	CALL	PRPSD_INITCARD
	LD	A,MID_NONE		; ASSUME FAILURE
	RET	NZ

	; ALL IS WELL, RETURN MEDIA IDENTIFIER
	LD	A,MID_HD		; SET MEDIA ID
	RET
;
;
;
PRPSD_INIT:
	; MARK DRIVE NOT READY
	; HARDWARE INIT DEFERRED UNTIL DRIVE SELECT
	XOR	A
	DEC	A
	LD	(PRPSD_STAT),A
	RET
;
;
;
PRPSD_STATUS:
	LD	A,(PRPSD_STAT)		; GET THE CURRENT READY STATUS
	OR	A
	RET
;
;
;
PRPSD_READ:
	CALL	PRPSD_CHKCARD		; CHECK / REINIT CARD AS NEEDED
	RET	NZ			; BAIL OUT ON ERROR
	
	LD	A,PRPSD_CMDRESET
	CALL	PRPSD_SNDCMD
	RET	NZ			; RETURN ON FAILURE, A = STATUS
	
	CALL	PRPSD_SETBLK
	
	LD	A,PRPSD_CMDREAD
	CALL	PRPSD_SNDCMD
	RET	NZ			; RETURN ON FAILURE, A = STATUS

	LD	C,PRPSD_DSKIO
	LD	B,0
	LD	HL,(DIOBUF)
	INIR
	INIR

	OR	A			; SET FLAGS
	RET				; RETURN WITH A = STATUS
;
;
;
PRPSD_WRITE:
	CALL	PRPSD_CHKCARD		; CHECK / REINIT CARD AS NEEDED
	RET	NZ			; BAIL OUT ON ERROR
	
	LD	A,PRPSD_CMDRESET
	CALL	PRPSD_SNDCMD
	RET	NZ			; RETURN ON FAILURE, A = STATUS
	
	CALL	PRPSD_SETBLK

	LD	A,PRPSD_CMDPREP
	CALL	PRPSD_SNDCMD
	RET	NZ			; RETURN ON FAILURE, A = STATUS
	
	LD	C,PRPSD_DSKIO
	LD	B,0
	LD	HL,(DIOBUF)
	OTIR
	OTIR

	LD	A,PRPSD_CMDWRITE
	CALL	PRPSD_SNDCMD
	RET	NZ			; RETURN ON FAILURE, A = STATUS

	OR	A			; SET FLAGS
	RET				; RETURN WITH A = STATUS
;
;
;
PRPSD_SNDCMD:
	LD	(PRPSD_CMD),A
	OUT	(PRPSD_DSKCMD),A
	NOP				; SETTLE
	NOP				; SETTLE
	LD	BC,0
PRPSD_SNDCMD1:
	IN	A,(PRPSD_DSKST)
	BIT	7,A
	JR	Z,PRPSD_SNDCMD2		; RET WITH A = STATUS
	LD	E,A			; SAVE STATUS
	CALL	DELAY
	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,PRPSD_SNDCMD1
	LD	A,E			; RECOVER STATUS
	OR	PRPSD_STTO		; SET TIMEOUT BIT
PRPSD_SNDCMD2:
	LD	(PRPSD_STAT),A
	JR	PRPSD_PRT		; RET WITH A = STATUS
;
;
;
PRPSD_INITCARD:
	; RESET INTERFACE, RETURN WITH NZ ON FAILURE
	LD	A,PRPSD_CMDRESET
	CALL	PRPSD_SNDCMD
	RET	NZ			; NZ SET, A HAS ERROR CODE
	
	; REQUEST HARDWARE INIT, RESULT IN A, Z/NZ SET
	LD	A,PRPSD_CMDINIT
	CALL	PRPSD_SNDCMD
	RET				; Z/NZ SET, A HAS RESULT CODE
;
; CHECK THE SD CARD, ATTEMPT TO REINITIALIZE IF NEEDED
;
PRPSD_CHKCARD:
	LD	A,(PRPSD_STAT)		; GET STATUS
	OR	A			; SET FLAGS
	CALL	NZ,PRPSD_INITCARD	; INIT CARD IF NOT READY
	RET				; RETURN WITH STATUS IN A
;
; SEND INDEX OF BLOCK TO READ FROM SD CARD
; 32 BIT VALUE (4 BYTES)
; NOTE THAT BYTES ARE SENT REVERSED, PROPELLER IS LITTLE ENDIAN
;
PRPSD_SETBLK:
	LD	DE,PRPSD_BLK + 3
	LD	A,(HSTSEC)		; A = LSB OF OS SECTOR
	CALL	PRPSD_SETBLK1
	LD	HL,(HSTTRK)		; GET OS TRACK VALUE
	LD	A,L			; EXTRACT LSB
	CALL	PRPSD_SETBLK1
	LD	A,H			; EXTRACT MSB
	CALL	PRPSD_SETBLK1
	XOR	A			; A = 0, NOT USED
	CALL	PRPSD_SETBLK1
	RET
PRPSD_SETBLK1:
	OUT	(PRPSD_DSKIO),A		; SEND IT
	LD	(DE),A
	DEC	DE
	RET
	
PRPSD_PRT:
	BIT	6,A
#IF (PRPSDTRACE == 0)
	RET
#ELSE
#IF (PRPSDTRACE == 1)
	RET	Z
#ENDIF
	PUSH	AF
	CALL	NEWLINE
	CALL	PC_LBKT
	CALL	PRTHEXWORD
	CALL	PC_RBKT
	CALL	PC_SPACE
	LD	DE,PRPSTR_PREFIX
	CALL	WRITESTR
	CALL	PC_SPACE
	LD	DE,PRPSTR_CMD
	CALL	WRITESTR
	LD	A,(PRPSD_CMD)
	CALL	PRTHEXBYTE
	CP	PRPSD_CMDREAD
	CALL	Z,PRPSD_PRTBLK
	CP	PRPSD_CMDWRITE
	CALL	Z,PRPSD_PRTBLK
	CALL	PC_SPACE
	LD	DE,PRPSTR_ARROW
	CALL	WRITESTR
	CALL	PC_SPACE
	POP	AF
	PUSH	AF
	CALL	PRTHEXBYTE
	BIT	6,A
	CALL	NZ,PRPSD_PRTERR
	POP	AF
	RET				; RET WITH A = STATUS

PRPSD_PRTBLK:
	CALL	PC_SPACE
	LD	HL,PRPSD_BLK
	LD	B,4
PRPSD_PRTBLK1:
	LD	A,(HL)
	CALL	PRTHEXBYTE
	INC	HL
	DJNZ	PRPSD_PRTBLK1
	RET
	
PRPSD_PRTERR:
	LD	B,4
PRPSD_PRTERR1:
	IN	A,(PRPSD_DSKIO)
	PUSH	AF
	DJNZ	PRPSD_PRTERR1
	CALL	PC_SPACE
	LD	DE,PRPSTR_ERR
	CALL	WRITESTR
	LD	B,4
PRPSD_PRTERR2:
	POP	AF
	CALL	PRTHEXBYTE
	DJNZ	PRPSD_PRTERR2
	RET
#ENDIF
;
;
;
PRPSTR_PREFIX	.TEXT	"PRPDSK:$"
PRPSTR_CMD	.TEXT	"CMD=$"
;PRPSTR_RC	.TEXT	"RC=$"
PRPSTR_ARROW	.TEXT	"-->$"
PRPSTR_ERR	.TEXT	"ERR=$"
;PRPSTR_RCOK	.TEXT	"OK$"
;PRPSTR_RCRDYTO	.TEXT	"READY TIMEOUT$"
;
;==================================================================================================
;   PRPSD DISK DRIVER - DATA
;==================================================================================================
;
PRPSD_STAT	.DB	0
;
PRPSD_CMD	.DB	0
PRPSD_BLK	.DB	0, 0, 0, 0
