	.title cbios.s    derived from    cbios.asm
	.sbttl by Douglas Goodall for N8VEM use '11

	.module cbios
	.optsdcc -mz80
	
;--------------------------------------------------------
; Public variables in this module
;--------------------------------------------------------
	.globl _cbios
;--------------------------------------------------------
; special function registers
;--------------------------------------------------------
;--------------------------------------------------------
;  ram data
;--------------------------------------------------------
	.area _DATA
;--------------------------------------------------------
; overlayable items in  ram 
;--------------------------------------------------------
	.area _OVERLAY
;--------------------------------------------------------
; external initialized ram data
;--------------------------------------------------------
;--------------------------------------------------------
; global & static initialisations
;--------------------------------------------------------
	.area _HOME
	.area _GSINIT
	.area _GSFINAL
	.area _GSINIT
;--------------------------------------------------------
; Home
;--------------------------------------------------------
	.area _HOME
	.area _HOME
;--------------------------------------------------------
; code
;--------------------------------------------------------

;	.area _CODE
	.area _CBIOS

_cbios_start::
_cbios:

;	CBIOS FOR N8VEM
;
;	Supports: Floppy, IDE HDD, ATAPI ZIP, RAM & ROM DRIVES, on board 16550, DSKY & VDU CARD
;
;	BY ANDREW LYNCH, WITH INPUT FROM MANY SOURCES
;
; DATA CONSTANTS
;__________________________________________________________________________________________________
FALSE		= 	0
TRUE		=  	1

; LIST OF CONDITIONAL ASSEMBLY INSTRUCTIONS

CONDIDESOFT	=	TRUE		; IF NO IDE DRIVE, HAS A SIGNIFICANT DELAY ON SOFT BOOT (TRUE) OR QUICK (FALSE)
CONDSHORTMSG	=	TRUE		; TRUE FOR ORIGINAL WARM BOOT SIGNON, FALSE FOR SHORTER ONE WITH LESS <CR>
CONDSUPERSUB	=	TRUE		; TRUE FOR NO SUPERSUB AUTOEXEC, FALSE TO RUN SUPERSUB AUTOEXEC
CONDABONLY    	=	TRUE   	 	; TRUE FOR ORIGINAL, FALSE TO ONLY HAVE DRIVE A AND B

CONDUSEVDU	=	FALSE	   	; TRUE FOR USE VDU CARD, FALSE TO USE SERIAL PORT (FOR CONSOLE)
CONDUSEFLOPPY	=	TRUE	   	; TRUE FOR USE FLOPPY, FALSE FOR NO FLOPPY DRIVE
COND144FLOPPY	=	TRUE		; TRUE FOR 1.44Mb FLOPPY ON DRIVE G:
CONDUSEATAPI	=	FALSE	   	; TRUE FOR USE ZIP DISK, FALSE FOR NO ZIP DISK
CONDUSEDSKY	=	FALSE	   	; TRUE FOR USE DSKY, FALSE FOR NO DSKY

; POINTERS TO VDU ROUTINES IN HIGH ROM BANK (NOT NEEDED IF NOT USING VDU CARD)

VDU_INIT	=	0x0100		; VECTOR TO VDU INIT CODE
IS_KBHIT	=	0x0395		; VECTOR TO KB HIT CODE
GET_KEY		=	0x039C		; VECTOR TO GET KEY CODE
CHARIN		=	0x011B		; VECTOR TO CHARIN CODE
PR_OUTCHAR	=	0x0CD6		; VECTOR TO PRINTER CODE

;
MSIZE		=	59		;CP/M VERSION MEMORY SIZE IN KILOBYTES
;
;	"BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
;	THAN 16K (REFERRED TO AS "B" THROUGHOUT THE TEXT) 
;
BIAS	 	= 	(MSIZE-20)*1024	;
CCP	 	= 	0x3400+BIAS	; BASE OF CCP
BDOS	 	= 	CCP+0x806	; BASE OF BDOS
BIOS	 	= 	CCP+0x1600	; BASE OF BIOS
CDISK	 	= 	4		; CURRENT DISK NUMBER 0=A,...,15=P
IOBYTE	 	= 	3		; I/O DEFINITION BYTE.

END		= 	0x0FF
CR		=	0x0D
LF		=	0x0A

; TEST PROTOTYPE SPECIFIC HARDWARE IO PORT ADDRESSES AND MEMORY LOCATIONS

UART		= 	0x68	; BASE IO ADDRESS OF UART
MPCL_RAM	= 	0x78	; BASE IO ADDRESS OF RAM MEMORY PAGER CONFIGURATION LATCH
MPCL_ROM	= 	0x7C	; BASE IO ADDRESS OF ROM MEMORY PAGER CONFIGURATION LATCH

ROMSTART_CPM= 	0x00A00	; WHERE THE CCP+BDOS+BIOS IS STORED IN ROM
RAMTARG_CPM=	0x0D000	; WHERE THE CCP+BDOS+BIOS STARTS IN RAM (ENTRY POINT)
MOVSIZ_CPM= 	0x02BFF	; CCP, BDOS
CCPSIZ_CPM= 	0x00800	; CCP 0800h BYTES IN LENGTH

; IDE REGISTER		IO PORT		; FUNCTION
IDELO		= 	0x20		; DATA PORT (LOW BYTE)
IDEERR		= 	0x21		; READ: ERROR REGISTER; WRITE: PRECOMP
IDESECTC	= 	0x22		; SECTOR COUNT
IDESECTN	= 	0x23		; SECTOR NUMBER
IDECYLLO	= 	0x24		; CYLINDER LOW
IDECYLHI	= 	0x25		; CYLINDER HIGH
IDEHEAD	= 	0x26		; DRIVE/HEAD
IDESTTS	= 	0x27		; READ: STATUS; WRITE: COMMAND
IDEHI		= 	0x28		; DATA PORT (HIGH BYTE)
IDECTRL	= 	0x2E		; READ: ALTERNATIVE STATUS; WRITE; DEVICE CONTROL
IDEADDR	= 	0x2F		; DRIVE ADDRESS (READ ONLY)
FMSR		=	0x36		; ADDRESS OF MAIN STATUS REGISTER
FDATA		=	0x37		; FLOPPY DATA REGISTER
FLATCH		=	0x3A		; FLOPPY CONFIGURATION LATCH
FDMA		=	0x3C		; PSEUDO DMA ADDRESS
;
; FDC CONFIGURATION LATCH OUTPUT BIT PATTERNS
MOTOR		=	0b00000000	; BIT PATTERN IN LATCH FOR MOTOR CONTROL (ON)
TERMCN		=	0b00000001	; BIT PATTERN IN LATCH TO WRITE A TC STROBE
RESETL		=	0b00000010	; BIT PATTERN IN LATCH TO RESET ALL BITS
MINI		=	0b00000100	; BIT PATTERN IN LATCH TO SET MINI MODE FDC9229 LOW DENS=1, HIGH DENS=0
PRECOMP	=	0b00100000	; BIT PATTERN IN LATCH TO SET WRITE PRECOMP 125 NS:
FDDENSITY	=	0b01000000	; BIT PATTERN IN LATCH TO FLOPPY LOW DENSITY (HIGH IS 0)
FDREADY	=	0b10000000	; BIT PATTERN IN LATCH TO FLOPPY READY (P-34):
;
; PIO 82C55 I/O IS DECODED TO PORT 60-67
PORTA		= 	0x60		; PORT A
PORTB		= 	0x61		; PORT B
PORTC		= 	0x62		; PORT C
PIOCONT 	= 	0x63		; PIO CONTROL PORT


;dwg;     		.ORG   BIOS

;__________________________________________________________________________________________________
;
;	CP/M JUMP VECTOR TABLE FOR INDIVIDUAL SUBROUTINES
;__________________________________________________________________________________________________
;
	JP	BOOT			; COLD START
WBOOTE:	JP	WBOOT			; WARM START
	JP	CONST			; CONSOLE STATUS
	JP	CONIN			; CONSOLE CHARACTER IN
	JP	CONOUT			; CONSOLE CHARACTER OUT
	JP	LIST			; LIST CHARACTER OUT (NULL ROUTINE)
	JP	PUNCH			; PUNCH CHARACTER OUT (NULL ROUTINE)
	JP	READER			; READER CHARACTER OUT (NULL ROUTINE)
	JP	HOME			; MOVE HEAD TO HOME POSITION
	JP	SELDSK			; SELECT DISK
	JP	SETTRK			; SET TRACK NUMBER
	JP	SETSEC			; SET SECTOR NUMBER
	JP	SETDMA			; SET DMA ADDRESS
	JP	READ			; READ DISK
	JP	WRITE			; WRITE DISK
	JP	LISTST			; RETURN LIST STATUS (NULL ROUTINE)
	JP	SECTRN			; SECTOR TRANSLATE
	
;__________________________________________________________________________________________________	
;
;   FIXED DATA TABLES FOR ALL DRIVES
;   0= FLOPPY DISK OR RAM DISK, 1=RAM DISK, 2=IDE, 3=ATAPI OR RAM DISK, 4=HDPART4
;   5= 1MB ROM DISK,6=32K ROM DISK
;
;   NOTE:  The RAM disk area is used as a substitute if the Floppy and/or ZIP drives are not enabled
;          in the sustem.  This RAM disk is the same "disk" as drive B.
;
;__________________________________________________________________________________________________

;   DISK PARAMETER HEADER FOR DISK 00
DPBASE:
	 	.DW 	0000,0000
	 	.DW 	0000,0000
	 	.DW 	DIRBF,DPBLK1
	 	.DW 	CHK01,ALL01

;   DISK PARAMETER HEADER FOR DISK 01
.IF CONDUSEFLOPPY
   .IF COND144FLOPPY
	 	.DW 	0000,0000
	 	.DW 	0000,0000
	 	.DW 	DIRBF,DPBLK7	; FOR 1.44M FLOPPIES
	 	.DW 	CHK07,ALL07
   .ELSE
	 	.DW 	0000,0000
	 	.DW 	0000,0000
	 	.DW 	DIRBF,DPBLK0
	 	.DW 	CHK00,ALL00
   .ENDIF
.ELSE
	 	.DW 	0000,0000
	 	.DW 	0000,0000
	 	.DW 	DIRBF,DPBLK1
	 	.DW 	CHK01,ALL01 
.ENDIF
;   DISK PARAMETER HEADER FOR DISK 02
	 	.DW 	0000,0000
	 	.DW 	0000,0000
	 	.DW 	DIRBF,DPBLK2
	 	.DW 	CHK02,ALL02
	 
 .IF CONDUSEATAPI	 
;   DISK PARAMETER HEADER FOR DISK 03
	 	.DW 	0000,0000
	 	.DW 	0000,0000
	 	.DW 	DIRBF,DPBLK3
	 	.DW 	CHK03,ALL03
 .ELSE
	 	.DW 	0000,0000
	 	.DW 	0000,0000
	 	.DW 	DIRBF,DPBLK1
	 	.DW 	CHK01,ALL01 	
 .ENDIF
 
;   DISK PARAMETER HEADER FOR DISK 04
	 	.DW 	0000,0000
	 	.DW 	0000,0000
	 	.DW 	DIRBF,DPBLK4
	 	.DW 	CHK04,ALL04
	 	
;   DISK PARAMETER HEADER FOR DISK 05
	 	.DW 	0000,0000
	 	.DW 	0000,0000
	 	.DW 	DIRBF,DPBLK5
	 	.DW 	CHK05,ALL05
	 	
;   DISK PARAMETER HEADER FOR DISK 06
	 	.DW 	0000,0000
	 	.DW 	0000,0000
	 	.DW 	DIRBF,DPBLK6
	 	.DW 	CHK06,ALL06
;

DPBLK0:					; DISK PARAMETER BLOCK (FLOPPY DISK 720KB)
SPT_0:	 	.DW  	36		; 36 SECTORS OF 128 BYTES PER 4.5K TRACK
BSH_0:		.DB  	4		; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
BLM_0:		.DB  	15		; PART OF THE ALLOCATION BLOCK SIZE MATH
EXM_0:		.DB  	0		; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
DSM_0:	 	.DW  	350		; BLOCKSIZE [2048] * NUMBER OF BLOCKS + 1 = DRIVE SIZE
DRM_0:	 	.DW  	127		; NUMBER OF DIRECTORY ENTRIES
AL0_0:		.DB  	0b11000000	; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
AL1_0:		.DB  	0b00000000	; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
CKS_0:	 	.DW  	32		; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
OFF_0:	 	.DW  	4		; FIRST 4 TRACKS TRACKS RESERVED (18K FOR SYSTEM)
					; 
DPBLK1:					; DISK PARAMETER BLOCK (RAMDISK 512K, 448K USABLE)
SPT_1:	 	.DW  	256		; 256 SECTORS OF 128 BYTES PER 32K TRACK
BSH_1:		.DB  	4		; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
BLM_1:		.DB  	15		; PART OF THE ALLOCATION BLOCK SIZE MATH
EXM_1:		.DB  	1		; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
DSM_1:	 	.DW  	225		; BLOCKSIZE [2048] * NUMBER OF BLOCKS + 1 = DRIVE SIZE
DRM_1:	 	.DW  	255		; NUMBER OF DIRECTORY ENTRIES
AL0_1:		.DB  	0b11110000	; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
AL1_1:		.DB  	0b00000000	; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
CKS_1:	 	.DW  	0		; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
OFF_1:	 	.DW  	1		; 1 TRACK RESERVED [FIRST 32K OF RAM]
					;
DPBLK2:					; DISK PARAMETER BLOCK (IDE HARD DISK 8MB)
SPT_2:	 	.DW  	256		; 256 SECTORS OF 128 BYTES PER 32K TRACK
BSH_2:		.DB  	5		; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
BLM_2:		.DB  	31		; PART OF THE ALLOCATION BLOCK SIZE MATH
EXM_2:		.DB  	1		; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
DSM_2:		.DW  	2017		; BLOCKSIZE [4096] * NUMBER OF BLOCKS + 1 = DRIVE SIZE
DRM_2:	 	.DW  	511		; NUMBER OF DIRECTORY ENTRIES
AL0_2:		.DB  	0b11110000	; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
AL1_2:		.DB  	0b00000000	; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
CKS_2:	 	.DW  	0		; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
OFF_2:	 	.DW  	0x03F1		; TRACKS (32K) RESERVED FOR SYSTEM AND OTHER PARTITIONS
					;
DPBLK3:					; DISK PARAMETER BLOCK (ATAPI DRIVE 8MB)
SPT_3:	 	.DW  	256		; 256 SECTORS OF 128 BYTES PER 32K TRACK
BSH_3:		.DB  	5		; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
BLM_3:		.DB  	31		; PART OF THE ALLOCATION BLOCK SIZE MATH
EXM_3:		.DB  	1		; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
DSM_3:	 	.DW  	2017		; BLOCKSIZE [4096] * NUMBER OF BLOCKS + 1 = DRIVE SIZE
DRM_3:	 	.DW  	511		; NUMBER OF DIRECTORY ENTRIES
AL0_3:		.DB  	0b11110000	; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
AL1_3:		.DB  	0b00000000	; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
CKS_3:	 	.DW  	0		; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
OFF_3:	 	.DW  	1		; 1 TRACK (32K) RESERVED FOR SYSTEM
					;
DPBLK4:					; DISK PARAMETER BLOCK (IDE HARD DISK 1024K)
SPT_4:	 	.DW  	256		; 256 SECTORS OF 128 BYTES PER 32K TRACK
BSH_4:		.DB  	4		; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
BLM_4:		.DB 	15		; PART OF THE ALLOCATION BLOCK SIZE MATH
EXM_4:		.DB  	1		; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
DSM_4:	 	.DW  	497		; BLOCKSIZE [2048] * NUMBER OF BLOCKS + 1 = DRIVE SIZE
DRM_4:	 	.DW  	255		; NUMBER OF DIRECTORY ENTRIES
AL0_4:		.DB  	0b11110000	; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
AL1_4:		.DB  	0b00000000	; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
CKS_4:	 	.DW  	0		; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
OFF_4:	 	.DW  	1		; 1 TRACK RESERVED [FIRST 32K OF PARTITION]
					;
DPBLK5:					; DISK PARAMETER BLOCK (ROMDISK 1MB) 
SPT_5:	 	.DW  	256		; 256 SECTORS OF 128 BYTES PER 32K TRACK
BSH_5:		.DB  	4		; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
BLM_5:		.DB  	15		; PART OF THE ALLOCATION BLOCK SIZE MATH
EXM_5:		.DB  	0		; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
DSM_5:	 	.DW  	511		; BLOCKSIZE [2048] * NUMBER OF BLOCKS +1 =DRIVE SIZE
DRM_5:	 	.DW  	255		; NUMBER OF DIRECTORY ENTRIES
AL0_5:		.DB  	0b11110000	; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
AL1_5:		.DB  	0b00000000	; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
CKS_5:	 	.DW  	0		; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
OFF_5:	 	.DW  	1		; 1 TRACK RESERVED [FIRST 32K OF ROM]	
					;
DPBLK6:					; DISK PARAMETER BLOCK (ROMDISK 32KB)
SPT_6:	 	.DW 	16	 	; 16 SECTORS OF 128 BYTES PER 2K TRACK
BSH_6:		.DB 	3 		; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
BLM_6:		.DB 	7 		; PART OF THE ALLOCATION BLOCK SIZE MATH
EXM_6:		.DB 	1 		; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
DSM_6:	 	.DW 	31 		; BLOCKSIZE [1024] * NUMBER OF BLOCKS + 1 = DRIVE SIZE
DRM_6:	 	.DW 	31 		; NUMBER OF DIRECTORY ENTRIES
AL0_6:		.DB 	0b10000000  	; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
AL1_6:		.DB 	0b00000000  	; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
CKS_6:	 	.DW 	0 	  	; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
OFF_6:	 	.DW 	10 	  	; FIRST 10 TRACKS TRACKS RESERVED (20K FOR SYSTEM)
					; SYSTEM IS ROM LOADER, CCP, BDOS, CBIOS, AND MONITOR
DPBLK7:					; DISK PARAMETER BLOCK FLOPPY 1.44M
SPT_7:	 	.DW 	72	 	; 16 SECTORS OF 128 BYTES PER 2K TRACK
BSH_7:		.DB 	4 		; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
BLM_7:		.DB 	15 		; PART OF THE ALLOCATION BLOCK SIZE MATH
EXM_7:		.DB 	0		; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
DSM_7:	 	.DW 	710 		; BLOCKSIZE [1024] * NUMBER OF BLOCKS + 1 = DRIVE SIZE
DRM_7:	 	.DW 	255 		; NUMBER OF DIRECTORY ENTRIES
AL0_7:		.DB 	0b11110000  	; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
AL1_7:		.DB 	0b00000000  	; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED

CKS_7:	 	.DW 	32 	  	; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
OFF_7:	 	.DW 	2 	  	; FIRST 10 TRACKS TRACKS RESERVED (20K FOR SYSTEM)
					; SYSTEM IS ROM LOADER, CCP, BDOS, CBIOS, AND MONITOR
					;
					; IMPORTANT NOTE: TRACKS 00h - 0AH OF 2K BYTES
					; EACH ARE MARKED WITH THE OFF_6 SET TO 5 AS 
					; SYSTEM TRACKS  USABLE ROM DRIVE SPACE
					; STARTING AFTER THE TENTH TRACK (IE, TRACK 0AH)
					; MOST LIKELY FIX TO THIS IS PLACING A DUMMY
					; FIRST 20K ROM CONTAINS THE ROM LOADER, MONITOR,
 					; CCP, BDOS, BIOS, ETC (10 TRACKS * 2K EACH)
;__________________________________________________________________________________________________ 			
;
;	END OF FIXED CP/M TABLES
;
;	INDIVIDUAL SUBROUTINES TO PERFORM EACH FUNCTION
;__________________________________________________________________________________________________


;___BOOT___________________________________________________________________________________________
BOOT:					; SIMPLEST CASE IS TO JUST PERFORM PARAMETER INITIALIZATION
					;
	LD	A,#0x80			; LOAD VALUE TO SWITCH OUT ROM
	OUT	(MPCL_ROM),A		; SWITCH OUT ROM, BRING IN LOWER 32K RAM PAGE
					;
					;
	LD	A,#0b10000001		; SWITCH IN FIRST 32K LOWER PAGE (FIRST TRACK)
	OUT	(MPCL_RAM),A		;
					; FORMATTING THE RAM IS SIMPLE AS CLEARING THE DIRECTORY AREA 
					; TO A VALUE OF E5H (THE FIRST 8K OF TRACK 1 OR THE RAMDISK) 
	LD	HL,#0000		; STARTING MEMORY ADDRESS OF TRACK 1, SECTOR 0 IN HL
	LD	BC,#0x1FFF		; 8K OF DIRECTORY SECTORS RESERVED (LENGTH IN BC)
	LD	A,#0x0E5			; INITIALIZING VALUE IN A 
	LD	E,L			;
	LD	D,H			;
	INC	DE			;
	LD	(HL),A			;
	LDIR				;
					;
	LD	A,#0x80			; LOAD VALUE TO SWITCH OUT ROM
	OUT	(MPCL_ROM),A		; SWITCH OUT ROM, BRING IN LOWER 32K RAM PAGE
					;
	LD	A,#0			; ENSURE LOWEST RAM PAGE SELECTED
	OUT	(MPCL_RAM),A		; BRING IN LOWEST 32K RAM PAGE
					;
	XOR	A			; ZERO IN THE ACCUM
	LD	(IOBYTE),A		; CLEAR THE IOBYTE
	LD	(CDISK),A		; SELECT DISK 0
					;	
	CALL	IDE_SOFT_RESET		; RESET THE IDE HARD DISK
					;
					;
	JP	GOCPM			; INITIALIZE AND GO TO CP/M
					;
;
;___WBOOT__________________________________________________________________________________________
WBOOT:					; SIMPLEST CASE IS TO READ THE DISK UNTIL ALL SECTORS LOADED
					; WITH A ROMDISK WE SELECT THE ROM AND THE CORRECT PAGE [0]
					; THEN COPY THE CP/M IMAGE (CCP, BDOS, BIOS, MONITOR) TO HIGH RAM
					; LOAD ADDRESS 
					; FOR Z80 IT LOOKS LIKE THIS . USING 8080 NEMONICS	
					;
	DI				; DISABLE INTERRUPT
	LD	SP,#0x80			; USE SPACE BELOW BUFFER FOR STACK
	IM	1			; SET INTERRUPT MODE 1
					;
	XOR	A			; CHEAP ZERO IN ACC
	OUT	(MPCL_ROM),A		; SEND 0 TO ROM MAP PORT (SWITCH IN LOWER 32K ROM PAGE)
					;
	XOR	A			; CHEAP ZERO IN ACC
	OUT	(MPCL_RAM),A		; SEND 0 TO RAM MAP PORT (SELECT LOWEST RAM PAGE)
					;
	LD	HL,#ROMSTART_CPM		; WHERE IN ROM CP/M IS STORED (FIRST BYTE)
	LD	DE,#RAMTARG_CPM		; WHERE IN RAM TO MOVE MONITOR TO (FIRST BYTE)
	LD	BC,#CCPSIZ_CPM		; NUMBER OF BYTES TO MOVE FROM ROM TO RAM
	LDIR				;
					;
					;
;;;;;	EI				; ENABLE INTERRUPTS
	LD	A,#0x80			; LOAD VALUE TO SWITCH OUT ROM
	OUT	(MPCL_ROM),A		; SWITCH OUT ROM, BRING IN LOWER 32K RAM PAGE
					;
	XOR	A			; CHEAP ZERO IN ACC
	OUT	(MPCL_RAM),A		; SEND 0 TO RAM MAP PORT (SELECT LOWEST RAM PAGE)
					;
	CALL	IDE_SOFT_RESET		; RESET THE IDE HARD DISK
					;
 .IF CONDSUPERSUB			;
					; DO NOTHING FOR ORIGINAL CODE
 .ELSE					;
					; CLEAR THE AUTOSUB BUFFER, DO ON A WARM BOOT
	XOR	A			;
	LD	(INBUFF+1),A		; SECOND BYTE IS ACTUAL LENGTH 
 .ENDIF					;
					; FALL THROUGH TO GOCPM ROUTINE
;
;	END OF LOAD OPERATION, SET PARAMETERS AND GO TO CP/M
;
;___GOCPM__________________________________________________________________________________________
GOCPM:
					; CPU RESET HANDLER
	LD	A,#0x0C3			; C3 IS A JMP INSTRUCTION
	LD	(0),A		; FOR JMP TO WBOOT
	LD	HL,#WBOOTE		; WBOOT ENTRY POINT
	LD	(1),HL			; SET ADDRESS FIELD FOR JMP AT 0
					;
					; CPU INTERRUPT HANDLER
	LD	A,#0x0C3			; C3 IS A JMP INSTRUCTION
	LD	(0x0038),A		; FOR JMP TO WBOOT
	LD	HL,#WBOOTE		; WBOOT ENTRY POINT
	LD	(1),HL			; SET ADDRESS FIELD FOR JMP AT 0
					;
	LD	(5),A			; FOR JMP TO BDOS
	LD	HL,#BDOS		; BDOS ENTRY POINT
	LD	(6),HL			; ADDRESS FIELD OF JUMP AT 5 TO BDOS
					;
	LD	BC,#0x80		; DEFAULT DMA ADDRESS IS 80H
	CALL	SETDMA			;
					;
 .IF CONDUSEFLOPPY			;
	CALL	SETUPDRIVE		; SETUP FLOPPY PARAMETERS
 .ENDIF					;
					;
 .IF CONDUSEVDU				;
	DI				; DISABLE INTERRUPTS	
	LD	A,#0x1F			; SET HIGH ROM PAGE
	OUT	(MPCL_ROM),A		; SEND TO ROM PORT MAPPER
	LD	HL,#0			;
	ADD	HL,SP			; GET STACK POINTER INTO HL
	LD	(PARKSTACK),HL		; SAVE STACK POINTER 
	LD	SP,#FLOPPYSTACK		; 
	CALL	VDU_INIT		;
	LD	SP,(PARKSTACK)		; RESTORE STACK
	LD	A,#0x80			; LOAD VALUE TO SWITCH OUT ROM
	OUT	(MPCL_ROM),A		;
	LD	A,#0			; CHOOSE HIGHEST RAM PAGE
	OUT	(MPCL_RAM),A		; SEND 19H TO RAM MAP PORT (SELECT HIGHEST RAM PAGE)
;;;;;	EI				; ENABLE INTERRUPTS	
 .ENDIF					;
	LD	HL,#TXT_STARTUP_MSG 	; PRINT STARTUP MESSAGE
	CALL	PRTMSG			;
					;
	LD	A,(CDISK)		; GET CURRENT DISK NUMBER
	LD	C,A			; SEND TO THE CCP
	JP	CCP			; GO TO CP/M FOR FURTHER PROCESSING
					;
;__________________________________________________________________________________________________
;
;	** CONSOLE & PRINTER I/O -- VDU CARD DRIVER INTERFACE
;		
;__________________________________________________________________________________________________
 .IF CONDUSEVDU
CONST:
	PUSH	HL			; STORE HL
	DI				; DISABLE INTERRUPTS	
	LD	A,#1FH			; SET HIGH ROM PAGE
	OUT	(MPCL_ROM),A		; SEND TO ROM PORT MAPPER
	LD	HL,#0			;
	ADD	HL,SP			; GET STACK POINTER INTO HL
	LD	(PARKSTACK),HL		; SAVE STACK POINTER 
	LD	SP,#FLOPPYSTACK		; 
	CALL	IS_KBHIT		; CHECK FOR KB HIT
	LD	C,A			; STORE RESULT	
	LD	SP,(PARKSTACK)		; RESTORE STACK
	LD	A,#0x80			; LOAD VALUE TO SWITCH OUT ROM
	OUT	(MPCL_ROM),A		;
	LD	A,#0			; CHOOSE HIGHEST RAM PAGE
	OUT	(MPCL_RAM),A		; SEND 19H TO RAM MAP PORT (SELECT HIGHEST RAM PAGE)
	LD	A,C			; RESTORE RESULT
;;;;;	EI				; ENABLE INTERRUPTS
	POP	HL			; RESTORE HL
	RET

CONIN:
	PUSH	HL			; STORE HL
	DI				; DISABLE INTERRUPTS	
	LD	A,#0x1F			; SET HIGH ROM PAGE
	OUT	(MPCL_ROM),A		; SEND TO ROM PORT MAPPER
	LD	HL,#0			;
	ADD	HL,SP			; GET STACK POINTER INTO HL
	LD	(PARKSTACK),HL		; SAVE STACK POINTER 
	LD	SP,#FLOPPYSTACK		; 
	CALL	GET_KEY			; GET KEY FROM KEYBOARD	
	LD	C,A			; STORE RESULT
	LD	SP,(PARKSTACK)		; RESTORE STACK
	LD	A,#0x80			; LOAD VALUE TO SWITCH OUT ROM
	OUT	(MPCL_ROM),A	;
	LD	A,#0x00			; CHOOSE HIGHEST RAM PAGE
	OUT	(MPCL_RAM),A		; SEND 19H TO RAM MAP PORT (SELECT HIGHEST RAM PAGE)
	LD	A,C			; RESTORE RESULT
;;;;;	EI				; ENABLE INTERRUPTS
	POP	HL			; RESTORE HL
	RET
	
CONOUT:
	PUSH	HL			; STORE HL
	DI				; DISABLE INTERRUPTS	
	LD	A,#0x1F			; SET HIGH ROM PAGE	
	OUT	(MPCL_ROM),A		; SEND TO ROM PORT MAPPER
	LD	HL,#0			;
	ADD	HL,SP			; GET STACK POINTER INTO HL
	LD	(PARKSTACK),HL		; SAVE STACK POINTER 
	LD	SP,#FLOPPYSTACK		; 
	LD	A,C			; RESTORE CHARACTER
	CALL	CHARIN			; DISPLAY CHARACTER	
	LD	SP,(PARKSTACK)		; RESTORE STACK
	LD	A,#0x80			; LOAD VALUE TO SWITCH OUT ROM
	OUT	(MPCL_ROM),A	;
	LD	A,#0x00			; CHOOSE HIGHEST RAM PAGE
	OUT	(MPCL_RAM),A		; SEND 19H TO RAM MAP PORT (SELECT HIGHEST RAM PAGE)
;;;;;	EI				; ENABLE INTERRUPTS
	POP	HL			; RESTORE HL
	RET
LIST:
	PUSH	HL			; STORE HL
	DI				; DISABLE INTERRUPTS	
	LD	A,#0x1F			; SET HIGH ROM PAGE
	OUT	(MPCL_ROM),A		; SEND TO ROM PORT MAPPER
	LD	HL,#0			;
	ADD	HL,SP			; GET STACK POINTER INTO HL
	LD	(PARKSTACK),HL		; SAVE STACK POINTER 	
	LD	SP,#FLOPPYSTACK		; 
	LD	A,C			; RESTORE CHARACTER
	CALL    PR_OUTCHAR	;
	LD	SP,(PARKSTACK)		; RESTORE STACK
	LD	A,#0x80			; LOAD VALUE TO SWITCH OUT ROM
	OUT	(MPCL_ROM),A	;
	LD	A,#0x00			; CHOOSE HIGHEST RAM PAGE
	OUT	(MPCL_RAM),A		; SEND 19H TO RAM MAP PORT (SELECT HIGHEST RAM PAGE)
;;;;;	EI				; ENABLE INTERRUPTS
	POP	HL			; RESTORE HL
	RET
	
;__________________________________________________________________________________________________
;
;	** CONSOLE I/O -- ON-BOARD 16550 SERIAL INTERFACE
;		
;__________________________________________________________________________________________________
 .ELSE
CONST:	; CONSOLE STATUS, RETURN 0FFH IF CHARACTER READY, 00H IF NOT
	IN	A,(UART + 5)	; READ LINE STATUS REGISTER (UART5 = 068h + $05)
	AND	#0x01		; TEST IF DATA IN RECEIVE BUFFER
				; IS THERE A CHAR READY? 0=NO, 1=YES
	JP	Z,NOT_READY	;
	LD	A,#0x0FF	; YES, PUT 0FFh IN A AND RETURN
NOT_READY:			;
				; NO, LEAVE 000h IN A AND RETURN
	RET			;
CONIN:				; CONSOLE CHARACTER INTO REGISTER A
				;
	CALL	CONST		; IS A CHAR READY TO BE READ FROM UART?
	CP	#0		; 
	JP	Z,CONIN		; NO?  TRY AGAIN   
	IN	A,(UART)	; YES? READ THE CHAR FROM THE UART (UART0 = 068h + $00)
				; REGISTER AND PASS BACK TO USER
	RET			;
				;
CONOUT:				; CONSOLE CHARACTER OUTPUT FROM REGISTER C
	IN	A,(UART + 5)	; READ LINE STATUS REGISTER
	AND	#0x20		; TEST IF UART IS READY TO SEND
	JP	Z,CONOUT	; IF NOT REPEAT
				;
	LD	A,C		; GET TO ACCUMULATOR
	OUT	(UART),A  ; THEN WRITE THE CHAR TO UART (UART0 = 068h + $00)
	RET			;
				;
LIST:				;LIST CHARACTER FROM REGISTER C
	LD	A,C		;CHARACTER TO REGISTER A
	RET			;NULL SUBROUTINE
 .ENDIF
				;
LISTST:					;RETURN LIST STATUS (0 IF NOT READY, 1 IF READY)
	XOR	A			;0 IS ALWAYS OK TO RETURN
	RET				;
					;
					;
;__________________________________________________________________________________________________
;
;	** PUNCH & READER I/O -- STUB
;		
;__________________________________________________________________________________________________			
PUNCH:					;PUNCH CHARACTER FROM REGISTER C
	LD	A,C			;CHARACTER TO REGISTER A
	RET				;NULL SUBROUTINE
					;
READER:					;READ CHARACTER INTO REGISTER A FROM READER DEVICE
	LD	A,C			;CHARACTER TO REGISTER A
	RET
	
	
;__________________________________________________________________________________________________
;
;	** DISK STORAGE I/O 
;		
;__________________________________________________________________________________________________
;
;   SELECT DISK GIVEN BY REGISTER C
;__________________________________________________________________________________________________

SELDSK:	LD	HL,#0x0000		; ERROR RETURN CODE
	LD	A,C			;
 .IF CONDABONLY				;
	CP	#7			; MUST BE BETWEEN 0 AND 6
 .ELSE					;
	CP	#2			; IF NO IDE THEN ONLY DRIVE A AND B FOR THE MINI N8VEM SO 0 OR 1 ONLY
 .ENDIF					;
	RET	NC			; RETURN IF OUT OF RANGE
	LD	(DISKNO),A		;
					; DISK NUMBER IS IN THE PROPER RANGE
					; COMPUTE PROPER DISK PARAMETER HEADER ADDRESS
	LD	L,A			; L=DISK NUMBER 0,1,2,3,4
	LD	H,#0			; HIGH ORDER ZERO
	ADD	HL,HL			; *2
	ADD	HL,HL			; *4
	ADD	HL,HL			; *8
	ADD	HL,HL			; *16 (SIZE OF EACH HEADER)
	LD	DE,#DPBASE		;
	ADD	HL,DE			; HL= DPBASE(DISKNO*16)
	RET
;__________________________________________________________________________________________________	
HOME:					; MOVE TO THE TRACK 00 POSITION OF CURRENT DRIVE
					; TRANSLATE THIS CALL INTO A SETTRK CALL WITH PARAMETER 00
	LD	BC,#0			; SELECT TRACK 0000
;__________________________________________________________________________________________________
SETTRK:					; SET TRACK GIVEN BY REGISTER BC
	LD	H,B			;
	LD	L,C			;
	LD	(TRACK),HL		;
	RET
;__________________________________________________________________________________________________
SETSEC:					; SET SECTOR GIVEN BY REGISTER BC
	LD	H,B			;
	LD	L,C			;
	LD	(SECTOR),HL		;
	RET				;
;__________________________________________________________________________________________________
;
;  TRANSLATE THE SECTOR GIVEN BY BC USING THE
;  TRANSLATE TABLE GIVEN BY DE
;  ONLY USED FOR FLOPPIES! FOR ROMDISK/RAMDISK/IDE/ATAPI IT'S 1:1
;  DO THE NEXT ROUTINE IS A NULL (RETURNS THE SAME)
;__________________________________________________________________________________________________
SECTRN:	
	LD	H,B			;
	LD	L,C			;
	RET				;
;__________________________________________________________________________________________________
SETDMA:					; SET DMA ADDRESS GIVEN BY REGISTERS B AND C
	LD	L,C			; LOW ORDER ADDRESS
	LD	H,B			; HIGH ORDER ADDRESS
	LD	(DMAAD),HL		; SAVE THE ADDRESS
	RET
;________________________________________________________________________________________________________
;  DISK DRIVERS .
;
; DRIVER NEEDS TO DO SEVERAL THINGS FOR ROM AND RAM DISKS 
;   - INTERRUPTS ARE NOT ALLOWED DURING LOW RAM/ROM ACCESS (DISABLE!)
;   -TRANSLATE TRACK AND SECTOR INTO A POINTER TO WHERE THE 128 BYTE 
;     SECTOR BEGINS IN THE RAM/ROM
;   -TRANSLATE THE DRIVE INTO A RAM/ROM SELECT, COMBINE WITH TRACK ADDRESS
;     AND SEND TO THE MAP PORT 
;   -COPY 128 BYTE FROM OR TO THE ROM/RAMDISK AND MEMORY POINTED TO BY THE DMA 
;     ADDRESS PREVIOUSLY STORED 
;   -RESTORE MAP PORT TO PRIOR CONDITION BEFOR READ/WRITE
;
;   - FIRST TRICK IS THAT WE MADE SECTORS 256 AS 256*128=32768   SO WE COPY 
;     THE LOW SECTOR ADDRESS TO THE LOW BYTE OF THE HL REGISTER AND THEN 
;     MULTIPLY BY 128  THIS RESULTS IN THE STARTING ADDRESS IN THE RAM OR ROM
;     (0000 -> 7F80H) 32K PAGE 
;
;    - TRICK TWO IS THE TRACK ADDRESS  EQUALS THE 32K PAGE ADDRESS AND IS A 
;      DIRECT SELECT THAT CAN BE COPIED TO THE MAP PORT D0 THROUGH D5   D7
;      SELECTS THE DRIVE (ROM OR RAM) 
;      THAT MEANS THE LOW BYTE OF TRACK CONTAINS THE D0-D5 VALUE AND 
;      DISKNO HAS THE DRIVE SELECTED   WE FIRST COPY DISKNO TO ACC
;      AND RIGHTSHIFT IT TO PLACE THAT IN BIT 7, WE THEN ADD THE LOW BYTE OF 
;      TRACK TO ACC AND THEN SEND THAT TO THE MAP PORT 
;
;      NOTE 1: A WRITE TO ROM SHOULD BE FLAGGED AS AN ERROR 
;      NOTE 2: RAM MUST START AS A "FORMATTED DISK"  IF BATTERY BACKED UP
;                   IT'S A DO ONCE AT COLD COLD START   IF NOT BATTERY BACKED U
;                   IT WILL HAVE TO BE DONE EVERY TIME THE SYSTEM IS POWERED 
;                   FORMATTING THE RAM IS SIMPLE AS CLEARING THE DIRECTORY AREA
;                   TO A VALUE OF E5H (THE FIRST 8K OF TRACK 1 OR THE RAMDISK) 
;                   IT COULD BE DONE AS A SIMPLE UTILITY PROGRAM STORED IN ROMD
;                   OR ANYTIME COLBOOT IS CALLED(LESS DESIREABLE) 
;
;     -WE NOW CAN COPY TO OR FROM AS CORRECT FOR THE DEVICE 128 BYTES (SECTOR)
;      TO OR FROM THE DMA ADDRESS  ALMOST!  SINCE ROM OR RAM IS BEING PAGED
;      WE HAVE TO COPY ANYTHING DETINED FOR BELOW 8000H TO A TEMP BUFFER THEN
;      HANDLE THE PAGING 
;        
;
;     - LAST STEP IS TO RESTORE THE MAP PORT TO POINT TO THE RAM (TRACK 0) SO T
;       MEMORY MAP IS ALL RAM AGAIN AND NOT POINTING INTO THE DATA AREAS OR THE
;       SINCE THE RAM 0TH PAGE IS NOMINALLY THE LOW 32K OF RAM IN THE SYSTEM WE
;       SEND A SIMPLE MVI A,80H ; OUT MPCL_ROM	; MVI A,00H ; OUT MPCL_RAM 
;
;      - THE READ OR WRITE OPERATION IS DONE 
;
;   READ DISK
;    USES DE,DL, BC,  ACC FLAGS
;      Z80 COULD USE BLOCK MOVE [LDIR] BUT WRITTEN IN 8080 
;________________________________________________________________________________________________________

;__READ__________________________________________________________________________________________________
;
; 	PERFORM CP/M SECTOR READ
;________________________________________________________________________________________________________
READ:
	DI				; DISABLE INTERRUPTS
	LD	A,(DISKNO)		; GET DRIVE
	CP	#0x01			; "B"
 .IF CONDUSEFLOPPY
	JP	Z,READ_FLPY_DSK 	; READ FLOPPY
 .ELSE
	JP	Z,READ_RAM_DISK		; READ FROM 448K RAM DISK		
 .ENDIF
	CP	#0			; "B"
	JP	Z,READ_RAM_DISK		; READ FROM 448K RAM DISK
	CP	#2			; "C"
	JP	Z,READ_IDE		; READ FROM 8 MB IDE HARD DISK
	CP	#3			; "D"
 .IF CONDUSEATAPI
 	JP	Z,READ_ATAPI		; READ FROM 8 MB ATAPI
 .ELSE
	JP	Z,READ_RAM_DISK		; READ FROM 448K RAM DISK		
 .ENDIF

	CP	#4			; "E"
	JP	Z,READ_HDPART4		; READ FROM 1 MB IDE HARD DISK, PARTITION 4  ** future use
	CP	#5			; "F"
	JP	Z,READ_RAM_DISK		; READ FROM 1M ROM DISK (UTILIZES SAME
					; ROUTINES AS RAM_DISK
					; "G"
					; READ FROM 22K EEPROM DISK , SO FALL THROUGH

;___READ_EEPROM_DISK_____________________________________________________________________________________
;
;	READ EEPROM DISK
;________________________________________________________________________________________________________
READ_EEPROM_DISK:
					; 
					; IF ROM, MAP TRACK/SECTOR TO VIRTUAL TRACK/SECTOR
					; HANDLE READING FROM ROM HERE
					; 
					; PURPOSE OF THIS ROUTINE IS TO MAP 32K ROM PART
					; TRACK/SECTOR MAP (2K TRACK SIZE MADE OF 16 128
					; BYTE SECTORS EACH) ONTO WHAT THE RAM/ROM SECTOR
					; READ ROUTINES ARE EXPECTING (32K TRACK SIZE MADE
					; OF 256 128 BYTE SECTORS EACH)   THE ROUTINE 
					; CONVERTS 4 BIT TRACK # AND 4 BIT SECTOR #
					; INTO A VIRTUAL 1 TRACK, 256 SECTOR ACCESS
	LD	HL,(TRACK)		; TRACK # IS UPPER 4 BITS OF SECTOR ADDRESS
	ADD	HL,HL			; SHIFT BITS LEFT 1 (*2)
	ADD	HL,HL			; SHIFT BITS LEFT 1 (*4)
	ADD	HL,HL			; SHIFT BITS LEFT 1 (*8)
	ADD	HL,HL			; SHIFT BITS LEFT 1 (*16)
	LD	B,H			; PUT UPPER 4 BITS OF SECTOR ADDRESS IN BC
	LD	C,L			; (B IS UPPER BYTE AND C IS LOWER BYTE)
					; BC NOW CONTAINS THE UPDATED TRACK #
	LD	HL,(SECTOR)		; SECTOR # IS LOWER 4 BITS OF SECTOR ADDRESS
	ADD	HL,BC			; VIRTUAL SECTOR = (UPDATED TRACK #) + SECTOR #
	LD	(PSECTOR),HL		; STORE VIRTUAL SECTOR #
					; NOW CONTINUE READING ROM WITH REGULAR RAM
					; SETUP FOR READ OF RAM OR ROM DISK
	LD	HL,(PSECTOR)		;
	ADD	HL,HL			; SHIFT BITS LEFT 1 (*2)
	ADD	HL,HL			; SHIFT BITS LEFT 1 (*4)
	ADD	HL,HL			; SHIFT BITS LEFT 1 (*8)
	ADD	HL,HL			; SHIFT BITS LEFT 1 (*16)
	ADD	HL,HL			; SHIFT BITS LEFT 1 (*32)
	ADD	HL,HL			; SHIFT BITS LEFT 1 (*64)
	ADD	HL,HL			; SHIFT BITS LEFT 1 (*128)
	LD	(SECST),HL		; SAVE SECTOR STARTING ADDRESS
					; SET PAGER WITH DRIVE (0) AND TRACK (0)
	LD	A,#0			; SWITCH IN ROM PAGE 
	OUT	(MPCL_ROM),A		; SEND TO PORT MAPPER
	LD	(PAGER),A		; SAVE COPY (JUST BECAUSE)	
	LD	HL,#SECTOR_BUFFER	; LOAD HL WITH TEMP BUF ADDRESS
	LD	E,L			;
	LD	D,H			; GET IT INTO DE
	LD	HL,(SECST)		; GET ROM/RAM ADDRESS
	CALL	COPY_CPM_SECTOR		;
	CALL	RPAGE			; SET PAGE TO CP/M RAM
	LD	HL,(DMAAD)		; LOAD HL WITH DMA ADDRESS
	LD	E,L			;
	LD	D,H			; GET IT INTO DE
	LD	HL,#SECTOR_BUFFER	; GET ROM/RAM ADDRESS
	CALL	COPY_CPM_SECTOR		;
	LD	A,(DISKNO)		; STORE CURRENT DRIVE IN BUFFER
	LD	(CUDISK),A		;
	LD	A,#0			;
;;;;;	EI				; RE-ENABLE INTERRUPTS
	RET		
;___READ_RAM_DISK_________________________________________________________________________________________
;
;	READ RAM DISK
;________________________________________________________________________________________________________
READ_RAM_DISK:				;
					; IF RAM, PROCEED WITH NORMAL TRACK/SECTOR READ
	CALL	SECPAGE			; SETUP FOR READ OF RAM OR ROM DISK
	CALL	PAGERB			; SET PAGER WITH DRIVE AND TRACK
	LD	HL,#SECTOR_BUFFER	; LOAD HL WITH TEMP BUF ADDRESS
	LD	E,L			;
	LD	D,H			; GET IT INTO DE
	LD	HL,(SECST)		; GET ROM/RAM ADDRESS
	CALL	COPY_CPM_SECTOR		; MOVE SECTOR TO SECTOR_BUFFER
	CALL	RPAGE			; SET PAGE TO CP/M RAM
	LD	HL,(DMAAD)		; LOAD HL WITH DMA ADDRESS					;
	LD	E,L			;
	LD	D,H			; GET IT INTO DE
	LD	HL,#SECTOR_BUFFER	; GET ROM/RAM ADDRESS
	CALL	COPY_CPM_SECTOR		; MOVE SECTOR FROM SECTOR_BUFFER TO DMA AREA
	LD	A,(DISKNO)		; STORE CURRENT DRIVE IN BUFFER
	LD	(CUDISK),A		;
	LD	A,#0			;
;;;;;	EI				; RE-ENABLE INTERRUPTS
	RET
	
;___TRFLSEC______________________________________________________________________________________________
;
;	TRANSLATE LOGICAL FLOPPY DISK SECTOR TO PHYSICAL SECTOR
;	IN:  TRACK,SECTOR
;	OUT: PTRACK,PSECTOR,SECTOR_INDEX
;________________________________________________________________________________________________________
TRFLSEC:	
	LD	A,(TRACK)		; LOAD TRACK # (LOW BYTE)
	AND	#1			; FILTER OUT HEAD
	LD	(HEAD),A		; STORE HEAD
	LD	A,(TRACK)		; SAVE TRACK IN A
	SRL	A			; REMOVE HEAD BIT	
	LD	(PTRACK),A		; STORE IN TRACK
	LD	A,(SECTOR)		; LOAD SECTOR # (LOW BYTE)
	LD	(SECTOR_INDEX),A	; STORE SECTOR IN SECTOR INDEX
	SRL	A			; 
	SRL	A			; DIVIDE BY 4 (FOR BLOCKING)
	LD	(PSECTOR),A		; STORE IN SECTOR
	LD	A,(SECTOR_INDEX)	; FILTER OUT UNWANTED BITS
	AND	#3			;
	LD	(SECTOR_INDEX),A	;
	RET	

;___DEBSEC_______________________________________________________________________________________________
;
;	DEBLOCK 512 BYTE SECTOR FOR CP/M
;
;________________________________________________________________________________________________________
DEBSEC:	
	LD	HL,(DMAAD)		; LOAD HL WITH DMA ADDRESS
	LD	D,H			; TRANSFER HL REGISTERS TO DE
	LD	E,L			;
	PUSH	DE			; STORE DE
					; COMPUTE STARTING ADDRESS OF CP/M SECTOR IN READ SECTOR BUFFER
	LD	HL,#SECTOR_BUFFER	; LOAD HL WITH SECTOR BUFFER ADDRESS
	LD	A,(SECTOR_INDEX)	; GET THE SECTOR INDEX (CP/M SECTOR OFFSET IN BUFFER)
	RRCA				; MOVE BIT 0 TO BIT 7
	RRCA				; DO AGAIN - IN EFFECT MULTIPLY BY 4
	LD	D,#0			; PUT RESULT AS 16 VALUE IN DE, UPPER BYTE IN D IS 000h
	LD	E,A			; PUT ADDRESS OFFSET IN E
	ADD	HL,DE			; MULTIPLY BY 2, TOTAL MULTIPLICATION IS X 128
	ADD	HL,DE			; CP/M SECTOR STARTING ADDRESS IN IDE HD SECTOR BUFFER
					; COPY CP/M SECTOR TO BDOS DMA ADDRESS BUFFER			
	POP	DE			; RESTORE DE			
	CALL	COPY_CPM_SECTOR		;
	RET

;___BLKSEC_______________________________________________________________________________________________
;
;	BLOCK 512 BYTE SECTOR FOR CP/M
;
;________________________________________________________________________________________________________
BLKSEC:	
					; COMPUTE STARTING ADDRESS OF CP/M SECTOR IN READ SECTOR BUFFER	
	LD	HL,#SECTOR_BUFFER	; LOAD HL WITH SECTOR BUFFER ADDRESS
	LD	A,(SECTOR_INDEX)	; GET THE SECTOR INDEX (CP/M SECTOR OFFSET IN BUFFER)
	RRCA				; MOVE BIT 0 TO BIT 7
	RRCA				; DO AGAIN - IN EFFECT MULTIPLY BY 64
	LD	D,#0			; PUT RESULT AS 16 VALUE IN DE, UPPER BYTE IN D IS 000h
	LD	E,A			; PUT ADDRESS OFFSET IN E
	ADD	HL,DE			; CP/M SECTOR STARTING ADDRESS IN IDE HD SECTOR BUFFER
	ADD	HL,DE			; MULTIPLY BY 2, TOTAL MULTIPLICATION IS X 128
	LD	(SECST),HL		; KEEP CP/M SECTOR ADDRESS FOR LATER USE
					; COPY CP/M SECTOR FROM BDOS DMA ADDRESS BUFFER
	LD	HL,(SECST)		; LOAD CP/M SECTOR ADDRESS (WHERE THE DATA IS TO BE WRITTEN)
	LD	D,H			; TRANSFER HL REGISTERS TO DE
	LD	E,L			;
	LD	HL,(DMAAD)		; LOAD HL WITH DMA ADDRESS (WHERE THE DATA TO BE WRITTEN IS)
	CALL	COPY_CPM_SECTOR		;
	RET
	
;___ISCUR_______________________________________________________________________________________________
;
;	IS CURRENT SECTOR IN BUFFER?
;
;________________________________________________________________________________________________________
ISCUR:		
	LD	HL,(PSECTOR)		; COMPARE REQUESTED SECTOR WITH SECTOR IN BUFFER
	LD	A,(CUSECTOR)		; 
	CP	L			;
	RET	NZ			; LOW BYTE NOT  EQUAL
	LD	A,(CUSECTOR+1)		; 
	CP	H			;
	RET	NZ			; HIGH BYTE NOT  EQUAL
	LD	HL,(PTRACK)		; COMPARE REQUESTED TRACK WITH TRACK IN BUFFER
	LD	A,(CUTRACK)		; 
	CP	L			; LOW BYTE NOT  EQUAL
	RET	NZ			;
	LD	A,(CUTRACK+1)		; 
	CP	H			;
	RET	NZ			; HIGH BYTE NOT  EQUAL
	LD	HL,(DISKNO)		; COMPARE REQUESTED DRIVE WITH DRIVE IN BUFFER
	LD	A,(CUDISK)		;
	CP	L			;
	RET				; EXIT WITH RESULT

;___READ_FLPY_DSK________________________________________________________________________________________
;
;	READ FLOPPY DISK
;
;________________________________________________________________________________________________________

READ_FLPY_DSK:
	DI				; DISABLE INTERRUPTS
	LD	HL,#0			;
	ADD	HL,SP			; GET STACK POINTER INTO HL
	LD	(PARKSTACK),HL		; SAVE STACK POINTER 
	LD	SP,#FLOPPYSTACK		; 
	CALL	TRFLSEC			; TRANSLATE SECTOR INFORMATION
	CALL 	READ_FLPY_SEC		;
	CALL	DEBSEC			; DEBLOCK SECTOR
	LD	A,(ST1)			; LOAD RESULT CODE INTO A
READ_FLPY_DSK_EXIT:			;
	LD	SP,(PARKSTACK)		; RETURN STACK
;;;;;	EI				; RE-ENABLE INTERRUPTS
	RET
	
	
;___READ_FLPY_SEC________________________________________________________________________________________
;
;	READ A SECTOR FROM A FLOPPY DISK
;
;________________________________________________________________________________________________________
READ_FLPY_SEC:
	LD	A,#0			; RESET STATUS FLAG 1
	LD	(ST1),A			;
	CALL	ISCUR			; IS CURRENT SECTOR ALREADY IN BUFFER
	JP	Z,READ_FLPY_SEC_OK
	LD	A,#20			; 20 RETRIES
	LD	(RETRY),A		;
	LD	A,#2			; 2 ITERATIONS OF RETRIES 
	LD	(RETRY1),A		;	
READ_FLPY_SEC_RETRY:			;
	CALL	FLOPPYREAD		; READ THE FLOPPY DISK SECTOR
	LD	A,(ST0)			; GET STATUS FLAG 0
	AND	#0x0F8			; MASK OF DRIVE AND HEAD SELECTION
	LD	B,A			; MOVE STATUS FLAG 0 TO B
	LD	A,(ST1)			; GET STATUS FLAG 1
	OR	B			; IF ZERO READ WAS OK
	JP	Z,READ_FLPY_SEC_OK
	LD	A,(RETRY)		; READ NOT OK, DEC RETRY COUNTER
	DEC	A			; 
	LD	(RETRY),A		; STORE NEW RETRY COUNTER
	JP	NZ,READ_FLPY_SEC_RETRY
	CALL	CYCLEFLOPPY		; CYCLE FLOPPY HEAD
	LD	A,#20			; RESET TO 20 RETRIES
	LD	(RETRY),A		; STORE RETRY COUNTER
	LD	A,(RETRY1)		; DEC RETRY ITERATION COUNTER
	DEC	A			;
	LD	(RETRY1),A		;
	JP	NZ,READ_FLPY_SEC_RETRY
	LD	HL,#0x0FFFF		; SET INVALID CONDITION, BUFFER IS INVALID
	LD	(CUSECTOR),HL		; CURRENT PHYSICAL DISK SECTOR IN BUFFER
	LD	(CUTRACK),HL		; CURRENT PHYSICAL DISK TRACK IN BUFFER
	RET				;
READ_FLPY_SEC_OK:			;
	LD	HL,(PSECTOR)		; STORE PHYSICAL SECTOR IN BUFFER
	LD	(CUSECTOR),HL		; 
	LD	HL,(PTRACK)		; STORE PHYSICAL DISK TRACK IN BUFFER
	LD	(CUTRACK),HL		; 
	LD	A,(DISKNO)		; STORE CURRENT DRIVE IN BUFFER
	LD	(CUDISK),A		;
	RET
	
;___READ_IDE_____________________________________________________________________________________________
;
;	READ  FROM IDE HARD DISK  
;________________________________________________________________________________________________________

READ_IDE:
	DI				; DISABLE INTERRUPTS
	LD	HL,#0			;
	ADD	HL,SP			; GET STACK POINTER INTO HL
	LD	(PARKSTACK),HL		; SAVE STACK POINTER 
	LD	SP,#FLOPPYSTACK		; 
					; DISABLE INTERRUPTS
	CALL	CONVERT_IDE_SECTOR_CPM 	
	CALL	IDE_READ_SECTOR		; READ THE IDE HARD DISK SECTOR
	JP	NC,READ_IDE_ERROR
	CALL	DEBSEC			;
	LD	SP,(PARKSTACK)		; RETURN STACK
;;;;;	EI				; RE-ENABLE INTERRUPTS
	LD	A,#0			; RETURN ERROR CODE READ SUCCESSFUL A=0
	RET				;
READ_IDE_ERROR:				;
	LD	SP,(PARKSTACK)		; RETURN STACK
;;;;;	EI				; RE-ENABLE INTERRUPTS
	LD	A,#0x0FF			; RETURN ERROR CODE READ ERROR A=FF
	RET	

;___READ_ATAPI_________________________________________________________________________________________
;
;	READ  FROM ATAPI DEVICE
;________________________________________________________________________________________________________	
READ_ATAPI:
	LD	A,#0x0FF			; 255 RETRIES
	LD	(RETRY),A		;
READ_ATAPI_RETRY:	
	LD	A,#0x10			; SET TO SECONDARY DEVICE
	LD	(IDEDEVICE),A		;
	DI				; DISABLE INTERRUPTS
	LD	HL,#0			;
	ADD	HL,SP			; GET STACK POINTER INTO HL
	LD	(PARKSTACK),HL		; SAVE STACK POINTER 
	LD	SP,#FLOPPYSTACK		; 
	CALL	CONVERT_IDE_SECTOR_CPM	
	CALL	ATAPI_READ_SECTOR	
	JP	NC,READ_ATAPI_ERROR	
	CALL	DEBSEC			;
	LD	SP,(PARKSTACK)		; RETURN STACK
;;;;;	EI				; RE-ENABLE INTERRUPTS
	LD	A,#0			; RETURN ERROR CODE READ SUCCESSFUL A=0
	RET				;
READ_ATAPI_ERROR:	
	LD	A,(RETRY)		; READ NOT OK, DEC RETRY COUNTER
	DEC	A			; 
	LD	(RETRY),A		; STORE NEW RETRY COUNTER
	JP	NZ,READ_ATAPI_RETRY	
	LD	SP,(PARKSTACK)		; RETURN STACK
;;;;;	EI				; RE-ENABLE INTERRUPTS
	LD	A,#0x0FF			; RETURN ERROR CODE READ ERROR A=FF
	RET				;
	
READ_HDPART4:
					; STUB
	RET

;___WRITE______________________________________________________________________________________________
;
;   HANDLE CP/M WRITE CALL
;
;________________________________________________________________________________________________________
WRITE:
	DI				; DISABLE INTERRUPTS
	LD	A,(DISKNO)		; GET DRIVE
	CP	#1			; FIND OUT WHICH DRIVE IS BEING REQUESTED
 .IF CONDUSEFLOPPY
	JP	Z,WRITE_FLP_DSK		;
 .ELSE
	JP	Z,WRITE_RAM_DISK	; WRITE TO 448K RAM DISK
 .ENDIF
	CP	#0			; 
	JP	Z,WRITE_RAM_DISK	; WRITE TO 448K RAM DISK
	CP	#2			;
	JP	Z,WRITE_IDE		; WRITE TO 8 MB IDE HARD DISK, PARTITION 2
	CP	#3			;
 .IF CONDUSEATAPI
	JP	Z,WRITE_ATAPI		; WRITE TO 8 MB IDE HARD DISK, PARTITION 3
 .ELSE
	JP	Z,WRITE_RAM_DISK	; WRITE TO 448K RAM DISK
 .ENDIF
	CP	#4			;
	JP	Z,WRITE_HDPART4		; WRITE TO 1 MB IDE HARD DISK, PARTITION 4


;___RDONLY______________________________________________________________________________________________
;
;   HANDLE WRITE TO READ ONLY
;
;   SENDS A MESSAGE TO TERMINAL THAT ROM DRIVE IS NOT WRITEABLE
;   DOES A PAUSE THEN RETURNS TO CPM WITH ERROR FLAGGED  THIS IS
;   DONE TO ALLOW A POSSIBLE GRACEFUL EXIT (SOME APPS MAY PUKE) 
;________________________________________________________________________________________________________
RDONLY:
	LD	HL,#TXT_RO_ERROR		; SET HL TO START OF ERROR MESSAGE
	CALL	PRTMSG			; PRINT ERROR MESSAGE
	LD	A,#1			; SEND BAD SECTOR ERROR BACK
					; BDOS WILL ALSO PRINT ITS OWN ERROR MESSAGE
	RET

;___WRITE_RAM_DISK_____________________________________________________________________________________
;
;	WRITE RAM DISK
;________________________________________________________________________________________________________
WRITE_RAM_DISK:
	LD	HL,#SECTOR_BUFFER	; LOAD HL WITH TEMP BUF ADDRESS
	LD	E,L			;
	LD	D,H			; GET IT INTO DE
	LD	HL,(DMAAD)		; GET DMA ADDRESS
	CALL	COPY_CPM_SECTOR		;
	CALL	SECPAGE			; GET RAM PAGE WRITE ADDRESS
	CALL	PAGERB			; SET PAGER WITH DRIVE AND TRACK
	LD	HL,(SECST)		; LOAD HL WITH DMA ADDRESS (WHERE TO WRITE TO)
	LD	E,L			;
	LD	D,H			; GET IT INTO DE
	LD	HL,#SECTOR_BUFFER	; GET TEMP BUFFER ADDRESS
	CALL	COPY_CPM_SECTOR		;
	CALL	RPAGE			; SET BACK TO RAM
	LD	A,(DISKNO)		; STORE CURRENT DRIVE IN BUFFER
	LD	(CUDISK),A		;
	LD	A,#0			;
;;;;;	EI				; RE-ENABLE INTERRUPTS
	RET
	
;___WRITE_FLP_DSK_____________________________________________________________________________________
;
;	WRITE FLOPPY DISK
;________________________________________________________________________________________________________
WRITE_FLP_DSK:
	DI				; DISABLE INTERRUPTS
	LD	HL,#0			;
	ADD	HL,SP			; MOVE STACK POINTER TO HL
	LD	(PARKSTACK),HL		; SAVE STACK POINTER 
	LD	SP,#FLOPPYSTACK		;
	CALL	TRFLSEC			; TRANSLATE SECTOR INFORMATION
	CALL 	READ_FLPY_SEC		;
	LD	A,(ST1)			; GET STATUS CODE
	JP	NZ,WRITE_FLP_DSK_OK	
WRITE_READ_FLPY_DSK_OK:			;
	CALL	BLKSEC			; BLOCK SECTOR 
					; IDE HD SECTOR IS NOW UPDATED WITH CURRENT CP/M SECTOR DATA SO WRITE TO DISK
	LD	A,#20			; 20 RETRIES
	LD	(RETRY),A		;
WRITE_FLP_DSK_RETRY:			;
	CALL	FLOPPYWRITE		; WRITE THE FLOPPY DISK SECTOR
	LD	A,(ST0)			; GET STATUS CODE 0
	AND	#0x0F8			; MASK OF DRIVE AND HEAD SELECTION
	LD	B,A			; MOVE STATUS CODE 0 TO B
	LD	A,(ST1)			; GET STATUS CODE 1
	OR	B			; IF ZERO WRITE WAS OK
	JP	Z,WRITE_FLP_DSK_OK	;
	LD	A,(RETRY)		; BAD WRITE, DEC RETRY COUNTER
	DEC	A			;
	LD	(RETRY),A		; STORE NEW RETRY COUNTER
	JP	NZ,WRITE_FLP_DSK_RETRY	;
WRITE_FLP_DSK_OK:			;
	LD	SP,(PARKSTACK)		; RESTORE STACK
	LD	A,(ST1)			; GET STATUS CODE 1
;;;;;	EI				; RE-ENABLE INTERRUPTS
	RET

	

;___WRITE_IDE____________________________________________________________________________________________
;
;	WRITE TO IDE DEVICE
;________________________________________________________________________________________________________	
WRITE_IDE:
	DI				; DISABLE INTERRUPTS
	LD	HL,#0			;
	ADD	HL,SP			; GET STACK POINTER INTO HL
	LD	(PARKSTACK),HL		; SAVE STACK POINTER 
	LD	SP,#FLOPPYSTACK		; 
	CALL	CONVERT_IDE_SECTOR_CPM 	;
	CALL	IDE_READ_SECTOR		; READ THE IDE HARD DISK SECTOR
	JP	NC,WRITE_IDE_ERROR	;
	CALL	BLKSEC			; DEBLOCK SECTOR
	CALL	IDE_WRITE_SECTOR	; WRITE THE UPDATED IDE HARD DISK SECTOR
	LD	SP,(PARKSTACK)		; RESTORE STACK
;;;;;	EI				; RE-ENABLE INTERRUPTS
	LD	A,#0			; RETURN ERROR CODE WRITE SUCCESSFUL A=0
	RET				;
WRITE_IDE_ERROR:			;
	LD	SP,(PARKSTACK)		; RESTORE STACK
;;;;;	EI				; RE-ENABLE INTERRUPTS
	LD	A,#0x0FF			; RETURN ERROR CODE WRITE ERROR A=FF
	RET

;___WRITE_ATAPI__________________________________________________________________________________________
;
;	WRITE TO ATAPI DEVICE
;________________________________________________________________________________________________________	
WRITE_ATAPI:
	LD	A,#0x10			; SET TO SECONDARY DEVICE
	LD	(IDEDEVICE),A		;
	DI				; DISABLE INTERRUPTS
	LD	HL,#0			;
	ADD	HL,SP			; GET STACK POINTER INTO HL
	LD	(PARKSTACK),HL		; SAVE STACK POINTER 
	LD	SP,#FLOPPYSTACK		; 
					;
	CALL	CONVERT_IDE_SECTOR_CPM	;
					;
	CALL	ATAPI_READ_SECTOR	;
	JP	NC,WRITE_ATAPI_ERROR	;
	CALL	BLKSEC			; DEBLOCK SECTOR
	CALL	ATAPI_WRITE_SECTOR	;
					;
	LD	SP,(PARKSTACK)		; RESTORE STACK			
;;;;;	EI				; RE-ENABLE INTERRUPTS
	LD	A,#0			; RETURN ERROR CODE WRITE SUCCESSFUL A=0
	RET				;
WRITE_ATAPI_ERROR:			;
	LD	SP,(PARKSTACK)		; RESTORE STACK
;;;;;	EI				; RE-ENABLE INTERRUPTS
	LD	A,#0x0FF		; RETURN ERROR CODE WRITE ERROR A=FF
	RET				;
	
WRITE_HDPART4:
					; STUB
	RET


;___PRTMSG_______________________________________________________________________________________________
;
;	PRINT MESSAGE POINTED TO BY HL ON CONSOLE DEVICE
;________________________________________________________________________________________________________	
PRTMSG:
	LD	A,(HL)			; GET CHARACTER TO A
	CP	#END			; TEST FOR END BYTE
	JP	Z,PRTMSG1		; JUMP IF END BYTE IS FOUND
	LD	C,A			; PUT CHAR TO PRINT VALUE IN REG C FOR CONOUT
	CALL	CONOUT			; SEND CHARACTER TO CONSOLE FROM REG C
	INC	HL			; INC POINTER, TO NEXT CHAR
	JP	PRTMSG			; TRANSMIT LOOP
PRTMSG1:
	RET


;___SECPAGE_______________________________________________________________________________________________
;
;	UTILITY ROUTINE FOR SECTOR TO PAGE ADDRESS
;________________________________________________________________________________________________________	
SECPAGE:
	LD	HL,(SECTOR)		; GET SECTOR INTO HL
	ADD	HL,HL			; SHIFT BITS 1 TO LEFT (*2)
	ADD	HL,HL			; SHIFT BITS 1 TO LEFT (*4)
	ADD	HL,HL			; SHIFT BITS 1 TO LEFT (*8)
	ADD	HL,HL			; SHIFT BITS 1 TO LEFT (*16)
	ADD	HL,HL			; SHIFT BITS 1 TO LEFT (*32)
	ADD	HL,HL			; SHIFT BITS 1 TO LEFT (*64)
	ADD	HL,HL			; SHIFT BITS 1 TO LEFT (*128)
	LD	(SECST),HL		; SAVE SECTOR STARTING ADDRESS
	RET
	
;___PAGERB_______________________________________________________________________________________________
;
;	PAGER BYTE CREATION
;    	ASSEMBLES DRIVE AND TRACK AND SENDS IT TO PAGER PORT
;________________________________________________________________________________________________________	
PAGERB:	
	LD	HL,(TRACK)		; LOAD TRACK INTO HL
	LD	A,(DISKNO)		; LOAD DISK INTO A
	CP	#5			; IS ROM?
	JP	Z,ROMD			; READ FROM 1M ROM DISK
	CP	#6			; IS ROM?
	JP	Z,ROMD			; READ FROM 22K ROM DISK
	AND	#1			; MASK FOR 1 BIT OF DRIVE SELECT 	
	RRCA				; MOVE BIT 0 TO BIT 7
	OR	L			; OR L WITH ACC TO COMBINE TRACK AND DRIVE
	OUT	(MPCL_RAM),A		; SEND TO RAM PORT MAPPER
	LD	(PAGER),A		; SAVE COPY (JUST BECAUSE)
	RET				;
ROMD:					;
	LD	A,#5			;
	AND	#1			; MASK FOR 1 BIT OF DRIVE SELECT 
	RRCA				; MOVE BIT 0 TO BIT 7
	OR	L			; OR L WITH ACC TO COMBINE TRACK AND DRIVE
	AND	#0x7F			; STRIP OFF BIT 7 (ROM_ENABLE BIT)	
	OUT	(MPCL_ROM),A		; SEND TO ROM PORT MAPPER
	LD	(PAGER),A		; SAVE COPY (JUST BECAUSE)
	LD	(DB_PAGER),A		; SAVE COPY (JUST BECAUSE) (DEBUG)
	RET

;___RPAGE_______________________________________________________________________________________________
;
;	RESET PAGER BACK TO RAM   
;________________________________________________________________________________________________________	
RPAGE:
	LD	A,#0x80			; DESELECT ROM PAGE
	OUT	(MPCL_ROM),A		; SELECT RAM
	LD	A,#0			; SET TO RAM, TRACK 0
	OUT	(MPCL_RAM),A		; SELECT RAM
	LD	(PAGER),A		; SAVE COPY OF PAGER BYTE
	RET

;___COPY_CPM_SECTOR______________________________________________________________________________________
;
; 	COPIES ONE CPM SECTOR FROM ONE MEMORY ADDRESS TO ANOTHER
;	INPUT
;  	 DE SOURCE ADDRESS
;	 HL TARGET ADDRESS
; 	USES C REGISTER
;________________________________________________________________________________________________________	
COPY_CPM_SECTOR:
	LD	BC,#128			; BC IS COUNTER FOR FIXED SIZE TRANSFER (128 BYTES)
	LDIR				; TRANSFER
	RET

;___CONVERT_IDE_SECTOR_CPM________________________________________________________________________________
;
; COMPUTES WHERE THE CP/M SECTOR IS IN THE LBA PARTITION
; LBA HD SECTORS ARE 512 BYTES EACH, CP/M SECTORS ARE 128 BYTES EACH
; MAXIMUM SIZE OF CP/M DISK IS 8 MB = 65536 (16 BITS) X 128 BYTES PER SECTOR
; LBA HD PARTITION CAN HAVE AT MOST 16777215 IDE SECTORS -> 67108860 CP/M SECTORS
; EACH IDE HD SECTOR CONTAINS 4 ADJACENT CP/M SECTORS
; 
; 
; INPUT:
;  - CP/M TRACK AND SECTOR 16 BIT WORDS
; 
; OUTPUT:
; IDE TARGET SECTOR (SENT TO IDE HD CONTROLLER FOR READ OPERATION)
;  - LOWER 16 BITS STORED IN LBA_TARGET_LO
;  - UPPER 16 BITS STORED IN LBA_TARGET_HI
; CP/M TO IDE HD SECTOR MAPPING PARAMETER STORED IN SECTOR_INDEX
;  - 8 BIT VALUE WITH 4 LEGAL STATES (00, 01, 02, 04) WHICH IS
;    TO BE USED TO COMPUTE STARTING ADDRESS OF 128 BYTE CP/M SECTOR ONCE
;    512 BYTE IDE HD SECTOR READ INTO MEMORY BUFFER
; LBA ADDRESS FORMAT = 00TTTTSS
;
; ROTATE WITH CARRY 16 BIT TRACK,SECTOR VALUE IN HL TO GET 14 BIT IDE HD
; TARGET SECTOR IN PARTITION
; KEEP LAST TWO BITS IN B FOR IDE HD SECTOR TO CP/M SECTOR TRANSLATION
; COMPUTE SECTOR_INDEX 
;________________________________________________________________________________________________________	
CONVERT_IDE_SECTOR_CPM:

	LD	A,(TRACK)		; LOAD TRACK # (LOW BYTE)
	LD	H,A			; 
	LD	A,(SECTOR)		; LOAD SECTOR# (LOW BYTE)
	LD	L,A			;	
	CALL	RRA16			; ROTATE 'HL' RIGHT (DIVIDE BY 2)
	CALL	RRA16			; ROTATE 'HL' RIGHT (DIVIDE BY 2)
	LD	A,(TRACK+1)		; GET HIGH BYTE OF TRACK INTO A
	SLA	A			;
	SLA	A			;
	SLA	A			;
	SLA	A			;
	SLA	A			;
	SLA	A			;
	OR	H			;
	LD	H,A			;
	LD	A,(TRACK+1)		; GET HIGH BYTE OF TRACK INTO A
	SRL	A			;
	SRL	A			;
	LD	(LBA_TARGET_HI),A	;
	LD	A,L			;
	LD	(LBA_TARGET_LO),A	; LBA REGISTER IS 00TTTTSS / 4
	LD	A,H			;
	LD	(LBA_TARGET_LO+1),A 	;
	LD	A,#0			;
	LD	(LBA_TARGET_HI+1),A	;
					;
	LD	HL,(LBA_TARGET_LO)	; STORE PHYSICAL SECTOR 
	LD	(PSECTOR),HL		;			
	LD	HL,(LBA_TARGET_HI)	; STORE PHYSICAL TRACK 
	LD	(PTRACK),HL		;			
	LD	A,(SECTOR)		; LOAD SECTOR # 
	AND	#0b000000011		; 
	LD	(SECTOR_INDEX),A	; LOCATES WHERE THE 128 BYTE CP/M SECTOR
					; IS WITHIN THE 512 BYTE IDE HD SECTOR
					; COMPUTE WHICH IDE HD SECTOR TO READ TO WITHIN 4 CP/M SECTORS 
					; SHIFTS 16 BIT PARTITION OFFSET TO THE RIGHT 2 BITS AND ADDS RESULT TO
					; IDE HD PARTITION STARTING SECTOR	
					; SHIFT PARTITION OFFSET RIGHT 1 BIT
	RET
RRA16:
	SCF				;
	CCF				; CLEAR CARRY FLAG
	LD	A,H			; 16 BIT ROTATE HL WITH CARRY
	RRA				;
	LD	H,A			; ROTATE HL RIGHT 1 BIT (DIVIDE BY 2)
	LD	A,L			;
	RRA				;
	LD	L,A			;	
	RET


;___IDE_READ_SECTOR______________________________________________________________________________________
;
;	READ IDE SECTOR
;________________________________________________________________________________________________________		
IDE_READ_SECTOR:
	CALL	ISCUR			; IS CURRENT SECTOR IN BUFFER?	
	JP	Z,IDE_READ_SECTOR_OK	;
	CALL	IDE_WAIT_BUSY_READY 	; MAKE SURE DRIVE IS READY TO PROCEED
	RET	NC			; ERROR, RETURN
	CALL	IDE_SETUP_LBA		; TELL DRIVE WHAT SECTOR IS REQUIRED
	LD	A,#0x20			;
	OUT	(IDESTTS),A		; 020h = IDE 'READ SECTOR' COMMAND 
IDE_SREX:				;
	CALL	IDE_WAIT_BUSY_READY	; MAKE SURE DRIVE IS READY TO PROCEED
	RET	NC			; ERROR, RETURN
	CALL	IDE_TEST_ERROR		; ENSURE NO ERROR WAS REPORTED
	RET	NC			; ERROR, RETURN
	CALL	IDE_WAIT_BUFFER		; WAIT FOR FULL BUFFER SIGNAL FROM DRIVE
	RET	NC			; ERROR, RETURN
	CALL	IDE_READ_BUFFER		; GRAB THE 256 WORDS FROM THE BUFFER
	SCF				; CARRY = 1 ON RETURN = OPERATION OK
IDE_READ_SECTOR_OK:			;
	LD	HL,(PSECTOR)		; STORE PHYSICAL SECTOR IN BUFFER
	LD	(CUSECTOR),HL		; 
	LD	HL,(PTRACK)		; STORE PHYSICAL DISK TRACK IN BUFFER
	LD	(CUTRACK),HL		; 
	LD	A,(DISKNO)		; STORE CURRENT DRIVE IN BUFFER
	LD	(CUDISK),A		;
	SCF				; CARRY = 1 ON RETURN = OPERATION OK
	RET
	
;___IDE_WRITE_SECTOR_____________________________________________________________________________________
;
;	WRITE IDE SECTOR
;________________________________________________________________________________________________________		
IDE_WRITE_SECTOR:
	CALL	IDE_WAIT_BUSY_READY 	; MAKE SURE DRIVE IS READY TO PROCEED
	RET	NC			; ERROR, RETURN
	CALL	IDE_SETUP_LBA		; TELL DRIVE WHAT SECTOR IS REQUIRED
	LD	A,#0x30			;
	OUT	(IDESTTS),A		; 030h = IDE 'WRITE SECTOR' COMMAND 
	CALL	IDE_WAIT_BUSY_READY	;
	RET	NC			; ERROR, RETURN
	CALL	IDE_TEST_ERROR		; ENSURE NO ERROR WAS REPORTED
	RET	NC			; ERROR, RETURN
	CALL	IDE_WAIT_BUFFER		; WAIT FOR BUFFER READY SIGNAL FROM DRIVE
	RET	NC			; ERROR, RETURN
	CALL	IDE_WRITE_BUFFER 	; SEND 256 WORDS TO DRIVE'S BUFFER
	CALL	IDE_WAIT_BUSY_READY 	; MAKE SURE DRIVE IS READY TO PROCEED
	RET	NC			; ERROR, RETURN
	CALL	IDE_TEST_ERROR		; ENSURE NO ERROR WAS REPORTED
	RET	NC			; ERROR, RETURN
	SCF				; CARRY = 1 ON RETURN = OPERATION OK
	RET	

;___IDE_SOFT_RESET_______________________________________________________________________________________
;
;	RESET IDE CHANNEL
;________________________________________________________________________________________________________		
IDE_SOFT_RESET:
 .IF 	CONDIDESOFT			;
	LD	A,#0b000000110		; NO INTERRUPTS, RESET DRIVE = 1
	OUT	(IDECTRL),A		;
	LD	A,#0b000000010		; NO INTERRUPTS, RESET DRIVE = 0
	OUT	(IDECTRL),A		;
	CALL	IDE_WAIT_BUSY_READY	;THIS TAKES A COUPLE OF SECONDS
	RET	
 .ELSE
	; SKIP THIS IF NO IDE DRIVE WHICH SPEEDS UP REBOOTS AND STARTUPS
	RET
 .ENDIF

;___ATAPI_WAIT_BUSY_READY________________________________________________________________________________
;
;	WAIT FOR ATAPI CHANNEL TO BE READY
;________________________________________________________________________________________________________		
ATAPI_WAIT_BUSY_READY:
	LD	DE,#0			; CLEAR OUT DE
ATAPI_WBSY:				;
	LD	B,#0x0F0			; SETUP TIMEOUT
ATAPI_DLP:				;
	DJNZ	ATAPI_DLP		; 
	INC	DE			;
	LD	A,D			;
	OR	E			;
	JR	Z,ATAPI_TO		;
	IN	A,(IDESTTS)		; READ ERROR REG
	AND	#0b010000000		; MASK OFF BUSY BIT
	JR	NZ,ATAPI_WBSY		; WE WANT BUSY(7) TO BE 0 
	SCF				; CARRY 1 = OK
	RET				;
ATAPI_TO:				;
	XOR	A			; CARRY 0 = TIMED OUT
	RET				;
	
;___IDE_WAIT_DRQ_READY___________________________________________________________________________________
;
;	WAIT FOR IDE CHANNEL TO BE READY
;________________________________________________________________________________________________________		
IDE_WAIT_DRQ_READY:
	IN	A,(IDESTTS)		; READ ERROR REG
	AND	#0b000001000		; MASK OFF RDY BIT
	JR	Z,IDE_WAIT_DRQ_READY	; WE WANT DRQ(3) TO BE 1
	RET

;___IDE_WAIT_DRQ_ZERO____________________________________________________________________________________
;
;	WAIT FOR IDE DRQ TO BE ZERO
;________________________________________________________________________________________________________		
IDE_WAIT_DRQ_ZERO:
	IN	A,(IDESTTS)		; READ ERROR REG
	AND	#0b000001000		; MASK OFF RDY BIT
	JR	NZ,IDE_WAIT_DRQ_ZERO	; WE WANT DRQ(3) TO BE 0
	RET

;___IDE_WAIT_BUSY_READY___________________________________________________________________________________
;
;	WAIT FOR IDE CHANNEL TO BE READY
;________________________________________________________________________________________________________		
IDE_WAIT_BUSY_READY:
	LD	DE,#0			; CLEAR DE
IDE_WBSY:				;
	LD	B,#5			; SETUP TIMEOUT
IDE_DLP:				;
	DEC	B			;
	JP	NZ,IDE_DLP		;
	INC	DE			;
	LD	A,D			;
	OR	E			;
	JP	Z,IDE_TO		;
	IN	A,(IDESTTS)		; READ ERROR REG
	AND	#0b011000000		; MASK OFF BUSY AND RDY BITS
	XOR	#0b001000000		; WE WANT BUSY(7) TO BE 0 AND RDY(6) TO BE 1
	JP	NZ,IDE_WBSY		;
	SCF				; CARRY 1 = OK
	RET
IDE_TO:
	XOR	A			; CARRY 0 = TIMED OUT
	RET
	
;___IDE_TEST_ERROR_______________________________________________________________________________________
;
;	CHECK FOR IDE ERROR CONDITION
;________________________________________________________________________________________________________		
IDE_TEST_ERROR:
	SCF				;
	IN	A,(IDESTTS)		;
	LD	B,A			; 
	AND	#0b000000001		; TEST ERROR BIT
	SCF				; 
	RET	Z			;
	LD	A,B			; 
	AND	#0b000100000		;
	SCF				;
	JP	NZ,IDE_ERR		; TEST WRITE ERROR BIT
	IN	A,(IDEERR)		; READ ERROR FLAGS
IDE_ERR:
	OR	A			; CARRY 0 = ERROR
	RET				; IF A = 0, IDE BUSY TIMED OUT

;___IDE_WAIT_BUFFER_______________________________________________________________________________________
;
;	WAIT FOR DATA BUFFER READY
;________________________________________________________________________________________________________		
IDE_WAIT_BUFFER:
	LD	DE,#0			;
IDE_WDRQ:				;
	LD	B,#5			;
IDE_BLP:				;
	DEC	B			;
	JP	NZ,IDE_BLP		;	
	INC	DE			;
	LD	A,D			;
	OR	E			;
	JP	Z,IDE_TO2		;
	IN	A,(IDESTTS)		; WAIT FOR DRIVE'S 512 BYTE READ BUFFER 
	AND	#0b000001000		; TO FILL (OR READY TO FILL)
	JP	Z,IDE_WDRQ		;
	SCF				; CARRY 1 = OK
	RET				;
IDE_TO2:				;
	XOR	A			; CARRY 0 = TIMED OUT
	RET				;

;___IDE_READ_BUFFER_______________________________________________________________________________________
;
;	READ IDE BUFFER
;________________________________________________________________________________________________________		
IDE_READ_BUFFER:
	PUSH	HL			;
	LD	HL,#SECTOR_BUFFER	;
	LD	B,#0			; 256 WORDS (512 BYTES PER SECTOR)
IDEBUFRD:				;
	IN	A,(IDELO)		; LOW BYTE OF WORD FIRST	
	LD	(HL),A			;
	IN	A,(IDEHI)		; THEN HIGH BYTE OF WORD
	INC	HL			;
	LD	(HL),A			;
	INC	HL			;
	DEC	B			;
	JP	NZ,IDEBUFRD		;
	POP	HL			;
	RET

;___IDE_WRITE_BUFFER_______________________________________________________________________________________
;
;	WRITE TO IDE BUFFER
;________________________________________________________________________________________________________		
IDE_WRITE_BUFFER:
	PUSH	HL			;
	LD	HL,#SECTOR_BUFFER	;
	LD	B,#0			; 256 WORDS (512 BYTES PER SECTOR)
IDEBUFWT:			
	INC	HL			;
	LD	A,(HL)			;
	DEC	HL			;
	OUT	(IDEHI),A		; SET UP HIGH LATCHED BYTE BEFORE
	LD	A,(HL)			;
	OUT	(IDELO),A		; WRITING WORD WITH WRITE TO LOW BYTE
	INC	HL			;
	INC	HL			;
	DEC	B			;
	JP	NZ,IDEBUFWT		;
	POP	HL			;
	RET	
	
;___IDE_SETUP_LDA________________________________________________________________________________________
;
;	SETUP IDE DRIVE FOR LDA OPERATION
;________________________________________________________________________________________________________		
IDE_SETUP_LBA:
	LD	A,(LBA_TARGET_LO)	; LOAD LBA REGISTER 0 WITH SECTOR ADDRESS TO READ
	LD	(IDE_LBA0),A		;
	LD	A,(LBA_TARGET_LO+1)	; LOAD LBA REGISTER 1 WITH SECTOR ADDRESS TO READ
	LD	(IDE_LBA1),A		;
	LD	A,(LBA_TARGET_HI) 	; LOAD LBA REGISTER 2 WITH SECTOR ADDRESS TO READ
	LD	(IDE_LBA2),A		;
	LD	A,(LBA_TARGET_HI+1)	; LOAD LBA REGISTER 3 WITH SECTOR ADDRESS TO READ
	AND	#0b000001111		; ONLY LOWER FOUR BITS ARE VALID
	ADD	A,#0b011100000		; ENABLE LBA BITS 5:7=111 IN IDE_LBA3
	LD	(IDE_LBA3),A		;
					; READ IDE HD SECTOR
	LD	A,#1			;
	OUT	(IDESECTC),A		; SET SECTOR COUNT = 1	
					;	
	LD	A,(IDE_LBA0)		;
	OUT	(IDESECTN),A		; SET LBA 0:7
					;
	LD	A,(IDE_LBA1)		;
	OUT	(IDECYLLO),A		; SET LBA 8:15
					;
	LD	A,(IDE_LBA2)		;
	OUT	(IDECYLHI),A		; SET LBA 16:23
					;
	LD	A,(IDE_LBA3)		;
	AND	#0b000001111		; LOWEST 4 BITS USED ONLY
	OR	#0b011100000		; TO ENABLE LBA MODE
	OUT	(IDEHEAD),A		; SET LBA 24:27 + BITS 5:7=111
 .IF CONDUSEDSKY		
	CALL	IDESEGDISPLAY		;
 .ENDIF	
	RET	

;___ATAPI_SOFT_RESET_____________________________________________________________________________________
;
;	RESET ATAPI BUS
;________________________________________________________________________________________________________		
ATAPI_SOFT_RESET:
	LD	A,#0b000001110		;NO INTERRUPTS, RESET DRIVE = 1
	OUT	(IDECTRL),A		;
	CALL	DELAY24			;
	LD	A,#0b000001010		;NO INTERRUPTS, RESET DRIVE = 0
	OUT	(IDECTRL),A		;
	CALL	ATAPI_WAIT_BUSY_READY	;
	RET	NC			; ERROR, RETURN
	CALL	ATAPI_DEVICE_SELECTION	;
	CALL	DELAY24			;
	CALL 	REQUEST_SENSE_LOOP	;
	RET
	
;___REQUEST_SENSE_LOOP____________________________________________________________________________________
;
;	ATAPI_REQUEST SENSE DATA
;_________________________________________________________________________________________________________		
REQUEST_SENSE_LOOP:
	LD	HL,#ATAPI_REQUEST_SENSE	;
	CALL	ATAPI_SEND_PACKET	;
	CALL	ATAPI_WAIT_BUSY_READY	; MAKE SURE DRIVE IS READY TO PROCEED
	RET	NC			; ERROR, RETURN
	LD	B,#0			; 256 WORDS (512 BYTES PER SECTOR)
REQUEST_SENSE_LOOP1:			;
	IN	A,(IDELO)		;
	INC	IX			;
	IN	A,(IDEHI)		;
	INC	IX			;
	DJNZ	REQUEST_SENSE_LOOP1	;
	RRD				; DELAY ONLY
	IN	A,(IDESTTS)		;READ ERROR REG
	AND	#0b000000001		;MASK OFF BIT
	JR	NZ,REQUEST_SENSE_LOOP	;
	RET

;___ATAPI_DEVICE_SELECTION________________________________________________________________________________
;
;	ATAPI DEVICE SELECTION
;_________________________________________________________________________________________________________		
ATAPI_DEVICE_SELECTION:

	LD	A,(IDEDEVICE)		; SELECTS DEVICE
	OR	#0x0A0			;
	OUT	(IDEHEAD),A		;	
	RET				;



;__ATAPI_READ_SECTOR_____________________________________________________________________________________________________________ 
;  READ ATAPI SECTOR   
;
;   D E H L = SECTOR (DOUBLE WORD) TO READ 
;________________________________________________________________________________________________________________________________ 
ATAPI_READ_SECTOR:
	CALL	ISCUR			;
	JP	Z,ATAPI_READ_DATA_EXIT	;
	LD	A,(LBA_TARGET_LO)	; LOAD LBA REGISTER 0 WITH SECTOR ADDRESS TO READ
	LD	(READ_DISK_PACKET+5),A	;
	LD	A,(LBA_TARGET_LO+1)	; LOAD LBA REGISTER 1 WITH SECTOR ADDRESS TO READ
	LD	(READ_DISK_PACKET+4),A	;
	LD	A,(LBA_TARGET_HI)	; LOAD LBA REGISTER 2 WITH SECTOR ADDRESS TO READ
	LD	(READ_DISK_PACKET+3),A	;
	LD	A,(LBA_TARGET_HI+1)	; LOAD LBA REGISTER 3 WITH SECTOR ADDRESS TO READ
	LD	(READ_DISK_PACKET+2),A	;
 .IF CONDUSEDSKY		
	CALL	ATAPISEGDISPLAY		;
 .ENDIF	
	CALL	REQUEST_SENSE_LOOP	; GET ATAPI SENSE CODES TO CLEAR ERRORS
	LD	HL,#READ_DISK_PACKET	; SET POINTER TO READ SECTOR PACKET
	CALL	ATAPI_SEND_PACKET	; SEND PACKET COMMAND
	CALL	ATAPI_WAIT_BUSY_READY	; MAKE SURE DRIVE IS READY TO PROCEED
	RET	NC			; ERROR, RETURN
	LD	B,#0			; 256 WORDS (512 BYTES PER SECTOR)
	LD	IX,#SECTOR_BUFFER	;
	IN	A,(IDESTTS)		; READ  REG
	AND	#0b000001000		; MASK OFF BIT
	CP	#8			; IS DATA WAITING?
	JR	NZ,ATAPI_READ_DATA_EXIT	; NO, EXIT
ATAPI_READ_DATA_LOOP:
	IN	A,(IDELO)		;

	LD	(IX),A			; 

	INC	IX			;
	IN	A,(IDEHI)		;

	LD	(IX),A			; 

	INC	IX			;
	DJNZ	ATAPI_READ_DATA_LOOP	;
ATAPI_READ_DATA_EXIT:			;
	LD	HL,(PSECTOR)		; STORE PHYSICAL SECTOR IN BUFFER
	LD	(CUSECTOR),HL		; 
	LD	HL,(PTRACK)		; STORE PHYSICAL DISK TRACK IN BUFFER
	LD	(CUTRACK),HL		; 
	LD	A,(DISKNO)		; STORE CURRENT DRIVE IN BUFFER
	LD	(CUDISK),A		;
	SCF				; CARRY = 1 ON RETURN = OPERATION OK
	RET				;



;__ATAPI_WRITE_SECTOR_____________________________________________________________________________________________________________ 
;  WRITE ATAPI SECTOR   
;
;   D E H L = SECTOR (DOUBLE WORD) TO WRITE 
;________________________________________________________________________________________________________________________________ 
ATAPI_WRITE_SECTOR:

	LD	A,(LBA_TARGET_LO)	; LOAD LBA REGISTER 0 WITH SECTOR ADDRESS TO READ
	LD	(WRITE_DISK_PACKET+5),A	;
	LD	A,(LBA_TARGET_LO+1)	; LOAD LBA REGISTER 1 WITH SECTOR ADDRESS TO READ
	LD	(WRITE_DISK_PACKET+4),A	;
	LD	A,(LBA_TARGET_HI)	; LOAD LBA REGISTER 2 WITH SECTOR ADDRESS TO READ
	LD	(WRITE_DISK_PACKET+3),A	;
	LD	A,(LBA_TARGET_HI+1)	; LOAD LBA REGISTER 3 WITH SECTOR ADDRESS TO READ
	LD	(WRITE_DISK_PACKET+2),A	;
 .IF CONDUSEDSKY		
	CALL	ATAPISEGDISPLAY		;
 .ENDIF	
	CALL 	REQUEST_SENSE_LOOP	;
	LD	HL,#WRITE_DISK_PACKET	; SET POINTER TO WRITE PACKET COMMAND
	CALL	ATAPI_SEND_PACKET	; SEND THE PACKET COMMAND			
	CALL	ATAPI_WAIT_BUSY_READY	; MAKE SURE DRIVE IS READY TO PROCEED
	RET	NC			; ERROR, RETURN
	LD	B,#0			; 256 WORDS (512 BYTES PER SECTOR)
	LD	IX,#SECTOR_BUFFER	;
ATAPI_WRITE_DATA_LOOP:
	IN	A,(IDESTTS)		; READ  REG

	LD	A,(IX)			; 

	PUSH    AF			;
	INC	IX			;

	LD	A,(IX)			; 

	OUT	(IDEHI),A		;
	POP	AF			;
	OUT	(IDELO),A		;
	INC	IX			;
	DJNZ	ATAPI_WRITE_DATA_LOOP	;
	SCF				; CARRY = 1 ON RETURN = OPERATION OK
	RET				;




;__ATAPI_SEND_PACKET_____________________________________________________________________________________________________________ 
;  SEND PACKET POINTED TO BY HL TO ATAPI DRIVE   
;
;________________________________________________________________________________________________________________________________ 
ATAPI_SEND_PACKET:

	CALL	ATAPI_WAIT_BUSY_READY	; MAKE SURE DRIVE IS READY TO PROCEED
	RET	NC			; ERROR, RETURN
	CALL	IDE_WAIT_DRQ_ZERO	;
					;
	LD	A,#0x0A			;
	OUT	(IDECTRL),A		; DISABLE INT
	LD	A,#0			;
	OUT	(IDEERR),A		;
	LD	A,#0			;
	OUT	(IDESECTC),A		; 
	LD	A,#0			;
	OUT	(IDESECTN),A		;
	LD	A,#0			;
	OUT	(IDECYLLO),A		; 
	LD	A,#0x60			;
	OUT	(IDECYLHI),A		; 
	LD	A,(IDEDEVICE)		;
	OUT	(IDEHEAD),A		; BIT 4 SELECTS DEVICE
	LD	A,#0x0A0			;
	OUT	(IDESTTS),A		;
					;
	CALL	IDE_WAIT_DRQ_READY	; MAKE SURE DRIVE IS READY TO PROCEED
					;
	LD	B,#6			; SEND 12 BYTES (6 WORDS)
					;
ATAPI_SEND_PACKET_LOOP:
	LD	A,(HL)			; GET BYTE
	LD	D,A			; STORE LOW BYTE IN D
	INC	HL			; INC POINTER
	LD	A,(HL)			; GET HIGH BYTE
	OUT	(IDEHI),A		; STORE HIGH BYTE
	LD	A,D			; MOVE LOW BYTE INTO A
	OUT	(IDELO),A		; STORE LOW BYTE
	INC	HL			; INC POINTER
	IN	A,(IDECTRL)		; GET STATUS
	DJNZ	ATAPI_SEND_PACKET_LOOP	; LOOP
					;
	CALL	ATAPI_WAIT_BUSY_READY	; MAKE SURE DRIVE IS READY TO PROCEED
	RET	NC			; ERROR, RETURN
	IN	A,(IDECTRL)		; READ STATUS (FOR DELAY)
					;
	RET				;
	
;__SETUPDRIVE__________________________________________________________________________________________________________________________ 
;
;	SETUP FLOPPY DRIVE SETTINGS 
;________________________________________________________________________________________________________________________________
;
SETUPDRIVE:
	LD	A,#RESETL		; RESET SETTINGS
.IF COND144FLOPPY-1
	OR	MINI			; SELECT MINI FLOPPY (LOW DENS=1, HIGH DENS=0)
.ENDIF
	OR	#PRECOMP			; SELECT PRECOMP 
	OR	#FDDENSITY		; SELECT DENSITY
	OR	#FDREADY			; SELECT READY SIGNAL
	LD	(FLATCH_STORE),A	; SAVE SETTINGS
	LD	A,#1			;
	LD	(UNIT),A		; SET UNIT 1
	LD	A,#2			; DENSITY
	LD	(DENS),A		;
	LD	A,#9			;
.IF COND144FLOPPY
	ADD	A,A
.ENDIF
	LD	(EOTSEC),A		; LAST SECTOR OF TRACK		
	LD	A,#0x7F			;
	LD	(SRTHUT),A		; STEP RATE AND HEAD UNLOAD TIME
	LD	A,#5			;
	LD	(HLT),A			; HEAD LOAD TIME
	LD	A,#0x0D			;
	LD	(GAP),A			; GAP 
;;	LD	A,#0x80			;
;;	LD	(SECSIZ),A		; SECTOR SIZE /4
					;
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
					;			
	LD	HL,#FLATCH_STORE		; POINT TO FLATCH
	RES	1,(HL)			; SET MOTOR ON
	CALL	OUTFLATCH		; OUTPUT TO CONTROLLER
	NOP				;
	NOP				;
	LD	A,#0			; ZERO TRACK
	LD	(PTRACK),A		; STORE TRACK
	CALL	SETTRACK		; DO IT	
	NOP				;
	NOP				;
	LD	HL,#FLATCH_STORE		; POINT TO FLATCH
	SET	1,(HL)			; SET MOTOR OFF
	CALL	OUTFLATCH		; OUTPUT TO CONTROLLER
	RET
;
;__OUTFLATCH__________________________________________________________________________________________________________________________ 
;
;	SEND SETTINGS TO FLOPPY CONTROLLER
;________________________________________________________________________________________________________________________________
;
OUTFLATCH:
	LD	A,(FLATCH_STORE)	; SET A TO SETTINGS
	OUT	(FLATCH),A		; OUTPUT TO CONTROLLER
	RET

;__FLOPPYREAD__________________________________________________________________________________________________________________________ 
;
; 	READ A FLOPPY DISK SECTOR 	
;________________________________________________________________________________________________________________________________
;	
FLOPPYREAD:
 .IF CONDUSEDSKY	
	CALL	SEGDISPLAY		;
 .ENDIF	
	LD	A,#0x46			; BIT 6 SETS MFM, 06H IS READ COMMAND
	LD	(CMD),A			;
	JP	DSKOP			;
;
;__FLOPPYWRITE__________________________________________________________________________________________________________________________ 
;
; 	WRITE A FLOPPY DISK SECTOR 	
;________________________________________________________________________________________________________________________________
;	
FLOPPYWRITE:
 .IF CONDUSEDSKY	
	CALL	SEGDISPLAY		;
 .ENDIF	
	LD	A,#0x45			; BIT 6 SETS MFM, 05H IS WRITE COMMAND
	LD	(CMD),A			;
	JP	DSKOP			;
;
;__DSKOP__________________________________________________________________________________________________________________________ 
;
; 	PERFORM A DISK OPERATION 	
;________________________________________________________________________________________________________________________________
;	
DSKOP:
	LD	HL,#FLATCH_STORE		; POINT TO FLATCH
	SET	1,(HL)			; SET MOTOR OFF
	CALL	OUTFLATCH		; OUTPUT TO CONTROLLER
					;
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	CP	#0x0FF			; DID IT RETURN WITH ERROR CODE?
	JP	Z,DSKEXIT		; IF YES, EXIT WITH ERROR CODE
					;	
	LD	A,(UNIT)		; GET DISK UNIT NUMBER
	AND	#3			; MASK FOR FOUR DRIVES 
	LD	B,A			; PARK IT IN B
	LD	A,(HEAD)		; GET HEAD SELECTION
	AND	#1			; INSURE SINGLE BIT
	RLA				;
	RLA				; MOVE HEAD TO BIT 2 POSITION
	OR	B			; OR HEAD TO UNIT BYTE IN COMMAND BLOCK
	LD	(UNIT),A		; STORE IN UNIT
					;
	LD	HL,#FLATCH_STORE		; POINT TO FLATCH
	RES	1,(HL)			; SET MOTOR ON
	CALL	OUTFLATCH		; OUTPUT TO CONTROLLER	
					;
	LD	A,#3			; SPECIFY COMMAND
	CALL	PFDATA			; PUSH IT
	LD	A,(SRTHUT)		; STEP RATE AND HEAD UNLOAD TIME
	CALL	PFDATA			; PUSH THAT
	LD	A,(HLT)			;
	CALL	PFDATA			; PUSH THAT
					;
	CALL	SETTRACK		; PERFORM SEEK TO TRACK
					;
	JP	NZ,DSKEXIT		; IF ERROR, EXIT
					;
	LD	A,(CMD)			; WHAT COMMAND IS PENDING?
	OR	A			; SET FLAGS
	JP	DOSO4			; NO, MUST BE READ OR WRITE COMMAND
DSKEXIT:	
	LD	HL,#FLATCH_STORE		; POINT TO FLATCH
	SET	1,(HL)			; SET MOTOR OFF
	CALL	OUTFLATCH		; OUTPUT TO CONTROLLER
					;
	OR	#0x0FF			; SET -1 IF ERROR
	RET

RESULT:
	LD	C,#7			; LOAD C WITH NUMBER OF STATUS BYTES
	LD	HL,#ST0			; POINT TO STATS STORAGE
RS3:
	CALL	GFDATA			; GET FIRST BYTE
	LD	(HL),A			; SAVE IT
	INC	HL			; POINTER++
	DEC	C			; CC-1
	JP	NZ,RS3			; LOOP TIL C0
	LD	A,(ST0)			; LOAD STS0
	AND	#0x0F8			; MASK OFF DRIVE #
	LD	B,A			; PARK IT
	LD	A,(ST1)			; LOAD STS1
	OR	B			; ACC OR B ->ACC IF 0 THEN SUCCESS
					;
RSTEXIT:
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	LD	HL,#FLATCH_STORE		; POINT TO FLATCH
	SET	1,(HL)			; SET MOTOR OFF
	CALL	OUTFLATCH		; OUTPUT TO CONTROLLER
					;
 .IF CONDUSEDSKY						
	CALL	SEGDISPLAY		;
 .ENDIF	
	RET				; DONE RETURN TO CALLER 
	
	
DOSO4:
					;
.IF 1					;
INT_LOC =    0x038                   ; IM 1 INTERRUPT CALLS GO HERE
; SET UP FOR I/O AT INTERRUPT LEVEL
        LD      DE,#INT_LOC
        LD      HL,#INT_RD
        LD      BC,#L_INT_RD
	LD	A,(CMD)			;
	AND	#0b000000001		; WRITE IS 1
        JP      Z,IS_READ
        ADD     HL,BC
IS_READ:
        LDIR
.ENDIF

	LD	HL,#SECTOR_BUFFER	; GET BUFFER ADDRESS TO HL
;;	LD	A,(SECSIZ)		; XFERLEN
;;	LD	C,A			; C WILL BE THE NUMBER OF TRANSACTIONS
					; DIVIDED BY 4

        ld      de,(FSECSIZ)            ; GET FULL SECTOR SIZE
        LD      B,E
        LD      C,#FDATA                 ; GET DATA REGISTER I/O ADDRESS

	LD	A,(CMD)			;
	CALL	PFDATA			; PUSH COMMAND TO I8272
	LD	A,(UNIT)		;
	CALL	PFDATA			; 
	LD	A,(PTRACK)		;
	CALL	PFDATA			; 
	LD	A,(HEAD)		;
	CALL	PFDATA			; 
	LD	A,(PSECTOR)		;
	INC	A			;
	CALL	PFDATA			; 
	LD	A,(DENS)		;
	CALL	PFDATA			; WHAT DENSITY
	LD	A,(EOTSEC)		;
	CALL	PFDATA			; ASSUME SC (SECTOR COUNT)  EOT
	LD	A,(GAP)			;
	CALL	PFDATA			; WHAT GAP IS NEEDED
	LD	A,(DTL)			; DTL, IS THE LAST COMMAND BYTE TO I8272
	CALL	PFDATAS			;
;
;
; PERFORM READ / WRITE
;


RDD_POLL:

FDC_RW_P0:
        EI
        HALT
        JP      NZ,FDC_RW_P0           ;10  COUNT THRU 256 BYTES
FDC_RW_P1:
        EI
        HALT
        JP      NZ,FDC_RW_P1           ;10  COUNT THRU 256 BYTES


;  FALL THROUGH WITH INTERRUPTS DISABLED (NOT ENABLED IN INTERRUPT SERVICE)


DSKOPEND:
	LD	HL,#FLATCH_STORE		; POINT TO FLATCH
	SET	0,(HL)			; SET TC
	CALL	OUTFLATCH		; OUTPUT TO CONTROLLER
	NOP				;
	NOP				; 2 MICROSECOND DELAY
	RES	0,(HL)			; RESET TC
	CALL	OUTFLATCH		; OUTPUT TO CONTROLLER
	NOP				;
	NOP				; 2 MICROSECOND DELAY
	NOP				;
	NOP				; 2 MICROSECOND DELAY
	SET	1,(HL)			; TURN OFF MOTOR
	CALL	OUTFLATCH		; OUTPUT TO CONTROLLER
	JP	RESULT			; GET STATUS BYTES <RESULT PHASE>



INT_RD:         INI
                RET
IRTEMP:
L_INT_RD        =    IRTEMP - INT_RD

INT_WR:         OUTI
                RET
IWTEMP:
L_INT_WR        =    IWTEMP - INT_WR



;__SETTRACK__________________________________________________________________________________________________________________________ 
;
; 	SEEK TO A TRACK ON GIVEN UNIT
; 	A: TRACK #
;________________________________________________________________________________________________________________________________
;
SETTRACK:
	LD	A,(FTRACK)		; GET CURRENT HEAD TRACK
	LD	C,A
	LD	A,(PTRACK)		; GET TRACK
	OR	A			; SET FLAGS
	JP	Z,RECAL			; IF 0 PERFORM RECAL INSTEAD OF SEEK
	CP	C			;
	JP	Z,WAINT			; ALREADY THERE, ABORT
	LD	(FTRACK),A		; STORE TRACK
	LD	A,#0x0F			; SEEK COMMAND
	CALL	PFDATA			; PUSH COMMAND
	LD	A,(UNIT)		; SAY WHICH UNIT
	CALL	PFDATA			; SEND THAT
	LD	A,(PTRACK)		; TO WHAT TRACK
	CALL	PFDATA			; SEND THAT TOO
	JP	WAINT			; WAIT FOR INTERRUPT SAYING DONE
RECAL:
	LD	A,#0			;
	LD	(FTRACK),A		; STORE TRACK
	LD	A,#7			; RECAL TO TRACK 0
	CALL	PFDATA			; SEND IT
	LD	A,(UNIT)		; WHICH UNIT
	CALL	PFDATA			; SEND THAT TOO
					;
WAINT:
					;
	CALL	DELAYHSEC		; DELAY TO LET HEADS SETTLE BEFORE READ
					;
					; WAIT HERE FOR INTERRPT SAYING DONE
					; LOOP TIL INTERRUPT
	CALL	CHECKINT		; CHECK INTERRUPT STATUS
					;
	RET
	
;__CYCLEFLOPPY__________________________________________________________________________________________________________________________ 
;
; 	SEEK TO TRACK 0, THEN BACK TO THE SELECTED TRACK    
;	THIS CAN BE USED ON AN ERROR CONDITION TO VERIFY THAT HEAD IS ON SELECTED TRACK
; 	
;________________________________________________________________________________________________________________________________
;
CYCLEFLOPPY:
	PUSH	AF			; STORE	AF
	PUSH	HL			; STORE	HL
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	CALL	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
	LD	HL,#FLATCH_STORE		; POINT TO FLATCH
	RES	1,(HL)			; SET MOTOR ON
	CALL	OUTFLATCH		; OUTPUT TO CONTROLLER
	NOP				;
	NOP				;
	CALL	RECAL			;
	CALL	DELAYHSEC		;
	CALL	DELAYHSEC		;
	CALL	DELAYHSEC		;
	CALL	DELAYHSEC		;
	CALL	RECAL			;
	CALL	DELAYHSEC		;
	CALL	DELAYHSEC		;
	CALL	DELAYHSEC		;
	CALL	DELAYHSEC		;
	CALL	SETTRACK		;
	CALL	DELAYHSEC		;
	CALL	DELAYHSEC		;
	CALL	DELAYHSEC		;
	CALL	DELAYHSEC		;
	POP	HL			;
	POP	AF			; RESTORE AF
	RET	

;__PFDATAS__________________________________________________________________________________________________________________________ 
;
; WRITE A COMMAND OR PARAMETER SEQUENCE
;
; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
;	RQM  DIO
;	0	0	BUSY
;	1	0	WRITE TO DATA REGISTER PERMITTED
;	1	1	BYTE FOR READ BY HOST PENDING
;	0	1	BUSY
;
;________________________________________________________________________________________________________________________________
;
PFDATAS:
	PUSH	AF			; STORE AF
PFDS1:
	IN	A,(FMSR)		; READING OR WRITING IS KEYS TO D7 RQM
	AND	#0x80			; MASK OFF RQM BIT 
	JP	Z,PFDS1			; WAIT FOR RQM TO BE TRUE 
	IN	A,(FMSR)		; READ STATUS
	AND	#0x40			; WAITING FOR INPUT?
	CALL	NZ,ERRORT		; NO, SIGNAL ERROR
	POP	AF			; RESTORE AF
	OUT	(FDATA),A		; OUTPUT A TO CONTROLLER
	RET	
	
;__PFDATA__________________________________________________________________________________________________________________________ 
;
; WRITE A COMMAND OR PARAMETER SEQUENCE
;
; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
;	RQM  DIO
;	0	0	BUSY
;	1	0	WRITE TO DATA REGISTER PERMITTED
;	1	1	BYTE FOR READ BY HOST PENDING
;	0	1	BUSY
;
;________________________________________________________________________________________________________________________________
;
PFDATA:
	PUSH	AF			; STORE AF
PFD1:
	IN	A,(FMSR)		; READING OR WRITING IS KEYS TO D7 RQM
	AND	#0x80			; MASK OFF RQM BIT 
	JP	Z,PFD1			; WAIT FOR RQM TO BE TRUE 
	IN	A,(FMSR)		; READ STATUS
	AND	#0x40			; WAITING FOR INPUT?
	CALL	NZ,ERRORT		; NO, SIGNAL ERROR
	POP	AF			; RESTORE AF
	OUT	(FDATA),A		; OUTPUT A TO CONTROLLER
	JP	DELAY24			; DELAY 24US
	
	
	
;__DELAY24__________________________________________________________________________________________________________________________ 
;
; 	DELAY 24US
;________________________________________________________________________________________________________________________________
;
DELAY24:	
					; JP= 10T	
	PUSH	IX			; 15T
	POP	IX			; 14T
	PUSH	IX			; 15T
	POP	IX			; 14T
DELAY12:
	PUSH	IX			; 15T
	POP	IX			; 14T
	RET				; 10T


;__CHECKINT__________________________________________________________________________________________________________________________ 
;
; CHECK FOR ACTIVE FDC INTERRUPTS BEFORE GIVING I8272 COMMANDS
; POLL RQM FOR WHEN NOT BUSY AND THEN SEND FDC
; SENSE INTERRUPT COMMAND   IF IT RETURNS WITH NON ZERO
; ERROR CODE, PASS BACK TO CALLING ROUTINE FOR HANDLING
;________________________________________________________________________________________________________________________________
;
CHECKINT:
	IN	A,(FMSR)		; READING OR WRITING IS KEYS TO D7 RQM
	AND	#0x80			; MASK OFF RQM BIT
	JP	Z,CHECKINT		; WAIT FOR RQM TO BE TRUE  WAIT UNTIL DONE
	IN	A,(FMSR)		; READ STATUS
	AND	#0x40			; WAITING FOR INPUT?
	JP	NZ,CHECKINTDONE		; NO, SIGNAL ERROR
	CALL	SENDINT			; SENSE INTERRUPT COMMAND
CHECKINTDONE:
	RET				;
	

;__DELAYHSEC__________________________________________________________________________________________________________________________ 
;
; DELAY FOR 1/2 SECOND
;________________________________________________________________________________________________________________________________
;	
DELAYHSEC:
	LD	HL,#0		; 65536
DELDM:
	NOP				; (4 T) 
	NOP				; (4 T)
	NOP				; (4 T)
	NOP				; (4 T)
	DEC	L			; (6 T)
	JP	NZ,DELDM		; (10 T) 24 T  8 MICROSECONDS AT 4 MHZ
	DEC	H			; (6 T)
	JP	NZ,DELDM		; (10 T) (8 US * 256) * 256  524288 US   5 SECONDS
	RET

;__ERRORT__________________________________________________________________________________________________________________________ 
;
; ERROR HANDLING
;________________________________________________________________________________________________________________________________
;		
ERRORT:
	IN	A,(FDATA)		; CLEAR THE JUNK OUT OF DATA REGISTER
	IN	A,(FMSR)		; CHECK WITH RQM
	AND	#0x80			; IF STILL NOT READY, READ OUT MORE JUNK
	JP	Z,ERRORT		;
	LD	A,#0x0FF			; RETURN ERROR CODE -1
					;
	RET

;__SENDINT__________________________________________________________________________________________________________________________ 
;
; SENSE INTERRUPT COMMAND
;________________________________________________________________________________________________________________________________
;		
SENDINT:
	LD	A,#8			; SENSE INTERRUPT COMMAND
	CALL	PFDATA			; SEND IT
	CALL	GFDATA			; GET RESULTS
	LD	(ST0A),A		; STORE THAT
	AND	#0x0C0			; MASK OFF INTERRUPT STATUS BITS
	CP	#0x80			; CHECK IF INVALID COMMAND
	JP	Z,ENDSENDINT		; YES, EXIT
	CALL	GFDATA			; GET ANOTHER (STATUS CODE 1)
	LD	(ST1A),A		; SAVE THAT
	LD	A,(ST0A)		; GET FIRST ONE
	AND	#0x0C0			; MASK OFF ALL BUT INTERRUPT CODE 00 IS NORMAL
ENDSENDINT:
	RET				; ANYTHING ELSE IS AN ERROR


;__GFDATA__________________________________________________________________________________________________________________________ 
;
; GET DATA FROM FLOPPY CONTROLLER
;
; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
;	RQM  DIO
;	0	0	BUSY
;	1	0	WRITE TO DATA REGISTER PERMITTED
;	1	1	BYTE FOR READ BY HOST PENDING
;	0	1	BUSY
;
;________________________________________________________________________________________________________________________________
;	
GFDATA:
	IN	A,(FMSR)		; READ STATUS BYTE
	AND	#0x80			; MASK OFF RQM
	JP	Z,GFDATA		; LOOP WHILE BUSY
	IN	A,(FMSR)		; READ STSTUS BUTE
	AND	#0x40			; MASK OFF DIO
	CALL	Z,ERRORT		; IF WRITE EXPECTED RUN ERRORRT
	IN	A,(FDATA)		; READ DATA
	JP	DELAY24			; DELAY 24US
	

	
 .IF CONDUSEDSKY	
;__IDESEGDISPLAY________________________________________________________________________________________
;
;  DISPLAY CONTENTS OF IDE LOGICAL BLOCK ADDRESS ON DSKY    
;____________________________________________________________________________________________________
IDESEGDISPLAY:
	LD	A, #0x82			;
	OUT (PIOCONT),A			;
					;
	LD	A,(IDE_LBA3)		;
	AND	#0x0F			;
	LD	(DISPLAYBUF+6),A	;
	LD	A,(IDE_LBA3)		;
	AND	#0x0F0			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	LD	(DISPLAYBUF+7),A	;
					;
	LD	A,(IDE_LBA2)		;
	AND	#0x0F			;
	LD	(DISPLAYBUF+4),A	;
	LD	A,(IDE_LBA2)		;
	AND	#0x0F0			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	LD	(DISPLAYBUF+5),A	;
					;
	LD	A,(IDE_LBA1)		;
	AND	#0x0F			;
	LD	(DISPLAYBUF+2),A	;
	LD	A,(IDE_LBA1)		;
	AND	#0x0F0			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	LD	(DISPLAYBUF+3),A	;
	
	LD	A,(IDE_LBA0)		;
	AND	#0x0F			;
	LD	(DISPLAYBUF),A		;
	LD	A,(IDE_LBA0)		;
	AND	#0x0F0			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	LD	(DISPLAYBUF+1),A	;
	JP	SEGDISPLAY1		;

;__ATAPISEGDISPLAY________________________________________________________________________________________
;
;  DISPLAY CONTENTS OF ATAPI LOGICAL BLOCK ADDRESS ON DSKY    
;____________________________________________________________________________________________________
ATAPISEGDISPLAY:
	LD  A, #0x82		;
	OUT (PIOCONT),A			;
					;
	LD	A,(LBA_TARGET_HI+1)	;
	AND	#0x0F			;
	LD	(DISPLAYBUF+6),A	;
	LD	A,(LBA_TARGET_HI+1)	;
	AND	#0x0F0			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	LD	(DISPLAYBUF+7),A	;
					;
	LD	A,(LBA_TARGET_HI)	;
	AND	#0x0F			;
	LD	(DISPLAYBUF+4),A	;
	LD	A,(LBA_TARGET_HI)	;
	AND	#0x0F0			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	LD	(DISPLAYBUF+5),A	;
					;
	LD	A,(LBA_TARGET_LO+1)	;
	AND	#0x0F			;
	LD	(DISPLAYBUF+2),A	;
	LD	A,(LBA_TARGET_LO+1)	;
	AND	#0x0F0			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	LD	(DISPLAYBUF+3),A	;
					;
	LD	A,(LBA_TARGET_LO)	;
	AND	#0x0F			;
	LD	(DISPLAYBUF),A		;
	LD	A,(LBA_TARGET_LO)	;
	AND	#0x0F0			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	LD	(DISPLAYBUF+1),A	;
	JP	SEGDISPLAY1		;

;__SEGDISPLAY________________________________________________________________________________________
;
;  DISPLAY CONTENTS OF TRACK, SECTOR, ST0, ST1 ON DSKY
;     
;____________________________________________________________________________________________________
SEGDISPLAY:
	LD	A, #0x82			;
	OUT (PIOCONT),A			;
	LD	A,(TRACK)		;
	AND	#0x0F			;
	LD	(DISPLAYBUF+6),A	;
	LD	A,(TRACK)		;
	AND	#0x0F0			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	LD	(DISPLAYBUF+7),A	;		
	LD	A,(SECTOR)		;
	AND	#0x0F			;
	LD	(DISPLAYBUF+4),A	;
	LD	A,(SECTOR)		;
	AND	#0x0F0			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	LD	(DISPLAYBUF+5),A	;
	LD	A,(ST0)			;
	AND	#0x0F			;
	LD	(DISPLAYBUF+2),A	;
	LD	A,(ST0)			;
	AND	#0x0F0			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	LD	(DISPLAYBUF+3),A	;		
	LD	A,(ST1)			;
	AND	#0x0F			;
	LD	(DISPLAYBUF),A		;
	LD	A,(ST1)			;
	AND	#0x0F0			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	SRL	A			;
	LD	(DISPLAYBUF+1),A	;
SEGDISPLAY1:				;
	LD	HL,#DISPLAYBUF		;
	LD	BC,#7 			;
	ADD	HL,BC			;
	LD	B,#8			; SET DIGIT COUNT
	LD	A,#0x40			; SET CONTROL PORT 7218 TO OFF
	OUT	(PORTC),A		; OUTPUT
	CALL 	DELAY12			; WAIT
	LD	A,#0x0D0			; SET CONTROL TO 1111 (DATA COMING, HEX DECODE, DECODE, NORMAL)
	OUT	(PORTA),A		; OUTPUT TO PORT
	LD	A,#0x80			; STROBE WRITE PULSE WITH CONTROL=1
	OUT	(PORTC),A		; OUTPUT TO PORT
	CALL 	DELAY12			; WAIT
	LD	A,#0x40			; SET CONTROL PORT 7218 TO OFF
	OUT	(PORTC),A		; OUTPUT
	CALL 	DELAY12			; WAIT
SEGDISPLAY_LP:	
	LD	A,(HL)			; GET DISPLAY DIGIT
	OUT	(PORTA),A		; OUT TO PORTA
	LD	A,#0			; SET WRITE STROBE
	OUT	(PORTC),A		; OUT TO PORTC
	CALL	DELAY12			; DELAY
	LD	A,#0x40			; SET CONTROL PORT OFF
	OUT	(PORTC),A		; OUT TO PORTC
	CALL	DELAY12			; WAIT
	DEC	HL			; INC POINTER
	DJNZ	SEGDISPLAY_LP		; LOOP FOR NEXT DIGIT
	RET	
	
DISPLAYBUF:	.DB 	01,02,03,04,05,06,07,08
 .ENDIF
		.DB	00,00,00,00,00,00,00,00	
		.DB	00,00,00,00,00,00,00,00	
		.DB	00,00,00,00,00,00,00,00	
		.DB	00,00,00,00,00,00,00,00	

 
 		
FLOPPYSTACK:	.DB	00
PARKSTACK:	.DB	00,00,00,00
	
READ_DISK_PACKET:
		.DB	0x0A8,00,00,00,00,01,00,00,00,01,00,00
WRITE_DISK_PACKET:
		.DB	0x2A,00,00,00,00,0x11,00,00,01,00,00,00
ATAPI_REQUEST_SENSE:
		.DB	3,00,00,00,0x11,00,00,00,00,00,00,00

;	******* TEXT STRINGS *******

TXT_RO_ERROR:
		.DB 	CR,LF
		.ascii 	"ERROR: WRITE TO READ ONLY DISK"
		.DB 	END


TXT_STARTUP_MSG:

 .IF 	CONDSHORTMSG
		.DB 	CR,LF
		.ascii 	"CP/M-80 2.2C (JC0705-1) for "
		.ascii 	"N8VEM - W/"
    .IF   CONDUSEVDU
                .ascii     "VDU "
    .ENDIF
    .IF   CONDUSEDSKY
                .ascii     "DSKY "
    .ENDIF
    .IF   CONDIDESOFT
                .ascii     "IDE "
    .ENDIF
    .IF   CONDUSEATAPI
                .ascii    "ATAPI "
    .ENDIF
    .IF   CONDUSEFLOPPY
                .ascii     "FLOPPY "
	.IF  COND144FLOPPY
		.ascii	"1.44M "
	.ENDIF
    .ENDIF
		.DB 	CR,LF
		.DB 	END
 .ELSE
		.ascii 	"CP/M V2.2C"
		.DB 	END
 .ENDIF

;
;	THE REMAINDER OF THE CBIOS IS RESERVED UNINITIALIZED
;	DATA AREA, AND DOES NOT NEED TO BE A PART OF THE
;	SYSTEM MEMORY IMAGE (THE SPACE MUST BE AVAILABLE,
;	HOWEVER, BETWEEN "BEGDAT" AND "ENDDAT") 
;

;
; DISK COMMAND BLOCK
;
CMD:		.DB	0		; COMMAND READ OR WRITE,
UNIT:		.DB	0		; PHYSICAL DRIVE 0->3
HEAD:		.DB	0		; HEAD SEL 0 OR 1
DENS:		.DB	2		; DENSITY
EOTSEC:		.DB	09		; LAST SECTOR OF TRACK
GAP:		.DB	0x1B		; VALUE FOR IRG <GAP3>
;SECSIZ:	.DB	0x80		; HOW MANY BYTES TO TRANSFER/4
FSECSIZ:        .dw     0x0200          ; actual sector size in bytes
DTL:		.DB	0x0FF		; SIZE OF SECTOR
SRTHUT:		.DB	0x7F		; STEP RATE AND HEAD UNLOAD TIME
HLT:		.DB	5		; HEAD LOAD TIME
MIN:		.DB	MINI		; LATCH BIT PATTERN FOR FDC9229 MINITRUE
PRE:		.DB	PRECOMP		; LATCH BIT PATTERN FOR FDC9229 PRECOMP125NS
;
; FLOPPY STATUS RESULT STORAGE
;
ST0:		.DB	0		; STORE STATUS 0
ST1:		.DB	0		; ST1
ST2:		.DB	0		; ST2
SCYL:		.DB	0		; TRACK
SHEAD:		.DB	0		; HEAD 0 OR 1
SREC:		.DB	0		; SECTOR
SNBIT:		.DB	0		; DENSITY
ST0A:		.DB	0		; STORE STATUS 0
ST1A:		.DB	0		; ST1
RETRY:		.DB	0		; RETRIES
RETRY1:		.DB	0		; RETRIES

FLATCH_STORE:	.DB	00		;
	
TRACK:		.DW 	0		; TWO BYTES FOR TRACK # (LOGICAL)
PTRACK:		.DW 	0		; TWO BYTES FOR TRACK # (PHYSICAL)
FTRACK:		.DW 	0		; TWO BYTES FOR TRACK # (HEAD LOCATION)

PAGER:		.DB 	1		; COPY OF PAGER BYTE
DB_PAGER:	.DB 	0x0FF		; COPY OF PAGER BYTE (DEBUG)
SECTOR:		.DW 	0		; TWO BYTES FOR SECTOR # (LOGICAL)
PSECTOR: 	.DW 	0		; TWO BYTES FOR SECTOR # (PHYSICAL)
SECST:		.DW 	0		; SECTOR IN ROM/RAM START ADDRESS
DMAAD:		.DW 	0		; DIRECT MEMORY ADDRESS
DISKNO:		.DB 	0		; DISK NUMBER 0-15
LBA_TARGET_LO: 	.DW 	0		; IDE HD PARTITION TARGET SECTOR (LOW 16 BITS)
LBA_TARGET_HI:	.DW 	0		; IDE HD PARTITION TARGET SECTOR (HI 16 BITS, 12 USED)
IDEDEVICE:	.DB 	0		; ATAPI DEVICE SELECTION FLAG

IDE_LBA0:	.DB 	0		; SET LBA 0:7
IDE_LBA1:	.DB 	0		; SET LBA 8:15
IDE_LBA2:	.DB 	0		; SET LBA 16:23
IDE_LBA3:	.DB 	0		; LOWEST 4 BITS USED ONLY TO ENABLE LBA MODE 
SECTOR_INDEX:	.DB 	1		; WHERE 128 BYTE CP/M SECTOR IS IN 512 BYTE IDE HD SECTOR
;
;	SCRATCH RAM AREA FOR BDOS USE
BEGDAT:
;		= 	$		; BEGINNING OF DATA AREA
DIRBF:		.DS 	128		; SCRATCH DIRECTORY AREA
ALL00:		.DS 	65		; ALLOCATION VECTOR 0  (DSM/8 = 1 BIT PER BLOCK)  44
ALL01:		.DS 	33		; ALLOCATION VECTOR 1 (225/8)
ALL02:		.DS 	256		; ALLOCATION VECTOR 2 (511/8)
ALL03:		.DS 	256		; ALLOCATION VECTOR 3 (511/8)
ALL04:		.DS 	65		; ALLOCATION VECTOR 4 (497/8)
ALL05:		.DS 	65		; ALLOCATION VECTOR 4 (495/8)
ALL06:		.DS 	65		; ALLOCATION VECTOR 4 (495/8)
ALL07:		.DS 	135		; ALLOCATION VECTOR 7 (495/8)
CHK00:		.DS 	5		; 720K MEDIA
CHK01:		.DS 	0		; NOT USED FOR FIXED MEDIA
CHK02:		.DS 	0		; NOT USED FOR FIXED MEDIA
CHK03:		.DS 	128		; 8M MEDIA
CHK04:		.DS 	0		; NOT USED FOR FIXED MEDIA
CHK05:		.DS 	0		; NOT USED FOR FIXED MEDIA
CHK06:		.DS 	0		; NOT USED FOR FIXED MEDIA
CHK07:		.DS 	15		; 1.44M MEDIA 
;
CUDISK:		.DS 	1		; CURRENT PHYSICAL DISK ID IN BUFFER
CUSECTOR:	.DW 	1		; CURRENT PHYSICAL DISK SECTOR IN BUFFER	
CUTRACK:	.DW 	2		; CURRENT PHYSICAL DISK TRACK IN BUFFER	
SECTOR_BUFFER:  .DS 	520		; STORAGE FOR 512 BYTE IDE HD SECTOR
ENDDAT:
;	 	.EQU 	$		; END OF DATA AREA
DSTEMP:
DATSIZ	 	=  	DSTEMP - BEGDAT	; SIZE OF DATA AREA


;dwg;	 	.ORG 	0FDFFH
LASTBYTE:	.DB 	0

; .END
	

	


_cbios_end::
	.area _CODE
	.area _CABS
