;
;==================================================================================================
;   LOADER
;==================================================================================================
;
; BOOT LOADER
;   CAN BE COMPILED IN DIFFERENT MODES:
;     - LOAD FROM ROM
;     - LOAD FROM IMAGE IN RAM
;     - LOAD FROM COM APPLICATION
;
#INCLUDE "std.asm"
#INCLUDE "hbios.exp"
;
LM_ROM	.EQU	1	; LOAD FROM ROM PAGE
LM_IMG	.EQU	2	; LOAD FROM IMAGE
LM_COM	.EQU	3	; LOAD FROM COM APP
;
LDRMODE	.EQU	MODE	; DEFINE MODE ON COMMAND LINE
;
P2LOC	.EQU	$F000	; PHASE 2 RUN LOCATION
;
#IF (LDRMODE == LM_ROM)
CURBNK	.EQU	BID_BOOT
#ELSE
CURBNK	.EQU	BID_USR
#ENDIF

#IF (LDRMODE == LM_COM)
	.ORG	$100
	JP	START
#ELSE
	.ORG	0
;
;==================================================================================================
; NORMAL PAGE ZERO SETUP, RET/RETI/RETN AS APPROPRIATE
;==================================================================================================
;
	.FILL	(000H - $),0FFH		; RST 0
	JP	START			; JUMP TO BOOT CODE
	.FILL	(004H - $),0FFH		; FILL TO START OF SIG PTR
	.DW	ROM_SIG
	.FILL	(008H - $),0FFH		; RST 8
	RET
	.FILL	(010H - $),0FFH		; RST 10
	RET
	.FILL	(018H - $),0FFH		; RST 18
	RET
	.FILL	(020H - $),0FFH		; RST 20
	RET
	.FILL	(028H - $),0FFH		; RST 28
	RET
	.FILL	(030H - $),0FFH		; RST 30
	RET
	.FILL	(038H - $),0FFH		; INT
	RETI
	.FILL	(066H - $),0FFH		; NMI
	RETN
;
	.FILL	(070H - $),0FFH		; SIG STARTS AT $80
;
ROM_SIG:
	.DB	$76, $B5		; 2 SIGNATURE BYTES
	.DB	1			; STRUCTURE VERSION NUMBER
	.DB	7			; ROM SIZE (IN MULTIPLES OF 4KB, MINUS ONE)
	.DW	NAME			; POINTER TO HUMAN-READABLE ROM NAME
	.DW	AUTH			; POINTER TO AUTHOR INITIALS
	.DW	DESC			; POINTER TO LONGER DESCRIPTION OF ROM
	.DB	0, 0, 0, 0, 0, 0	; RESERVED FOR FUTURE USE; MUST BE ZERO
;
NAME	.DB	"ROMWBW v", BIOSVER, ", ", TIMESTAMP, 0
AUTH	.DB	"WBW",0
DESC	.DB	"ROMWBW v", BIOSVER, ", Copyright 2014, Wayne Warthen, GNU GPL v3", 0
;
	.FILL	($100 - $),$FF		; PAD REMAINDER OF PAGE ZERO
#ENDIF
;
;==================================================================================================
;   HBIOS CONFIGURATION BLOCK
;==================================================================================================
;
		.ORG	$ + P2LOC
CB:
		.DB	'W',~'W'	; MARKER
		.DB	RMJ << 4 | RMN	; FIRST BYTE OF VERSION INFO
		.DB	RUP << 4 | RTP	; SECOND BYTE OF VERSION INFO
;
CB_PLT		.DB	PLATFORM
CB_CPUMHZ	.DB	CPUMHZ
CB_CPUKHZ	.DW	CPUKHZ
CB_RAMBANKS	.DB	RAMSIZE / 32
CB_ROMBANKS	.DB	ROMSIZE / 32
;
CB_BOOTVOL	.DW	0
CB_BOOTBID	.DB	0
CB_SERDEV	.DB	SERDEV
CB_CRTDEV	.DB	CRTDEV
CB_CONDEV	.DB	SERDEV
;
CB_CUREMU	.DB	VDAEMU		; CURRENT VDA TERMINAL EMULATION
CB_CURVDA	.DB	VDADEV		; CURRENT VDA TARGET FOR EMULATION

;
; STANDARD BANK ID'S START AT $D8
;
		.FILL	(CB + $D8 - $),0
;
CB_BIDCOM	.DB	BID_COM
CB_BIDUSR	.DB	BID_USR
CB_BIDBIOS	.DB	BID_BIOS
CB_BIDAUX	.DB	BID_AUX
CB_BIDRAMD0	.DB	BID_RAMD0
CB_BIDRAMDN	.DB	BID_RAMDN
CB_BIDROMD0	.DB	BID_ROMD0
CB_BIDROMDN	.DB	BID_ROMDN

;
; DEVICE LISTS START AT $E0
;
	.FILL	(CB + $E0 - $),0
;
; CHARACTER DEVICE LIST AT $E0 (7 ENTRY MAX)
;
	.DB	CB_CDLEND - CB_CDL	; ENTRY COUNT
;
CB_CDL:					; START OF LIST
;
#IF ASCIENABLE
	.DB	CIODEV_ASCI + 0		; ASCI0:
	.DB	CIODEV_ASCI + 1		; ASCI1:
#ENDIF
;
#IF UARTENABLE
#IF (UARTCNT >= 1)
	.DB	CIODEV_UART + 0		; UART0:
#ENDIF
#IF (UARTCNT >= 2)
	.DB	CIODEV_UART + 1		; UART1:
#ENDIF
#IF (UARTCNT >= 3)
	.DB	CIODEV_UART + 2		; UART2:
#ENDIF
#IF (UARTCNT >= 4)
	.DB	CIODEV_UART + 3		; UART3:
#ENDIF
#ENDIF
;
CB_CDLEND:
	.FILL	(CB_CDL + 7 - $),0	; PAD REMAINDER OF CDL
;
; PRINT DEVICE LIST AT $E8 (3 ENTRY MAX)
;
	.DB	CB_PDLEND - CB_PDL	; ENTRY COUNT
;
CB_PDL:					; START OF LIST
;
CB_PDLEND:
	.FILL	(CB_PDL + 3 - $),0	; PAD REMAINDER OF PDL
;
; VIDEO DISPLAY DEVICE LIST AT $EC (3 ENTRY MAX)
;
	.DB	CB_VDLEND - CB_VDL	; ENTRY COUNT
;
CB_VDL:					; START OF LIST
;
CB_VDLEND:
	.FILL	(CB_VDL + 3 - $),0	; PAD REMAINDER OF VDL
;
; DISK DEVICE LIST AT $F0 (7 ENTRY MAX)
;
	.DB	CB_DDLEND - CB_DDL	; ENTRY COUNT
;
CB_DDL:					; START OF LIST
;
#IF MDENABLE
	.DB	DIODEV_MD + 1		; MD1: (RAM DISK)
	.DB	DIODEV_MD + 0		; MD0: (ROM DISK)
#ENDIF
;
#IF FDENABLE
	.DB	DIODEV_FD + 0		; FD0: (PRIMARY FLOPPY DRIVE)
	.DB	DIODEV_FD + 1		; FD1: (SECONDARY FLOPPY DRIVE)
#ENDIF
;
#IF RFENABLE
#IF (RFCNT >= 1)
	.DB	DIODEV_RF + 0		; RF0: (RAMFLOPPY DISK UNIT 0)
#ENDIF
#IF (RFCNT >= 2)
	.DB	DIODEV_RF + 1		; RF1: (RAMFLOPPY DISK UNIT 1)
#ENDIF
#ENDIF
;
#IF IDEENABLE
#IF (IDECNT >= 1)
	.DB	DIODEV_IDE + 0		; IDE0: (IDE PRIMARY MASTER DISK)
#ENDIF
#IF (IDECNT >= 2)
	.DB	DIODEV_IDE + 1		; IDE1: (IDE PRIMARY SLAVE DISK)
#ENDIF
#IF (IDECNT >= 3)
	.DB	DIODEV_IDE + 2		; IDE2: (IDE SECONDARY MASTER DISK)
#ENDIF
#IF (IDECNT >= 4)
	.DB	DIODEV_IDE + 3		; IDE3: (IDE SECONDARY SLAVE DISK)
#ENDIF
#ENDIF
;
#IF PPIDEENABLE
#IF (PPIDECNT >= 1)
	.DB	DIODEV_PPIDE + 0	; PPIDE0: (PAR PORT IDE PRIMARY MASTER DISK)
#ENDIF
#IF (PPIDECNT >= 2)
	.DB	DIODEV_PPIDE + 1	; PPIDE1: (PAR PORT IDE PRIMARY SLAVE DISK)
#ENDIF
#ENDIF
;
#IF SDENABLE
	.DB	DIODEV_SD + 0		; SD0: (SD CARD DISK)
#ENDIF
;
#IF (PRPENABLE & PRPSDENABLE)
	.DB	DIODEV_PRPSD + 0	; PRPSD0: (PROPIO SD DISK)
#ENDIF
;
#IF (PPPENABLE & PPPSDENABLE)
	.DB	DIODEV_PPPSD + 0	; PPPSD0: (PARPORTPROP SD DISK)
#ENDIF
;
#IF HDSKENABLE
#IF (HDSKCNT >= 1)
	.DB	DIODEV_HDSK + 0		; HDSK0: (SIMH DISK DRIVE 0)
#ENDIF
#IF (HDSKCNT >= 2)
	.DB	DIODEV_HDSK + 1		; HDSK1: (SIMH DISK DRIVE 1)
#ENDIF
#IF (HDSKCNT >= 3)
	.DB	DIODEV_HDSK + 2		; HDSK2: (SIMH DISK DRIVE 2)
#ENDIF
#IF (HDSKCNT >= 4)
	.DB	DIODEV_HDSK + 3		; HDSK3: (SIMH DISK DRIVE 3)
#ENDIF
#ENDIF	
;
CB_DDLEND:
	.FILL	(CB_DDL + 15 - $),0	; PAD REMAINDER OF DDL
;
	.FILL	(CB + HCB_SIZ - $),0	; PAD REMAINDER OF HCB
;
	.ORG	$ - P2LOC
;
;==================================================================================================
;   COLD START
;==================================================================================================
;
START:
	DI			; NO INTERRUPTS
	IM	1		; INTERRUPT MODE 1
	LD	SP,HBX_LOC	; SETUP INITIAL STACK JUST BELOW HBIOS PROXY
;
; HARDWARE BOOTSTRAP FOR Z180
; FOR N8, ACR & RMAP ARE ASSUMED TO BE ALREADY SET OR THIS CODE
; WOULD NOT BE EXECUTING
;
#IF ((PLATFORM == PLT_N8) | (PLATFORM == PLT_MK4))
	; SET BASE FOR CPU IO REGISTERS
   	LD	A,Z180_BASE
	OUT0	(Z180_ICR),A

	; DISABLE REFRESH
	XOR	A
	OUT0	(Z180_RCR),A

	; SET DEFAULT CPU CLOCK MULTIPLIERS (XTAL / 2)
	XOR	A
	OUT0	(Z180_CCR),A
	OUT0	(Z180_CMR),A

	; SET DEFAULT WAIT STATES
	LD	A,$F0
	OUT0	(Z180_DCNTL),A

	; MMU SETUP
	LD	A,$80
	OUT0	(Z180_CBAR),A		; SETUP FOR 32K/32K BANK CONFIG
#IF (LDRMODE == LM_ROM)
	XOR	A
	OUT0	(Z180_BBR),A		; BANK BASE = 0
#ENDIF
	LD	A,(RAMSIZE + RAMBIAS - 64) >> 2
	OUT0	(Z180_CBR),A		; COMMON BASE = LAST (TOP) BANK

#IF (Z180_CLKDIV >= 1)
	; SET CLOCK DIVIDE TO 1 RESULTING IN FULL XTAL SPEED
	LD	A,$80
	OUT0	(Z180_CCR),A
#ENDIF

#IF (Z180_CLKDIV >= 2)
	; SET CPU MULTIPLIER TO 1 RESULTING IN XTAL * 2 SPEED
	LD	A,$80
	OUT0	(Z180_CMR),A
#ENDIF

	; SET DESIRED WAIT STATES
	LD	A,0 + (Z180_MEMWAIT << 6) | (Z180_IOWAIT << 4)
	OUT0	(Z180_DCNTL),A
#ENDIF
;
; HARDWARE BOOTSTRAP FOR ZETA 2
;
#IF (PLATFORM == PLT_ZETA2)
	; SET PAGING REGISTERS
#IF (LDRMODE == LM_ROM)
	XOR	A
	OUT	(MPGSEL_0),A
	INC	A
	OUT	(MPGSEL_1),A
#ENDIF
	LD	A,62
	OUT	(MPGSEL_2),A
	INC	A
	OUT	(MPGSEL_3),A
	; ENABLE PAGING
	LD	A,1
	OUT	(MPGENA),A
#ENDIF

;
; EMIT FIRST SIGN OF LIFE TO SERIAL PORT
;
	CALL	XIO_INIT	; INIT SERIAL PORT
	LD	HL,STR_BOOT	; POINT TO MESSAGE
	CALL	XIO_OUTS	; SAY HELLO
;
; COPY OURSELVES AND LOADER TO HI RAM FOR PHASE 2
;
	LD	HL,0		; COPY FROM START OF ROM IMAGE
	LD	DE,P2LOC	; TO HIMEM RUN LOCATION
	LD	BC,LDR_END	; COPY FULL IMAGE
	LDIR
;
	CALL	XIO_DOT		; MARK PROGRESS
;
	JP	PHASE2		; JUMP TO PHASE 2 BOOT IN UPPER MEMORY
;
STR_BOOT	.DB	"RomWBW$"
;
; IMBED DIRECT SERIAL I/O ROUTINES
;
#INCLUDE "xio.asm"
;
;______________________________________________________________________________________________________________________
;
; THIS IS THE PHASE 2 CODE THAT MUST EXECUTE IN UPPER MEMORY
;
	.ORG	$ + P2LOC	; WE ARE NOW EXECUTING IN UPPER MEMORY
;
PHASE2:
	CALL	XIO_DOT		; MARK PROGRESS
;
; INSTALL HBIOS PROXY IN UPPER MEMORY
;
#IF (LDRMODE == LM_ROM)
	LD	A,BID_BIOSIMG	; HBIOS IMAGE ROM BANK
	CALL	BNKSEL		; SELECT IT
#ENDIF
	LD	HL,HBX_IMG	; HL := SOURCE OF HBIOS PROXY IMAGE
#IF (LDRMODE != LM_ROM)
	LD	BC,LDR_END	; SIZE OF LOADER
	ADD	HL,BC		; OFFSET SOURCE ADDRESS
#ENDIF
	LD	DE,HBX_LOC	; DE := DESTINATION TO INSTALL IT
	LD	BC,HBX_SIZ	; SIZE
	LDIR			; DO THE COPY
	LD	A,CURBNK	; BOOT/SETUP BANK
	LD	(HB_CURBNK),A	; INIT CURRENT BANK
#IF (LDRMODE == LM_ROM)
	CALL	BNKSEL		; SELECT IT
#ENDIF
	CALL	XIO_DOT		; MARK PROGRESS
;
; INSTALL HBIOS CODE BANK
;
#IF (LDRMODE == LM_ROM)
	LD	A,BID_BIOSIMG	; SOURCE BANK
#ELSE
	LD	A,(HB_CURBNK)	; SOURCE BANK
#ENDIF
	LD	(HB_SRCBNK),A	; SET IT
	LD	A,BID_BIOS	; DESTINATION BANK
	LD	(HB_DSTBNK),A	; SET IT
	LD	HL,0		; SOURCE ADDRESS IS ZERO
#IF (LDRMODE != LM_ROM)
	LD	BC,LDR_END	; SIZE OF LOADER
	ADD	HL,BC		; OFFSET SOURCE ADDRESS
#ENDIF
	LD	DE,0		; TARGET ADDRESS IS ZERO
	LD	BC,HB_END	; COPY ALL OF HBIOS IMAGE
	CALL	HB_BNKCPY	; DO IT
	CALL	XIO_DOT		; MARK PROGRESS
	
	;; HACK TO FLUSH THE OUTPUT FIFO
	;XOR	A
	;CALL	XIO_OUTC
	;CALL	XIO_OUTC
	;CALL	XIO_OUTC
	;CALL	XIO_OUTC
;
; INSTALL HCB INTO HBIOS CODE BANK
;
	LD	A,BID_BIOS	; GET BIOS BANK
	LD	(HB_SRCBNK),A	; SET AS SOURCE (IRRELEVANT)
	LD	(HB_DSTBNK),A	; SET AS DEST
	LD	HL,CB		; LOCAL LOADER HCB ADDRESS
	LD	DE,HCB_LOC	; DEST HBIOS HCB ADDRESS
	LD	BC,HCB_SIZ	; ONE PAGE IN LENGTH
	CALL	HB_BNKCPY	; DO IT
	CALL	XIO_DOT		; MARK PROGRESS
;
; INITIALIZE HBIOS
;
	LD	A,BID_BIOS	; HBIOS BANK
	LD	HL,0		; ADDRESS 0 IS HBIOS INIT ENTRY ADDRESS
	CALL	HB_BNKCALL	; DO IT
;
; CHAIN TO OS LOADER
;
#IF (LDRMODE == LM_ROM)
	; PERFORM BANK CALL TO OS IMAGES BANK
	LD	A,BID_OSIMG	; CHAIN TO OS IMAGES BANK
	LD	HL,0		; ENTER AT ADDRESS 0
	CALL	HB_BNKCALL	; GO THERE
	HALT			; WE SHOULD NEVER COME BACK!
#ELSE
	; SLIDE OS IMAGES BLOB DOWN TO $0000
	LD	HL,LDR_END	; SOURCE IS LOADER END
	LD	BC,HB_END	; PLUS HBIOS IMAGE SIZE
	ADD	HL,BC		; FINAL SOURCE ADDRESS
	LD	DE,0		; TARGET ADDRESS IS ZERO
	LD	BC,BNKTOP	; MAX SIZE OF OS IMAGES
	LDIR			; DO IT
	; JUMP TO START
	JP	0		; AND CHAIN
#ENDIF
;
;==================================================================================================
;   MEMORY MANAGER
;==================================================================================================
;
#IF (LDRMODE == LM_ROM)
#INCLUDE "memmgr.asm"
#ENDIF
;
;==================================================================================================
;   CLEAN UP
;==================================================================================================
;
	.ORG	$ - P2LOC	; BACK TO IMAGE-BASED ADDRESSING
LDR_END	.EXPORT	LDR_END		; EXPORT ENDING ADDRESS
	.END
