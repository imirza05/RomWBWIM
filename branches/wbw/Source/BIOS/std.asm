; The purpose of this file is to define generic symbols and to include
; the appropriate std-*.inc file to bring in platform specifics.

; There are several classes of systems supported by SBC.
; 1. SBC 	Z80 SBC (v1 or v2) w/ ECB interface
; 2. ZETA	Standalone Z80 SBC w/ SBC compatibility
; 3. ZETA2	Second version of ZETA with enhanced memory bank switching
; 4. N8		MSX-compatible Z180 SBC w/ onboard video and sound
; 5. MK4	Mark IV Z180 based SBC w/ ECB interface
; 6. UNA	Any Z80/Z180 computer with UNA BIOS

; All the classes require certain generic definitions, and these are
; defined here prior to the inclusion of platform specific .inc files.

; It is unfortunate, but all the possible config items must be defined
; here because the config gets read before the specific std-*.inc's

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
FALSE		.EQU 	0
TRUE		.EQU 	~FALSE
;
; PRIMARY HARDWARE PLATFORMS
;
PLT_SBC		.EQU	1		; SBC ECB Z80 SBC
PLT_ZETA	.EQU	2		; ZETA Z80 SBC
PLT_ZETA2	.EQU	3		; ZETA Z80 V2 SBC
PLT_N8		.EQU	4		; N8 (HOME COMPUTER) Z180 SBC
PLT_MK4		.EQU	5		; MARK IV
PLT_UNA		.EQU	6		; UNA BIOS
;
; BOOT STYLE
;
BT_MENU		.EQU	1		; WAIT FOR MENU SELECTION AT LOADER PROMPT
BT_AUTO		.EQU	2		; AUTO SELECT BOOT_DEFAULT AFTER BOOT_TIMEOUT
;
; RAM DISK INITIALIZATION OPTIONS
;
CLR_NEVER	.EQU	0		; NEVER CLEAR RAM DISK
CLR_AUTO	.EQU	1		; CLEAR RAM DISK IF INVALID DIR ENTRIES
CLR_ALWAYS	.EQU	2		; ALWAYS CLEAR RAM DISK
;
; FLOPPY DISK MEDIA SELECTIONS (ID'S MUST BE INDEX OF ENTRY IN FCD_TBL)
;
FDM720		.EQU	0		; 3.5" FLOPPY, 720KB, 2 SIDES, 80 TRKS, 9 SECTORS
FDM144		.EQU	1		; 3.5" FLOPPY, 1.44MB, 2 SIDES, 80 TRKS, 18 SECTORS
FDM360		.EQU	2		; 5.25" FLOPPY, 360KB, 2 SIDES, 40 TRKS, 9 SECTORS
FDM120		.EQU	3		; 5.25" FLOPPY, 1.2MB, 2 SIDES, 80 TRKS, 15 SECTORS
FDM111		.EQU	4		; 8" FLOPPY, 1.11MB, 2 SIDES, 74 TRKS, 15 SECTORS
;
; MEDIA ID VALUES
;
MID_NONE	.EQU	0
MID_MDROM	.EQU	1
MID_MDRAM	.EQU	2
MID_RF		.EQU	3
MID_HD		.EQU	4
MID_FD720	.EQU	5
MID_FD144	.EQU	6
MID_FD360	.EQU	7
MID_FD120	.EQU	8
MID_FD111	.EQU	9
;
; FD MODE SELECTIONS
;
FDMODE_NONE	.EQU	0		; FD modes defined in std-*.inc
FDMODE_DIO	.EQU	1		; DISKIO V1
FDMODE_ZETA	.EQU	2		; ZETA
FDMODE_ZETA2	.EQU	3		; ZETA V2
FDMODE_DIDE	.EQU	4		; DUAL IDE
FDMODE_N8	.EQU	5		; N8
FDMODE_DIO3	.EQU	6		; DISKIO V3
;
; IDE MODE SELECTIONS
;
IDEMODE_NONE	.EQU	0
IDEMODE_DIO	.EQU	1		; DISKIO V1
IDEMODE_DIDE	.EQU	2		; DUAL IDE
IDEMODE_MK4	.EQU	3		; MARK IV ONBOARD IDE (8 BIT)
;
; PPIDE MODE SELECTIONS
;
PPIDEMODE_NONE	.EQU	0
PPIDEMODE_STD	.EQU	1		; STANDARD SBC PARALLEL PORT
PPIDEMODE_DIO3	.EQU	2		; DISKIO V3 PARALLEL PORT
PPIDEMODE_MFP	.EQU	3		; MULTIFUNCTION / PIC
;
; SD MODE SELECTIONS
;
SDMODE_NONE	.EQU	0
SDMODE_JUHA	.EQU	1		; JUHA MINI BOARD
SDMODE_N8	.EQU	2		; N8-2511, UNMODIFIED
SDMODE_CSIO	.EQU	3		; N8-2312 OR N8-2511 MODIFIED
SDMODE_PPI	.EQU	4		; PPISD MINI BOARD
SDMODE_UART	.EQU	5		; SD INTERFACE VIA UART
SDMODE_DSD	.EQU	6		; DUAL SD
SDMODE_MK4	.EQU	7		; MARK IV
;
; EMULATION TYPES
;
EMUTYP_NONE	.EQU	0
EMUTYP_TTY	.EQU	1
EMUTYP_ANSI	.EQU	2
;
; INCLUDE VERSION AND BUILD SETTINGS
;
#INCLUDE "ver.inc"			; ADD BIOSVER
;
#INCLUDE "build.inc"			; INCLUDE USER CONFIG, ADD VARIANT, TIMESTAMP, & ROMSIZE
;
; INCLUDE PLATFORM SPECIFIC HARDWARE DEFINITIONS
;
#IF ((PLATFORM == PLT_SBC) | (PLATFORM == PLT_ZETA) | (PLATFORM == PLT_ZETA2))
#INCLUDE "SBC.inc"
#ENDIF
;
#IF (PLATFORM == PLT_N8)
#INCLUDE "n8.inc"
#ENDIF
;
#IF (PLATFORM == PLT_MK4)
#INCLUDE "mk4.inc"
#ENDIF
;
#IF (PLATFORM == PLT_UNA)
#INCLUDE "una.inc"
#ENDIF
;
; CHARACTER DEVICE FUNCTIONS
;
CF_INIT		.EQU	0
CF_IN		.EQU	1
CF_IST		.EQU	2
CF_OUT		.EQU	3
CF_OST		.EQU	4
;
; DISK OPERATIONS
;
DOP_READ	.EQU	0		; READ OPERATION
DOP_WRITE	.EQU	1		; WRITE OPERATION
DOP_FORMAT	.EQU	2		; FORMAT OPERATION
DOP_READID	.EQU	3		; READ ID OPERATION
;
; DISK DRIVER FUNCTIONS
;
DF_READY	.EQU	1
DF_SELECT	.EQU	2
DF_READ		.EQU	3
DF_WRITE	.EQU	4
DF_FORMAT	.EQU	5
;
; BIOS FUNCTIONS
;
#IF (PLATFORM == PLT_UNA)
BF_CIO		.EQU	$10
BF_CIOIN	.EQU	BF_CIO + 1	; CHARACTER INPUT
BF_CIOOUT	.EQU	BF_CIO + 2	; CHARACTER OUTPUT
BF_CIOIST	.EQU	BF_CIO + 3	; CHARACTER INPUT STATUS
BF_CIOOST	.EQU	BF_CIO + 4	; CHARACTER OUTPUT STATUS
;
BF_DIO		.EQU	$40
BF_DIORD	.EQU	BF_DIO + 2	; DISK READ
BF_DIOWR	.EQU	BF_DIO + 3	; DISK WRITE
#ELSE
BF_CIO		.EQU	$00
BF_CIOIN	.EQU	BF_CIO + 0	; CHARACTER INPUT
BF_CIOOUT	.EQU	BF_CIO + 1	; CHARACTER OUTPUT
BF_CIOIST	.EQU	BF_CIO + 2	; CHARACTER INPUT STATUS
BF_CIOOST	.EQU	BF_CIO + 3	; CHARACTER OUTPUT STATUS
BF_CIOCFG	.EQU	BF_CIO + 4	; CHARACTER I/O CONFIG
BF_CIOGETCNT	.EQU	BF_CIO + 8	; CHARACTER DEVICE COUNT
BF_CIOGETINF	.EQU	BF_CIO + 9	; CHARACTER DEVICE INFO
;
BF_DIO		.EQU	$10
BF_DIORD	.EQU	BF_DIO + 0	; DISK READ
BF_DIOWR	.EQU	BF_DIO + 1	; DISK WRITE
BF_DIOST	.EQU	BF_DIO + 2	; DISK STATUS
BF_DIOMED	.EQU	BF_DIO + 3	; DISK MEDIA
BF_DIOID	.EQU	BF_DIO + 4	; DISK IDENTIFY
BF_DIOGETBUF	.EQU	BF_DIO + 8	; DISK GET BUFFER ADR
BF_DIOSETBUF	.EQU	BF_DIO + 9	; DISK SET BUFFER ADR
BF_DIOGETCNT	.EQU	BF_DIO + 10	; DISK DEVICE COUNT
BF_DIOGETINF	.EQU	BF_DIO + 11	; DISK DEVICE INFO
;
BF_RTC		.EQU	$20
BF_RTCGETTIM	.EQU	BF_RTC + 0	; GET TIME
BF_RTCSETTIM	.EQU	BF_RTC + 1	; SET TIME
BF_RTCGETBYT	.EQU	BF_RTC + 2	; GET NVRAM BYTE BY INDEX
BF_RTCSETBYT	.EQU	BF_RTC + 3	; SET NVRAM BYTE BY INDEX
BF_RTCGETBLK	.EQU	BF_RTC + 4	; GET NVRAM DATA BLOCK
BF_RTCSETBLK	.EQU	BF_RTC + 5	; SET NVRAM DATA BLOCK
;
BF_EMU		.EQU	$30
BF_EMUIN	.EQU	BF_EMU + 0	; EMULATOR CHARACTER INPUT
BF_EMUOUT	.EQU	BF_EMU + 1	; EMULATOR CHARACTER OUTPUT
BF_EMUIST	.EQU	BF_EMU + 2	; EMULATOR CHARACTER INPUT STATUS
BF_EMUOST	.EQU	BF_EMU + 3	; EMULATOR CHARACTER OUTPUT STATUS
BF_EMUCFG	.EQU	BF_EMU + 4	; EMULATOR CHARACTER I/O CONFIG
BF_EMUINI	.EQU	BF_EMU + 8	; INITIALIZE EMULATION
BF_EMUQRY	.EQU	BF_EMU + 9	; QUERY EMULATION STATUS
;
BF_VDA		.EQU	$40
BF_VDAINI	.EQU	BF_VDA + 0	; INITIALIZE VDU
BF_VDAQRY	.EQU	BF_VDA + 1	; QUERY VDU STATUS
BF_VDARES	.EQU	BF_VDA + 2	; SOFT RESET VDU
BF_VDASCS	.EQU	BF_VDA + 3	; SET CURSOR STYLE
BF_VDASCP	.EQU	BF_VDA + 4	; SET CURSOR POSITION
BF_VDASAT	.EQU	BF_VDA + 5	; SET CHARACTER ATTRIBUTE
BF_VDASCO	.EQU	BF_VDA + 6	; SET CHARACTER COLOR
BF_VDAWRC	.EQU	BF_VDA + 7	; WRITE CHARACTER
BF_VDAFIL	.EQU	BF_VDA + 8	; FILL
BF_VDACPY	.EQU	BF_VDA + 9	; COPY
BF_VDASCR	.EQU	BF_VDA + 10	; SCROLL
BF_VDAKST	.EQU	BF_VDA + 11	; GET KEYBOARD STATUS
BF_VDAKFL	.EQU	BF_VDA + 12	; FLUSH KEYBOARD BUFFER
BF_VDAKRD	.EQU	BF_VDA + 13	; READ KEYBOARD
;
BF_SYS		.EQU	$F0
BF_SYSSETBNK	.EQU	BF_SYS + 0	; SET CURRENT BANK
BF_SYSGETBNK	.EQU	BF_SYS + 1	; GET CURRENT BANK
BF_SYSCPY	.EQU	BF_SYS + 2	; COPY TO/FROM RAM/ROM MEMORY BANK
BF_SYSXCPY	.EQU	BF_SYS + 3	; EXTENDED COPY SETUP
BF_SYSGETVER	.EQU	BF_SYS + 6	; GET VERSION OF HBIOS
BF_SYSHCBGETB	.EQU	BF_SYS + 8	; GET HCB BYTE VALUE
BF_SYSHCBPUTB	.EQU	BF_SYS + 9	; PUT HCB BYTE VALUE
BF_SYSHCBGETW	.EQU	BF_SYS + 10	; GET HCB WORD VALUE
BF_SYSHCBPUTW	.EQU	BF_SYS + 11	; PUT HCB BYTE VALUE
#ENDIF
;	
; HBIOS CONTROL BLOCK OFFSETS
;
HCB_CPUMHZ	.EQU	$05
HCB_CPUKHZ	.EQU	$06
HCB_BOOTVOL	.EQU	$0C		; BOOT VOLUME, MSB=DEV/UNIT, LSB=LU
HCB_BOOTBID	.EQU	$0E		; BANK ID OF ROM PAGE BOOTED
HCB_BOOTVDA	.EQU	$0F		; 0=NO, 1=YES (BOOT TO VIDEO DISPLAY)
HCB_CDL		.EQU	$E0		; CHARACTER DEVICE LIST
HCB_PDL		.EQU	$E8		; PRINT DEVICE LIST
HCB_VDL		.EQU	$EC		; VIDEO DEVICE LIST
HCB_DDL		.EQU	$F0		; DISK DEVICE LIST
;
; MEMORY LAYOUT
;
SYS_SIZ		.EQU	$3000			; COMBINED SIZE OF SYSTEM AREA (OS + HBIOS PROXY)
HBBUF_SIZ	.EQU	1024			; INVARIANT HBIOS PHYSICAL DISK BUFFER, 1K
HBX_SIZ		.EQU	$200			; HBIOS PROXY SIZE (SUBJECT TO CHANGE)
CPM_SIZ		.EQU	SYS_SIZ - HBX_SIZ	; NET SIZE OF ALL OS COMPONENTS (EXCLUDING HBIOS PROXY)
CCP_SIZ		.EQU	$800			; INVARIANT SIZE OF CCP
BDOS_SIZ	.EQU	$E00			; INVARIANT SIZE OF BDOS
CBIOS_SIZ	.EQU	CPM_SIZ - CCP_SIZ - BDOS_SIZ	; CBIOS IS THE REMAINDER

MEMTOP		.EQU	$10000			; INVARIANT TOP OF Z80 ADDRESSABLE MEMORY
BNKTOP		.EQU	$8000			; BANK MEMORY BARRIER

HBX_IMG		.EQU	$200			; LOC OF HBX IMAGE IN HBIOS IMAGE BANK

HBBUF_END	.EQU	BNKTOP			; END OF PHYSICAL DISK BUFFER IN HBIOS
HBBUF_LOC	.EQU	HBBUF_END - HBBUF_SIZ	; START OF PHYSICAL DISK BUFFER
HBX_END		.EQU	MEMTOP			; END OF HBIOS PROXY
HBX_LOC		.EQU	HBX_END - HBX_SIZ	; START OF HBIOS PROXY
CPM_END		.EQU	HBX_LOC			; END OF CPM COMPONENTS (INCLUDING CBIOS)
CPM_LOC		.EQU	CPM_END - CPM_SIZ	; START OF CPM COMPONENTS
CBIOS_END	.EQU	HBX_LOC			; END OF CBIOS
CBIOS_LOC	.EQU	CBIOS_END - CBIOS_SIZ	; START OF CBIOS
BDOS_END	.EQU	CBIOS_LOC		; END OF BDOS
BDOS_LOC	.EQU	BDOS_END - BDOS_SIZ	; START OF BDOS
CCP_END		.EQU	BDOS_LOC		; END OF CCP
CCP_LOC		.EQU	CCP_END - CCP_SIZ	; START OF CCP

HCB_LOC		.EQU	$100			; LOCATION OF HCB IN HBIOS BANK

CPM_ENT		.EQU	CBIOS_LOC		; CPM ENTRY POINT (IN CBIOS)
CCP_ENT		.EQU	CPM_LOC			; COMMAND PROCESSOR ENTRY POINT (IN CCP)

MON_LOC		.EQU	$C000			; LOCATION OF MONITOR FOR RUNNING SYSTEM
MON_SIZ		.EQU	$1000			; SIZE OF MONITOR BINARY IMAGE
MON_END		.EQU	MON_LOC + MON_SIZ	; END OF MONITOR

MON_DSKY	.EQU	MON_LOC + (0 * 3)	; MONITOR ENTRY (DSKY)
MON_SERIAL	.EQU	MON_LOC + (1 * 3)	; MONITOR ENTRY (SERIAL PORT)

CBIOS_BOOT	.EQU	CBIOS_LOC + (0 * 3)
CBIOS_WBOOT	.EQU	CBIOS_LOC + (1 * 3)
CBIOS_CONST	.EQU	CBIOS_LOC + (2 * 3)
CBIOS_CONIN	.EQU	CBIOS_LOC + (3 * 3)
CBIOS_CONOUT	.EQU	CBIOS_LOC + (4 * 3)
CBIOS_LIST	.EQU	CBIOS_LOC + (5 * 3)
CBIOS_PUNCH	.EQU	CBIOS_LOC + (6 * 3)
CBIOS_READER	.EQU	CBIOS_LOC + (7 * 3)
CBIOS_HOME	.EQU	CBIOS_LOC + (8 * 3)
CBIOS_SELDSK	.EQU	CBIOS_LOC + (9 * 3)
CBIOS_SETTRK	.EQU	CBIOS_LOC + (10 * 3)
CBIOS_SETSEC	.EQU	CBIOS_LOC + (11 * 3)
CBIOS_SETDMA	.EQU	CBIOS_LOC + (12 * 3)
CBIOS_READ	.EQU	CBIOS_LOC + (13 * 3)
CBIOS_WRITE	.EQU	CBIOS_LOC + (14 * 3)
CBIOS_LISTST	.EQU	CBIOS_LOC + (15 * 3)
CBIOS_SECTRN	.EQU	CBIOS_LOC + (16 * 3)
;
CDISK:	 	.EQU 	4	; LOC IN PAGE 0 OF CURRENT DISK NUMBER 0=A,...,15=P
IOBYTE:	 	.EQU 	3	; LOC IN PAGE 0 OF I/O DEFINITION BYTE
;
; HBIOS PROXY COMMON DATA BLOCK
; EXACTLY 32 BYTES AT $FFE0-$FFFF
;
HBX_XFC		.EQU	$10000 - $20		; HBIOS PROXY INTERFACE AREA, 32 BYTES FIXED
;
HBX_XFCDAT	.EQU	HBX_XFC			; DATA PORTION OF HBIOX PROXY INTERFACE AREA
HB_CURBNK	.EQU	HBX_XFCDAT + 0		; CURRENTLY ACTIVE LOW MEMORY BANK ID
;HB_PRVBNK	.EQU	HBX_XFCDAT + 1		; PREVIOUS BANK (DEPRECATED)
HB_SRCADR	.EQU	HBX_XFCDAT + 2		; BNKCPY: DESTINATION BANK ID
HB_SRCBNK	.EQU	HBX_XFCDAT + 4		; BNKCPY: SOURCE BANK ID
HB_DSTADR	.EQU	HBX_XFCDAT + 5		; BNKCPY: DESTINATION ADDRESS
HB_DSTBNK	.EQU	HBX_XFCDAT + 7		; BNKCPY: SOURCE ADDRESS
HB_CNT		.EQU	HBX_XFCDAT + 8		; BNKCPY: COUNT
;
HBX_XFCFNS	.EQU	HBX_XFC + $10		; JUMP TABLE PORTION OF HBIOS PROXY INTERFACE AREA
HB_INVOKE	.EQU	HBX_XFCFNS + (0 * 3)	; INVOKE HBIOS FUNCTION
HB_BNKSEL	.EQU	HBX_XFCFNS + (1 * 3)	; SELECT LOW MEMORY BANK ID
HB_BNKCPY	.EQU	HBX_XFCFNS + (2 * 3)	; INTERBANK MEMORY COPY
HB_BNKCALL	.EQU	HBX_XFCFNS + (3 * 3)	; INTERBANK FUNCTION CALL
;HB_LOC		.EQU	HBX_XFCFNS + 12		; ADDRESS OF HBIOS PROXY START (DEPRECATED)
HB_IDENT	.EQU	HBX_XFCFNS + 14		; POINTER TO HBIOS IDENT DATA BLOCK
;
;
;
#IF (PLATFORM == PLT_SBC)
  #DEFINE 	PLATFORM_NAME	"SBC Z80"
#ENDIF
#IF (PLATFORM == PLT_ZETA)
  #DEFINE 	PLATFORM_NAME	"ZETA Z80"
#ENDIF
#IF (PLATFORM == PLT_ZETA2)
  #DEFINE 	PLATFORM_NAME	"ZETA Z80 V2"
#ENDIF
#IF (PLATFORM == PLT_N8)
  #DEFINE 	PLATFORM_NAME	"N8 Z180"
#ENDIF
#IF (PLATFORM == PLT_MK4)
  #DEFINE 	PLATFORM_NAME	"MARK IV Z180"
#ENDIF
#IF (PLATFORM == PLT_UNA)
  #DEFINE	PLATFORM_NAME	"UNA"
#ENDIF
;
; HELPER MACROS
;
#DEFINE	PRTC(C)	CALL PRTCH \ .DB C			; PRINT CHARACTER C TO CONSOLE - PRTC('X')
#DEFINE	PRTS(S)	CALL PRTSTRD \ .DB S			; PRINT STRING S TO CONSOLE - PRTD("HELLO")
#DEFINE	PRTX(X) CALL PRTSTRI \ .DW X			; PRINT STRING AT ADDRESS X TO CONSOLE - PRTI(STR_HELLO)
;
#DEFINE	XIO_PRTC(C)	CALL XIO_PRTCH \ .DB C		; PRINT CHARACTER C TO CONSOLE - PRTC('X')
#DEFINE	XIO_PRTS(S)	CALL XIO_PRTSTRD \ .DB S	; PRINT STRING S TO CONSOLE - PRTD("HELLO")
#DEFINE	XIO_PRTX(X)	CALL XIO_PRTSTRI \ .DW X	; PRINT STRING AT ADDRESS X TO CONSOLE - PRTI(STR_HELLO)
