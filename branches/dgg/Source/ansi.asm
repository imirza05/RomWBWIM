;
;==================================================================================================
;   ANSI EMULATION MODULE
;==================================================================================================
;
; TODO:
;   - THIS IS CURRENTLY JUST A CLONE OF TTY.ASM!  NEEDS A REAL IMPLEMENTATION!
;   - SOME FUNCTIONS ARE NOT IMPLEMENTED!
;
ANSI_INIT:
	JR	ANSI_INI	; REUSE THE INI FUNCTION BELOW
;
;
;
ANSI_DISPATCH:
	LD	A,B		; GET REQUESTED FUNCTION
	AND	$0F		; ISOLATE SUB-FUNCTION
	JR	Z,ANSI_IN	; $30
	DEC	A
	JR	Z,ANSI_OUT	; $31
	DEC	A
	JR	Z,ANSI_IST	; $32
	DEC	A
	JR	Z,ANSI_OST	; $33
	DEC	A
	JR	Z,ANSI_CFG	; $34
	CP	8
	JR	Z,ANSI_INI	; $38
	CP	9
	JR	Z,ANSI_QRY	; $39
	CALL	PANIC
;
;
;
ANSI_IN:
	LD	B,BF_VDAKRD	; SET FUNCTION TO KEYBOARD READ
	JP	EMU_VDADISP	; CHAIN TO VDA DISPATCHER
;
;
;
ANSI_OUT:
	CALL	ANSI_DOCHAR	; HANDLE THE CHARACTER (EMULATION ENGINE)
	XOR	A		; SIGNAL SUCCESS
	RET
;
;
;
ANSI_IST:
	LD	B,BF_VDAKST	; SET FUNCTION TO KEYBOARD STATUS
	JP	EMU_VDADISP	; CHAIN TO VDA DISPATCHER
;
;
;
ANSI_OST:
	XOR	A		; ZERO ACCUM
	INC	A		; A := $FF TO SIGNAL OUTPUT BUFFER READY
	RET
;
;
;
ANSI_CFG:
	XOR	A		; SIGNAL SUCCESS
	RET
;
;
;
ANSI_INI:
	LD	B,BF_VDAQRY	; FUNCTION IS QUERY
	LD	HL,0		; WE DO NOT WANT A COPY OF THE CHARACTER BITMAP DATA
	CALL	EMU_VDADISP	; PERFORM THE QUERY FUNCTION
	LD	(ANSI_DIM),DE	; SAVE THE SCREEN DIMENSIONS RETURNED
	LD	DE,0		; DE := 0, CURSOR TO HOME POSITION 0,0
	LD	(ANSI_POS),DE	; SAVE CURSOR POSITION
	LD	B,BF_VDARES	; SET FUNCTION TO RESET
	JP	EMU_VDADISP	; RESET VDA AND RETURN
;
;
;
ANSI_QRY:
	XOR	A		; SIGNAL SUCCESS
	RET
;
;
;
ANSI_DOCHAR:
	LD	A,E		; CHARACTER TO PROCESS
	CP	8		; BACKSPACE
	JR	Z,ANSI_BS
	CP	12		; FORMFEED
	JR	Z,ANSI_FF
	CP	13		; CARRIAGE RETURN
	JR	Z,ANSI_CR
	CP	10		; LINEFEED
	JR	Z,ANSI_LF
	CP	32		; COMPARE TO SPACE (FIRST PRINTABLE CHARACTER)
	RET	C		; SWALLOW OTHER CONTROL CHARACTERS
	LD	B,BF_VDAWRC
	CALL	EMU_VDADISP	; SPIT OUT THE RAW CHARACTER
	LD	A,(ANSI_COL)	; GET CUR COL
	INC	A		; INCREMENT
	LD	(ANSI_COL),A	; SAVE IT
	LD	DE,(ANSI_DIM)	; GET SCREEN DIMENSIONS
	CP	E		; COMPARE TO COLS IN LINE
	RET	C		; NOT PAST END OF LINE, ALL DONE
	CALL	ANSI_CR		; CARRIAGE RETURN
	JR	ANSI_LF		; LINEFEED AND RETURN
;
ANSI_FF:
	LD	DE,0		; PREPARE TO HOME CURSOR
	LD	(ANSI_POS),DE	; SAVE NEW CURSOR POSITION
	CALL	ANSI_XY		; EXECUTE
	LD	DE,(ANSI_DIM)	; GET SCREEN DIMENSIONS
	LD	H,D		; SET UP TO MULTIPLY ROWS BY COLS
	CALL	MULT8		; HL := H * E TO GET TOTAL SCREEN POSITIONS
	LD	E,' '		; FILL SCREEN WITH BLANKS
	LD	B,BF_VDAFIL	; SET FUNCTION TO FILL
	CALL	EMU_VDADISP	; PERFORM FILL
	JR	ANSI_XY		; HOME CURSOR AND RETURN
;
ANSI_BS:
	LD	DE,(ANSI_POS)	; GET CURRENT ROW/COL IN DE
	LD	A,E		; GET CURRENT COLUMN
	CP	1		; COMPARE TO COLUMN 1
	RET	C		; LESS THAN 1, NOTHING TO DO
	DEC	E		; POINT TO PREVIOUS COLUMN
	LD	(ANSI_POS),DE	; SAVE NEW COLUMN VALUE
	CALL	ANSI_XY		; MOVE CURSOR TO NEW TARGET COLUMN
	LD	E,' '		; LOAD A SPACE CHARACTER
	LD	B,BF_VDAWRC	; SET FUNCTION TO WRITE CHARACTER
	CALL	EMU_VDADISP	; OVERWRITE WITH A SPACE CHARACTER
	JR	ANSI_XY		; NEED TO MOVE CURSOR BACK TO NEW TARGET COLUMN
;
ANSI_CR:
	XOR	A		; ZERO ACCUM
	LD	(ANSI_COL),A	; COL := 0
	JR	ANSI_XY		; REPOSITION CURSOR AND RETURN
;
ANSI_LF:
	LD	A,(ANSI_ROW)	; GET CURRENT ROW
	INC	A		; BUMP TO NEXT
	LD	(ANSI_ROW),A	; SAVE IT
	LD	DE,(ANSI_DIM)	; GET SCREEN DIMENSIONS
	CP	D		; COMPARE TO SCREEN ROWS
	JR	C,ANSI_XY	; NOT PAST END, ALL DONE
	DEC	D		; D NOW HAS MAX ROW NUM (ROWS - 1)
	SUB	D		; A WILL NOW HAVE NUM LINES TO SCROLL
	LD	E,A		; LINES TO SCROLL -> E
	LD	B,BF_VDASCR	; SET FUNCTION TO SCROLL
	CALL	EMU_VDADISP	; DO THE SCROLLING
	LD	A,(ANSI_ROWS)	; GET SCREEN ROW COUNT
	DEC	A		; A NOW HAS LAST ROW
	LD	(ANSI_ROW),A	; SAVE IT
	JR	ANSI_XY		; RESPOSITION CURSOR AND RETURN
;
ANSI_XY:
	LD	DE,(ANSI_POS)	; GET THE DESIRED CURSOR POSITION
	LD	B,BF_VDASCP	; SET FUNCTIONT TO SET CURSOR POSITION
	JP	EMU_VDADISP	; REPOSITION CURSOR
;
;
;
ANSI_POS:
ANSI_COL	.DB	0	; CURRENT COLUMN - 0 BASED
ANSI_ROW	.DB	0	; CURRENT ROW - 0 BASED
;
ANSI_DIM:
ANSI_COLS	.DB	80	; NUMBER OF COLUMNS ON SCREEN
ANSI_ROWS	.DB	24	; NUMBER OF ROWS ON SCREEN