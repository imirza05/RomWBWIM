                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 3.0.2 #6489 (May 10 2011) (Mac OS X x86_64)
                              4 ; This file was generated Sun May 29 01:02:12 2011
                              5 ;--------------------------------------------------------
                              6 	.module dribdos
                              7 	.optsdcc -mz80
                              8 	
                              9 ;--------------------------------------------------------
                             10 ; Public variables in this module
                             11 ;--------------------------------------------------------
                             12 	.globl _bdos
                             13 ;--------------------------------------------------------
                             14 ; special function registers
                             15 ;--------------------------------------------------------
                             16 ;--------------------------------------------------------
                             17 ;  ram data
                             18 ;--------------------------------------------------------
                             19 	.area _DATA
                             20 ;--------------------------------------------------------
                             21 ; overlayable items in  ram 
                             22 ;--------------------------------------------------------
                             23 	.area _OVERLAY
                             24 ;--------------------------------------------------------
                             25 ; external initialized ram data
                             26 ;--------------------------------------------------------
                             27 ;--------------------------------------------------------
                             28 ; global & static initialisations
                             29 ;--------------------------------------------------------
                             30 	.area _HOME
                             31 	.area _GSINIT
                             32 	.area _GSFINAL
                             33 	.area _GSINIT
                             34 ;--------------------------------------------------------
                             35 ; Home
                             36 ;--------------------------------------------------------
                             37 	.area _HOME
                             38 	.area _HOME
                             39 ;--------------------------------------------------------
                             40 ; code
                             41 ;--------------------------------------------------------
                             42 	.area _BDOS
                             43 ;dribdos.c:4: void bdos(int argc,char **argv)
                             44 ;	---------------------------------
                             45 ; Function bdos
                             46 ; ---------------------------------
   0000                      47 _bdos_start::
   0000                      48 _bdos:
                             49 ;;	push	ix
                             50 ;;	ld	ix,#0
                             51 ;;	add	ix,sp
                             52 ;; ;dribdos.c:7: }
                             53 ;; 	pop	ix
                             54 ;;	ret
                             55 
                             56 ;; dwg ; begin DRI source code here
                             57 
                             58 	.title	'Bdos Interface, Bdos, Version 2.2 Feb, 1980'
                             59 
                             60 ;;dwg;;:	.Z80
                             61 ;;	aseg
o  0000                      62 	org	100h
o  0000                      63 	maclib	MEMCFG.LIB	; define configuration parameters
o  0000                      64 	.phase	bdosph
o  0000                      65 bios	equ	biosph
                             66 
                             67 ;*****************************************************************
                             68 ;*****************************************************************
                             69 ;**                                                             **
                             70 ;**   B a s i c    D i s k   O p e r a t i n g   S y s t e m    **
                             71 ;**            I n t e r f a c e   M o d u l e                  **
                             72 ;**                                                             **
                             73 ;*****************************************************************
                             74 ;*****************************************************************
                             75 
                             76 ;	Copyright (c) 1978, 1979, 1980
                             77 ;	Digital Research
                             78 ;	Box 579, Pacific Grove
                             79 ;	California
                             80 
                             81 
                             82 ;      20 january 1980
                             83 
o  0000                      84 ssize	equ	24		;24 level stack
                             85 
                             86 ;	low memory locations
o  0000                      87 reboot	equ	0000h		;reboot system
o  0000                      88 ioloc	equ	0003h		;i/o byte location
o  0000                      89 bdosa	equ	0006h		;address field of jp BDOS
                             90 
                             91 ;	bios access constants
o  0000                      92 bootf	defl	bios+3*0	;cold boot function
o  0000                      93 wbootf	defl	bios+3*1	;warm boot function
o  0000                      94 constf	defl	bios+3*2	;console status function
o  0000                      95 coninf	defl	bios+3*3	;console input function
o  0000                      96 conoutf	defl	bios+3*4	;console output function
o  0000                      97 listf	defl	bios+3*5	;list output function
o  0000                      98 punchf	defl	bios+3*6	;punch output function
o  0000                      99 readerf	defl	bios+3*7	;reader input function
o  0000                     100 homef	defl	bios+3*8	;disk home function
o  0000                     101 seldskf	defl	bios+3*9	;select disk function
o  0000                     102 settrkf	defl	bios+3*10	;set track function
o  0000                     103 setsecf	defl	bios+3*11	;set sector function
o  0000                     104 setdmaf	defl	bios+3*12	;set dma function
o  0000                     105 readf	defl	bios+3*13	;read disk function
o  0000                     106 writef	defl	bios+3*14	;write disk function
o  0000                     107 liststf	defl	bios+3*15	;list status function
o  0000                     108 sectran	defl	bios+3*16	;sector translate
                            109 
                            110 ;	equates for non graphic characters
o  0000                     111 ctlc	equ	03h		;control c
o  0000                     112 ctle	equ	05h		;physical eol
o  0000                     113 ctlh	equ	08h		;backspace
o  0000                     114 ctlp	equ	10h		;prnt toggle
o  0000                     115 ctlr	equ	12h		;repeat line
o  0000                     116 ctls	equ	13h		;stop/start screen
o  0000                     117 ctlu	equ	15h		;line delete
o  0000                     118 ctlx	equ	18h		;=ctl-u
o  0000                     119 ctlz	equ	1ah		;end of file
o  0000                     120 rubout	equ	7fh		;char delete
o  0000                     121 tab	equ	09h		;tab char
o  0000                     122 cr	equ	0dh		;carriage return
o  0000                     123 lf	equ	0ah		;line feed
o  0000                     124 ctl	equ	5eh		;up arrow
                            125 
   0000 00 00 00 00 00 00   126 	.db	0,0,0,0,0,0
                            127 
                            128 ;	enter here from the user's program with function number in c,
                            129 ;	and information address in d,e
   0006 C3r11s00            130 	jp	bdose		;past parameter block
                            131 
                            132 ;	************************************************
                            133 ;	*** relative locations 0009 - 000e           ***
                            134 ;	************************************************
   0009r37s00               135 pererr:	.dw	persub		;permanent error subroutine
   000Br3Es00               136 selerr:	.dw	selsub		;select error subroutine
   000Dr41s00               137 roderr:	.dw	rodsub		;ro disk error subroutine
   000Fr44s00               138 roferr:	.dw	rofsub		;ro file error subroutine
                            139 
                            140 
   0011 EB                  141 bdose:	ex	de,hl		;arrive here from user programs
   0012 22rFCs01            142 	ld	(info),hl
   0015 EB                  143 	ex	de,hl		;info=DE, DE=info
   0016 7B                  144 	ld	a,e
   0017 32rC6s0A            145 	ld	(linfo),a	;linfo = low(info) - don't equ
a  001A                     146 	ld	hl,0
   001A 22rFCs01            147 	ld	(aret),hl	;return value defaults to 0000
                            148 				;save user's stack pointer, set to local stack
   001D 39                  149 	add	hl,sp
   001E 22rFCs01            150 	ld	(entsp),hl	;entsp = stackptr
a  0021                     151 	ld	sp,lstack	;local stack setup
   0021 AF                  152 	xor	a
   0022 32rC6s0A            153 	ld	(fcbdsk),a
   0025 32rC6s0A            154 	ld	(resel),a	;fcbdsk,resel=false
a  0028                     155 	ld	hl,goback	;return here after all functions
   0028 E5                  156 	push	hl		;jmp goback equivalent to ret
   0029 79                  157 	ld	a,c
ua 002A                     158 	cp	nfuncs
   002A D0                  159 	ret	nc		;skip if invalid #
   002B 4B                  160 	ld	c,e		;possible output character to C
a  002C                     161 	ld	hl,functab
   002C 5F                  162 	ld	e,a
a  002D                     163 	ld	d,0		;DE=func, HL=.ciotab
   002D 19                  164 	add	hl,de
   002E 19                  165 	add	hl,de
   002F 5E                  166 	ld	e,(hl)
   0030 23                  167 	inc	hl
   0031 56                  168 	ld	d,(hl)		;DE=functab(func)
   0032 2ArFCs01            169 	ld	hl,(info)	;info in DE for later xchg
   0035 EB                  170 	ex	de,hl
   0036 E9                  171 	jp	(hl)		;dispatched
                            172 
                            173 ;	dispatch table for functions
   0037                     174 functab:
o  0037                     175 	dw	wbootf, func1, func2, func3
o  0037                     176 	dw	punchf, listf, func6, func7
o  0037                     177 	dw	func8, func9, func10,func11
o  0037                     178 diskf	equ	($-functab)/2	;disk funcs
o  0037                     179 	dw	func12,func13,func14,func15
o  0037                     180 	dw	func16,func17,func18,func19
o  0037                     181 	dw	func20,func21,func22,func23
o  0037                     182 	dw	func24,func25,func26,func27
o  0037                     183 	dw	func28,func29,func30,func31
o  0037                     184 	dw	func32,func33,func34,func35
o  0037                     185 	dw	func36,func37,func38,func39
o  0037                     186 	dw	func40
o  0037                     187 nfuncs	equ	($-functab)/2
                            188 
                            189 
                            190 ;	error subroutines
a  0037                     191 persub:	ld	hl,permsg	;report permanent error
   0037 CDr4As00            192 	call	errflg		;to report the error
ua 003A                     193 	cp	ctlc
u  003A CA 00 00            194 	jp	z,reboot	;reboot if response is ctlc
   003D C9                  195 	ret			;and ignore the error
                            196 
a  003E                     197 selsub:	ld	hl,selmsg	;report select error
   003E C3r44s00            198 	jp	wait$err	;wait console before boot
                            199 
a  0041                     200 rodsub:	ld	hl,rodmsg	;report write to read/only disk
   0041 C3r44s00            201 	jp	wait$err	;wait console
                            202 
   0044                     203 rofsub:				;report read/only file
a  0044                     204 	ld	hl,rofmsg	;drop through to wait for console
                            205 
   0044                     206 wait$err:			;wait for response before boot
   0044 CDr4As00            207 	call	errflg
u  0047 C3 00 00            208 	jp	reboot
                            209 
                            210 ;	error messages
o  004A                     211 dskmsg:	db	'Bdos Err On '
o  004A                     212 dskerr:	db	' : $'		;filled in by errflg
o  004A                     213 permsg:	db	'Bad Sector$'
o  004A                     214 selmsg:	db	'Select$'
o  004A                     215 rofmsg:	db	'File '
o  004A                     216 rodmsg:	db	'R/O$'
                            217 
                            218 
   004A E5                  219 errflg:	push	hl		;report error to console, message address in HL
   004B CDrF0s00            220 	call	crlf		;stack mssg address, new line
   004E 3ArFCs01            221 	ld	a,(curdsk)
aq 0051                     222 	add	a,'A'
   0051 32r4As00            223 	ld	(dskerr),a	;current disk name
a  0054                     224 	ld	bc,dskmsg
   0054 CDrF6s00            225 	call	print		;the error message
   0057 C1                  226 	pop	bc
   0058 CDrF6s00            227 	call	print		;error mssage tail
                            228 ;	jp	conin		;to get the input character
                            229 				;(drop through to conin)
                            230 ;	ret
                            231 
                            232 
                            233 ;	console handlers
a  005B                     234 conin:	ld	hl,kbchar	;read console character to A
   005B 7E                  235 	ld	a,(hl)
a  005C                     236 	ld	(hl),0
   005C B7                  237 	or	a
   005D C0                  238 	ret	nz
                            239 				;no previous keyboard character ready
u  005E C3 00 00            240 	jp	coninf		;get character externally
                            241 ;	ret
   0061 CDr5Bs00            242 conech:	call	conin		;read character with echo
   0064 CDr6Fs00            243 	call	echoc
   0067 D8                  244 	ret	c		;echo character?
                            245 				;character must be echoed before return
   0068 F5                  246 	push	af
   0069 4F                  247 	ld	c,a
   006A CDrC8s00            248 	call	tabout
   006D F1                  249 	pop	af
   006E C9                  250 	ret			;with character in A
                            251 
   006F                     252 echoc:				;echo character if graphic
ua 006F                     253 	cp	cr		;cr, lf, tab, or backspace
   006F C8                  254 	ret	z		;carriage return?
ua 0070                     255 	cp	lf
   0070 C8                  256 	ret	z		;line feed?
ua 0071                     257 	cp	tab
   0071 C8                  258 	ret	z		;tab?
ua 0072                     259 	cp	ctlh
   0072 C8                  260 	ret	z		;backspace?
q  0073                     261 	cp	' '
   0073 C9                  262 	ret			;carry set if not graphic
                            263 
   0074                     264 conbrk:				;check for character ready
   0074 3ArFCs01            265 	ld	a,(kbchar)
   0077 B7                  266 	or	a
   0078 C2r90s00            267 	jp	nz,conb1	;skip if active kbchar
                            268 				;no active kbchar, check external break
u  007B CD 00 00            269 	call	constf
a  007E                     270 	and	1
   007E C8                  271 	ret	z		;return if no char ready
                            272 				;character ready, read it
u  007F CD 00 00            273 	call	coninf		;to A
ua 0082                     274 	cp	ctls
   0082 C2r8Ds00            275 	jp	nz,conb0	;check stop screen function
                            276 				;found ctls, read next character
u  0085 CD 00 00            277 	call	coninf		;to A
ua 0088                     278 	cp	ctlc
u  0088 CA 00 00            279 	jp	z,reboot	;ctlc implies re-boot
                            280 				;not a reboot, act as if nothing has happened
   008B AF                  281 	xor	a
   008C C9                  282 	ret			;with zero in accumulator
   008D                     283 conb0:
                            284 				;character in accum, save it
   008D 32rFCs01            285 	ld	(kbchar),a
   0090                     286 conb1:
                            287 				;return with true set in accumulator
a  0090                     288 	ld	a,1
   0090 C9                  289 	ret
                            290 
   0091                     291 conout:				;compute character position/write console char from C
                            292 				;compcol = true if computing column position
   0091 3ArFCs01            293 	ld	a,(compcol)
   0094 B7                  294 	or	a
   0095 C2rABs00            295 	jp	nz,compout
                            296 				;write the character, then compute the column
                            297 				;write console character from C
   0098 C5                  298 	push	bc
   0099 CDr74s00            299 	call	conbrk		;check for screen stop function
   009C C1                  300 	pop	bc
   009D C5                  301 	push	bc		;recall/save character
u  009E CD 00 00            302 	call	conoutf		;externally, to console
   00A1 C1                  303 	pop	bc
   00A2 C5                  304 	push	bc		;recall/save character
                            305 				;may be copying to the list device
   00A3 3ArFCs01            306 	ld	a,(listcp)
   00A6 B7                  307 	or	a
u  00A7 C4 00 00            308 	call	nz,listf	;to printer, if so
   00AA C1                  309 	pop	bc		;recall the character
   00AB                     310 compout:
   00AB 79                  311 	ld	a,c		;recall the character
                            312 				;and compute column position
a  00AC                     313 	ld	hl,column	;A = char, HL = .column
ua 00AC                     314 	cp	rubout
   00AC C8                  315 	ret	z		;no column change if nulls
   00AD 34                  316 	inc	(hl)		;column = column + 1
q  00AE                     317 	cp	' '
   00AE D0                  318 	ret	nc		;return if graphic
                            319 				;not graphic, reset column position
   00AF 35                  320 	dec	(hl)		;column = column - 1
   00B0 7E                  321 	ld	a,(hl)
   00B1 B7                  322 	or	a
   00B2 C8                  323 	ret	z		;return if at zero
                            324 				;not at zero, may be backspace or end line
   00B3 79                  325 	ld	a,c		;character back to A
ua 00B4                     326 	cp	ctlh
   00B4 C2rB9s00            327 	jp	nz,notbacksp
                            328 				;backspace character
   00B7 35                  329 	dec	(hl)		;column = column - 1
   00B8 C9                  330 	ret
                            331 
   00B9                     332 notbacksp:			;not a backspace character, eol?
ua 00B9                     333 	cp	lf
   00B9 C0                  334 	ret	nz		;return if not
                            335 				;end of line, column = 0
a  00BA                     336 	ld	(hl),0		;column = 0
   00BA C9                  337 	ret
                            338 
   00BB                     339 ctlout:				;send C character with possible preceding up-arrow
   00BB 79                  340 	ld	a,c
   00BC CDr6Fs00            341 	call	echoc		;cy if not graphic (or special case)
   00BF D2rC8s00            342 	jp	nc,tabout	;skip if graphic, tab, cr, lf, or ctlh
                            343 				;send preceding up arrow
   00C2 F5                  344 	push	af
ua 00C3                     345 	ld	c,ctl
   00C3 CDr91s00            346 	call	conout		;up arrow
   00C6 F1                  347 	pop	af
q  00C7                     348 	or	40h		;becomes graphic letter
   00C7 4F                  349 	ld	c,a		;ready to print
                            350 				;(drop through to tabout)
                            351 
   00C8                     352 tabout:				;expand tabs to console
   00C8 79                  353 	ld	a,c
ua 00C9                     354 	cp	tab
   00C9 C2r91s00            355 	jp	nz,conout	;direct to conout if not
                            356 				;tab encountered, move to next tab position
aq 00CC                     357 tab0:	ld	c,' '
   00CC CDr91s00            358 	call	conout		;another blank
   00CF 3ArFCs01            359 	ld	a,(column)
q  00D2                     360 	and	111b		;column mod 8 = 0 ?
   00D2 C2rCCs00            361 	jp	nz,tab0		;back for another if not
   00D5 C9                  362 	ret
                            363 
   00D6                     364 backup:				;back-up one screen position
   00D6 CDrDCs00            365 	call	pctlh
aq 00D9                     366 	ld	c,' '
u  00D9 CD 00 00            367 	call	conoutf
                            368 ;	(drop through to pctlh)
   00DC                     369 pctlh:				;send ctlh to console without affecting column count
ua 00DC                     370 	ld	c,ctlh
u  00DC C3 00 00            371 	jp	conoutf
                            372 ;	ret
   00DF                     373 crlfp:				;print #, cr, lf for ctlx, ctlu, ctlr functions
                            374 				;then move to strtcol (starting column)
aq 00DF                     375 	ld	c,'#'
   00DF CDr91s00            376 	call	conout
   00E2 CDrF0s00            377 	call	crlf		;column = 0, move to position strtcol
   00E5 3ArFCs01            378 crlfp0:	ld	a,(column)
a  00E8                     379 	ld	hl,strtcol
   00E8 BE                  380 	cp	(hl)
   00E9 D0                  381 	ret	nc		;stop when column reaches strtcol
aq 00EA                     382 	ld	c,' '
   00EA CDr91s00            383 	call	conout		;print blank
   00ED C3rE5s00            384 	jp	crlfp0
                            385 
ua 00F0                     386 crlf:	ld	c,cr		;carriage return line feed sequence
   00F0 CDr91s00            387 	call	conout
ua 00F3                     388 	ld	c,lf
   00F3 C3r91s00            389 	jp	conout
                            390 ;	ret
   00F6 0A                  391 print:	ld	a,(bc)		;print message until M(BC) = '$'
q  00F7                     392 	cp	'$'
   00F7 C8                  393 	ret	z		;stop on $
                            394 				;more to print
   00F8 03                  395 	inc	bc
   00F9 C5                  396 	push	bc
   00FA 4F                  397 	ld	c,a		;char to C
   00FB CDrC8s00            398 	call	tabout		;another character printed
   00FE C1                  399 	pop	bc
   00FF C3rF6s00            400 	jp	print
                            401 
   0102                     402 read:				;read to info address (max length, current length, buffer)
   0102 3ArFCs01            403 	ld	a,(column)
   0105 32rFCs01            404 	ld	(strtcol),a	;save start for ctl-x, ctl-h
   0108 2ArFCs01            405 	ld	hl,(info)
   010B 4E                  406 	ld	c,(hl)
   010C 23                  407 	inc	hl
   010D E5                  408 	push	hl
a  010E                     409 	ld	b,0
                            410 				;B = current buffer length,
                            411 				;C = maximum buffer length,
                            412 				;HL= next to fill - 1
   010E                     413 readnx:				;read next character, BC, HL active
   010E C5                  414 	push	bc
   010F E5                  415 	push	hl		;blen, cmax, HL saved
   0110 CDr5Bs00            416 readn0:	call	conin		;next char in A
q  0113                     417 	and	7fh		;mask parity bit
   0113 E1                  418 	pop	hl
   0114 C1                  419 	pop	bc		;reactivate counters
ua 0115                     420 	cp	cr
   0115 CArBAs01            421 	jp	z,readen	;end of line?
ua 0118                     422 	cp	lf
   0118 CArBAs01            423 	jp	z,readen	;also end of line
ua 011B                     424 	cp	ctlh
   011B C2r2Ds01            425 	jp	nz,noth		;backspace?
                            426 				;do we have any characters to back over?
   011E 78                  427 	ld	a,b
   011F B7                  428 	or	a
   0120 CAr0Es01            429 	jp	z,readnx
                            430 				;characters remain in buffer, backup one
   0123 05                  431 	dec	b		;remove one character
   0124 3ArFCs01            432 	ld	a,(column)
   0127 32rFCs01            433 	ld	(compcol),a	;col > 0
                            434 				;compcol > 0 marks repeat as length compute
   012A C3r73s01            435 	jp	linelen		;uses same code as repeat
                            436 
   012D                     437 noth:				;not a backspace
ua 012D                     438 	cp	rubout
   012D C2r3Bs01            439 	jp	nz,notrub	;rubout char?
                            440 				;rubout encountered, rubout if possible
   0130 78                  441 	ld	a,b
   0131 B7                  442 	or	a
   0132 CAr0Es01            443 	jp	z,readnx	;skip if len=0
                            444 				;buffer has characters, resend last char
   0135 7E                  445 	ld	a,(hl)
   0136 05                  446 	dec	b
   0137 2B                  447 	dec	hl		;A = last char
                            448 				;blen=blen-1, next to fill - 1 decremented
   0138 C3rA6s01            449 	jp	rdech1		;act like this is an echo
                            450 
   013B                     451 notrub:				;not a rubout character, check end line
ua 013B                     452 	cp	ctle
   013B C2r4As01            453 	jp	nz,note		;physical end line?
                            454 				;yes, save active counters and force eol
   013E C5                  455 	push	bc
   013F E5                  456 	push	hl
   0140 CDrF0s00            457 	call	crlf
   0143 AF                  458 	xor	a
   0144 32rFCs01            459 	ld	(strtcol),a	;start position = 00
   0147 C3r10s01            460 	jp	readn0		;for another character
                            461 
   014A                     462 note:				;not end of line, list toggle?
ua 014A                     463 	cp	ctlp
   014A C2r54s01            464 	jp	nz,notp		;skip if not ctlp
                            465 				;list toggle - change parity
   014D E5                  466 	push	hl		;save next to fill - 1
a  014E                     467 	ld	hl,listcp	;HL=.listcp flag
a  014E                     468 	ld	a,1
   014E 96                  469 	sub	(hl)		;True-listcp
   014F 77                  470 	ld	(hl),a		;listcp = not listcp
   0150 E1                  471 	pop	hl
   0151 C3r0Es01            472 	jp	readnx		;for another char
                            473 
   0154                     474 notp:				;not a ctlp, line delete?
ua 0154                     475 	cp	ctlx
   0154 C2r66s01            476 	jp	nz,notx
   0157 E1                  477 	pop	hl		;discard start position
                            478 				;loop while column > strtcol
   0158 3ArFCs01            479 backx:	ld	a,(strtcol)
a  015B                     480 	ld	hl,column
   015B BE                  481 	cp	(hl)
   015C D2r02s01            482 	jp	nc,read		;start again
   015F 35                  483 	dec	(hl)		;column = column - 1
   0160 CDrD6s00            484 	call	backup		;one position
   0163 C3r58s01            485 	jp	backx
                            486 
   0166                     487 notx:				;not a control x, control u?
                            488 				;not control-X, control-U?
ua 0166                     489 	cp	ctlu
   0166 C2r70s01            490 	jp	nz,notu		;skip if not
                            491 				;delete line (ctlu)
   0169 CDrDFs00            492 	call	crlfp		;physical eol
   016C E1                  493 	pop	hl		;discard starting position
   016D C3r02s01            494 	jp	read		;to start all over
                            495 
   0170                     496 notu:				;not line delete, repeat line?
ua 0170                     497 	cp	ctlr
   0170 C2rA3s01            498 	jp	nz,notr
   0173                     499 linelen:			;repeat line, or compute line len (ctlh)
                            500 				;if compcol > 0
   0173 C5                  501 	push	bc
   0174 CDrDFs00            502 	call	crlfp		;save line length
   0177 C1                  503 	pop	bc
   0178 E1                  504 	pop	hl
   0179 E5                  505 	push	hl
   017A C5                  506 	push	bc
                            507 				;bcur, cmax active, beginning buff at HL
   017B 78                  508 rep0:	ld	a,b
   017C B7                  509 	or	a
   017D CAr8Ds01            510 	jp	z,rep1		;count len to 00
   0180 23                  511 	inc	hl
   0181 4E                  512 	ld	c,(hl)		;next to print
   0182 05                  513 	dec	b
   0183 C5                  514 	push	bc
   0184 E5                  515 	push	hl		;count length down
   0185 CDrBBs00            516 	call	ctlout		;character echoed
   0188 E1                  517 	pop	hl
   0189 C1                  518 	pop	bc		;recall remaining count
   018A C3r7Bs01            519 	jp	rep0		;for the next character
                            520 
   018D                     521 rep1:				;end of repeat, recall lengths
                            522 				;original BC still remains pushed
   018D E5                  523 	push	hl		;save next to fill
   018E 3ArFCs01            524 	ld	a,(compcol)
   0191 B7                  525 	or	a		;>0 if computing length
   0192 CAr10s01            526 	jp	z,readn0	;for another char if so
                            527 				;column position computed for ctlh
a  0195                     528 	ld	hl,column
   0195 96                  529 	sub	(hl)		;diff > 0
   0196 32rFCs01            530 	ld	(compcol),a	;count down below
                            531 				;move back compcol-column spaces
   0199                     532 backsp:				;move back one more space
   0199 CDrD6s00            533 	call	backup		;one space
a  019C                     534 	ld	hl,compcol
   019C 35                  535 	dec	(hl)
   019D C2r99s01            536 	jp	nz,backsp
   01A0 C3r10s01            537 	jp	readn0		;for next character
                            538 
   01A3                     539 notr:				;not a ctlr, place into buffer
   01A3 23                  540 rdecho:	inc	hl
   01A4 77                  541 	ld	(hl),a		;character filled to mem
   01A5 04                  542 	inc	b		;blen = blen + 1
   01A6                     543 rdech1:				;look for a random control character
   01A6 C5                  544 	push	bc
   01A7 E5                  545 	push	hl		;active values saved
   01A8 4F                  546 	ld	c,a		;ready to print
   01A9 CDrBBs00            547 	call	ctlout		;may be up-arrow C
   01AC E1                  548 	pop	hl
   01AD C1                  549 	pop	bc
   01AE 7E                  550 	ld	a,(hl)		;recall char
ua 01AF                     551 	cp	ctlc		;set flags for reboot test
   01AF 78                  552 	ld	a,b		;move length to A
   01B0 C2rB6s01            553 	jp	nz,notc		;skip if not a control c
a  01B3                     554 	cp	1		;control C, must be length 1
u  01B3 CA 00 00            555 	jp	z,reboot	;reboot if blen = 1
                            556 				;length not one, so skip reboot
   01B6                     557 notc:				;not reboot, are we at end of buffer?
   01B6 B9                  558 	cp	c
   01B7 DAr0Es01            559 	jp	c,readnx	;go for another if not
   01BA                     560 readen:				;end of read operation, store blen
   01BA E1                  561 	pop	hl
   01BB 70                  562 	ld	(hl),b		;M(current len) = B
ua 01BC                     563 	ld	c,cr
   01BC C3r91s00            564 	jp	conout		;return carriage
                            565 ;	ret
   01BF                     566 func1:				;return console character with echo
   01BF CDr61s00            567 	call	conech
   01C2 C3rF5s01            568 	jp	sta$ret
                            569 
o  01C5                     570 func2	equ	tabout
                            571 				;write console character with tab expansion
                            572 
   01C5                     573 func3:				;return reader character
u  01C5 CD 00 00            574 	call	readerf
   01C8 C3rF5s01            575 	jp	sta$ret
                            576 
                            577 ;func4:	equated to punchf
                            578 				;write punch character
                            579 
                            580 ;func5:	equated to listf
                            581 				;write list character
                            582 				;write to list device
                            583 
   01CB                     584 func6:				;direct console i/o - read if 0ffh
   01CB 79                  585 	ld	a,c
   01CC 3C                  586 	inc	a
   01CD CArD7s01            587 	jp	z,dirinp	;0ffh => 00h, means input mode
   01D0 3C                  588 	inc	a
u  01D1 CA 00 00            589 	jp	z,constf	;0feH in C for status
                            590 				;direct output function
u  01D4 C3 00 00            591 	jp	conoutf
                            592 
u  01D7 CD 00 00            593 dirinp:	call	constf		;status check
   01DA B7                  594 	or	a
   01DB CArAFs0A            595 	jp	z,retmon	;skip, return 00 if not ready
                            596 				;character is ready, get it
u  01DE CD 00 00            597 	call	coninf		;to A
   01E1 C3rF5s01            598 	jp	sta$ret
                            599 
   01E4                     600 func7:				;return io byte
u  01E4 3A 00 00            601 	ld	a,(ioloc)
   01E7 C3rF5s01            602 	jp	sta$ret
                            603 
   01EA                     604 func8:				;set i/o byte
ua 01EA                     605 	ld	hl,ioloc
   01EA 71                  606 	ld	(hl),c
   01EB C9                  607 	ret			;jmp goback
                            608 
   01EC                     609 func9:				;write line until $ encountered
   01EC EB                  610 	ex	de,hl		;was lhld info
   01ED 4D                  611 	ld	c,l
   01EE 44                  612 	ld	b,h		;BC=string address
   01EF C3rF6s00            613 	jp	print		;out to console
                            614 
o  01F2                     615 func10	equ	read
                            616 				;read a buffered console line
                            617 
   01F2                     618 func11:				;check console status
   01F2 CDr74s00            619 	call	conbrk
                            620 				;(drop through to sta$ret)
   01F5                     621 sta$ret:			;store the A register to aret
   01F5 32rFCs01            622 	ld	(aret),a
   01F8                     623 func$ret:
   01F8 C9                  624 	ret			;jmp goback (pop stack for non cp/m functions)
                            625 
   01F9                     626 setlret1:			;set lret = 1
a  01F9                     627 	ld	a,1
   01F9 C3rF5s01            628 	jp	sta$ret
                            629 
                            630 
                            631 
                            632 ;	data areas
                            633 
   01FC                     634 compcol:
o  01FC                     635 	db	0		;true if computing column position
   01FC                     636 strtcol:
o  01FC                     637 	db	0		;starting column position after read
o  01FC                     638 column:	db	0		;column position
o  01FC                     639 listcp:	db	0		;listing toggle
o  01FC                     640 kbchar:	db	0		;initial key char = 00
o  01FC                     641 entsp:	ds	2		;entry stack pointer
o  01FC                     642 	ds	ssize*2		;stack size
   01FC                     643 lstack:
                            644 ;	end of Basic I/O System
                            645 
                            646 ;*****************************************************************
                            647 ;*****************************************************************
                            648 
                            649 ;	common values shared between bdosi and bdos
   01FC                     650 usrcode:
o  01FC                     651 	db	0		;current user number
o  01FC                     652 curdsk:	db	0		;current disk number
o  01FC                     653 info:	ds	2		;information address
o  01FC                     654 aret:	ds	2		;address value to return
o  01FC                     655 lret	equ	aret		;low(aret)
                            656 
                            657 ;*****************************************************************
                            658 ;*****************************************************************
                            659 ;**                                                             **
                            660 ;**   B a s i c    D i s k   O p e r a t i n g   S y s t e m    **
                            661 ;**                                                             **
                            662 ;*****************************************************************
                            663 ;*****************************************************************
                            664 
o  01FC                     665 dvers	equ	22h		;version 2.2
                            666 ;	module addresses
                            667 
                            668 ;	literal constants
o  01FC                     669 true	equ	0ffh		;constant true
o  01FC                     670 false	equ	000h		;constant false
o  01FC                     671 enddir	equ	0ffffh		;end of directory
o  01FC                     672 byte	equ	1		;number of bytes for "byte" type
o  01FC                     673 word	equ	2		;number of bytes for "word" type
                            674 
                            675 ;	fixed addresses in low memory
o  01FC                     676 tfcb	equ	005ch		;default fcb location
o  01FC                     677 tbuff	equ	0080h		;default buffer location
                            678 
                            679 ;	fixed addresses referenced in bios module are
                            680 ;	pererr (0009), selerr (000c), roderr (000f)
                            681 
                            682 ;	error message handlers
                            683 
                            684 ;per$error:			;report permanent error to user
                            685 ;	ld	hl,pererr
                            686 ;	jp	goerr
                            687 
                            688 ;rod$error:			;report read/only disk error
                            689 ;	ld	hl,roderr
                            690 ;	jp	goerr
                            691 
                            692 ;rof$error:			;report read/only file error
                            693 ;	ld	hl,roferr
                            694 ;	jp	goerr
                            695 
   01FC                     696 sel$error:			;report select error
a  01FC                     697 	ld	hl,selerr
                            698 
                            699 
   01FC                     700 goerr:				;HL = .errorhandler, call subroutine
   01FC 5E                  701 	ld	e,(hl)
   01FD 23                  702 	inc	hl
   01FE 56                  703 	ld	d,(hl)		;address of routine in DE
   01FF EB                  704 	ex	de,hl
   0200 E9                  705 	jp	(hl)		;to subroutine
                            706 
                            707 
                            708 
                            709 ;	local subroutines for bios interface
                            710 
   0201                     711 move:				;move data length of length C from source DE to
                            712 				;destination given by HL
   0201 0C                  713 	inc	c		;in case it is zero
   0202 0D                  714 move0:	dec	c
   0203 C8                  715 	ret	z		;more to move
   0204 1A                  716 	ld	a,(de)
   0205 77                  717 	ld	(hl),a		;one byte moved
   0206 13                  718 	inc	de
   0207 23                  719 	inc	hl		;to next byte
   0208 C3r02s02            720 	jp	move0
                            721 
   020B                     722 selectdisk:			;select the disk drive given by curdsk, and fill
                            723 				;the base addresses curtrka - alloca, then fill
                            724 				;the values of the disk parameter block
   020B 3ArFCs01            725 	ld	a,(curdsk)
   020E 4F                  726 	ld	c,a		;current disk# to c
                            727 				;lsb of e = 0 if not yet logged - in
u  020F CD 00 00            728 	call	seldskf		;HL filled by call
                            729 				;HL = 0000 if error, otherwise disk headers
   0212 7C                  730 	ld	a,h
   0213 B5                  731 	or	l
   0214 C8                  732 	ret	z		;return with 0000 in HL and z flag
                            733 				;disk header block address in hl
   0215 5E                  734 	ld	e,(hl)
   0216 23                  735 	inc	hl
   0217 56                  736 	ld	d,(hl)
   0218 23                  737 	inc	hl		;DE=.tran
   0219 22rC6s0A            738 	ld	(cdrmaxa),hl
   021C 23                  739 	inc	hl
   021D 23                  740 	inc	hl		;.cdrmax
   021E 22rC6s0A            741 	ld	(curtrka),hl
   0221 23                  742 	inc	hl
   0222 23                  743 	inc	hl		;HL=.currec
   0223 22rC6s0A            744 	ld	(curreca),hl
   0226 23                  745 	inc	hl
   0227 23                  746 	inc	hl		;HL=.buffa
                            747 				;DE still contains .tran
   0228 EB                  748 	ex	de,hl
   0229 22rC6s0A            749 	ld	(tranv),hl	;.tran vector
a  022C                     750 	ld	hl,buffa	;DE= source for move, HL=dest
ua 022C                     751 	ld	c,addlist
   022C CDr01s02            752 	call	move		;addlist filled
                            753 				;now fill the disk parameter block
   022F 2ArC6s0A            754 	ld	hl,(dpbaddr)
   0232 EB                  755 	ex	de,hl		;DE is source
a  0233                     756 	ld	hl,sectpt	;HL is destination
ua 0233                     757 	ld	c,dpblist
   0233 CDr01s02            758 	call	move		;data filled
                            759 				;now set single/double map mode
   0236 2ArC6s0A            760 	ld	hl,(maxall)	;largest allocation number
   0239 7C                  761 	ld	a,h		;00 indicates < 255
a  023A                     762 	ld	hl,single
ua 023A                     763 	ld	(hl),true	;assume a=00
   023A B7                  764 	or	a
   023B CAr3Es02            765 	jp	z,retselect
                            766 				;high order of maxall not zero, use double dm
ua 023E                     767 	ld	(hl),false
   023E                     768 retselect:
ua 023E                     769 	ld	a,true
   023E B7                  770 	or	a
   023F C9                  771 	ret			;select disk function ok
                            772 
   0240                     773 home:				;move to home position, then offset to start of dir
u  0240 CD 00 00            774 	call	homef		;move to track 00, sector 00 reference
                            775 				;lxi h,offset ;mov c,m ;inx h ;mov b,m ;call settrkf
                            776 				;first directory position selected
   0243 AF                  777 	xor	a		;constant zero to accumulator
   0244 2ArC6s0A            778 	ld	hl,(curtrka)
   0247 77                  779 	ld	(hl),a
   0248 23                  780 	inc	hl
   0249 77                  781 	ld	(hl),a		;curtrk=0000
   024A 2ArC6s0A            782 	ld	hl,(curreca)
   024D 77                  783 	ld	(hl),a
   024E 23                  784 	inc	hl
   024F 77                  785 	ld	(hl),a		;currec=0000
                            786 				;curtrk, currec both set to 0000
   0250 C9                  787 	ret
                            788 
   0251                     789 rdbuff:				;read buffer and check condition
u  0251 CD 00 00            790 	call	readf		;current drive, track, sector, dma
   0254 C3r5As02            791 	jp	diocomp		;check for i/o errors
                            792 
   0257                     793 wrbuff:				;write buffer and check condition
                            794 				;write type (wrtype) is in register C
                            795 				;wrtype = 0 => normal write operation
                            796 				;wrtype = 1 => directory write operation
                            797 				;wrtype = 2 => start of new block
u  0257 CD 00 00            798 	call	writef		;current drive, track, sector, dma
   025A                     799 diocomp:			;check for disk errors
   025A B7                  800 	or	a
   025B C8                  801 	ret	z
a  025C                     802 	ld	hl,pererr
   025C C3rFCs01            803 	jp	goerr
                            804 
   025F                     805 seek$dir:			;seek the record containing the current dir entry
   025F 2ArC6s0A            806 	ld	hl,(dcnt)	;directory counter to HL
ua 0262                     807 	ld	c,dskshf
   0262 CDr6As03            808 	call	hlrotr		;value to HL
   0265 22rC6s0A            809 	ld	(arecord),hl
   0268 22rC6s0A            810 	ld	(drec),hl	;ready for seek
                            811 ;	jp	seek
                            812 ;	ret
                            813 
                            814 
   026B                     815 seek:				;seek the track given by arecord (actual record)
                            816 				;local equates for registers
                            817 				;load the registers from memory
a  026B                     818 	ld	hl,arecord
   026B 4E                  819 	ld	c,(hl)
   026C 23                  820 	inc	hl
   026D 46                  821 	ld	b,(hl)
   026E 2ArC6s0A            822 	ld	hl,(curreca)
   0271 5E                  823 	ld	e,(hl)
   0272 23                  824 	inc	hl
   0273 56                  825 	ld	d,(hl)
   0274 2ArC6s0A            826 	ld	hl,(curtrka)
   0277 7E                  827 	ld	a,(hl)
   0278 23                  828 	inc	hl
   0279 66                  829 	ld	h,(hl)
   027A 6F                  830 	ld	l,a
                            831 				;loop while arecord < currec
   027B 79                  832 seek0:	ld	a,c
   027C 93                  833 	sub	e
   027D 78                  834 	ld	a,b
   027E 9A                  835 	sbc	a,d
   027F D2r91s02            836 	jp	nc,seek1	;skip if arecord >= currec
                            837 				;currec = currec - sectpt
   0282 E5                  838 	push	hl
   0283 2ArC6s0A            839 	ld	hl,(sectpt)
   0286 7B                  840 	ld	a,e
   0287 95                  841 	sub	l
   0288 5F                  842 	ld	e,a
   0289 7A                  843 	ld	a,d
   028A 9C                  844 	sbc	a,h
   028B 57                  845 	ld	d,a
   028C E1                  846 	pop	hl
                            847 				;curtrk = curtrk - 1
   028D 2B                  848 	dec	hl
   028E C3r7Bs02            849 	jp	seek0		;for another try
                            850 
   0291                     851 seek1:				;look while arecord >= (t:=currec + sectpt)
   0291 E5                  852 	push	hl
   0292 2ArC6s0A            853 	ld	hl,(sectpt)
   0295 19                  854 	add	hl,de		;HL = currec+sectpt
   0296 DArA6s02            855 	jp	c,seek2		;can be > FFFFH
   0299 79                  856 	ld	a,c
   029A 95                  857 	sub	l
   029B 78                  858 	ld	a,b
   029C 9C                  859 	sbc	a,h
   029D DArA6s02            860 	jp	c,seek2		;skip if t > arecord
                            861 				;currec = t
   02A0 EB                  862 	ex	de,hl
                            863 				;curtrk = curtrk + 1
   02A1 E1                  864 	pop	hl
   02A2 23                  865 	inc	hl
   02A3 C3r91s02            866 	jp	seek1		;for another try
                            867 
   02A6 E1                  868 seek2:	pop	hl
                            869 				;arrive here with updated values in each register
   02A7 C5                  870 	push	bc
   02A8 D5                  871 	push	de
   02A9 E5                  872 	push	hl		;to stack for later
                            873 				;stack contains (lowest) BC=arecord, DE=currec, HL=curtrk
   02AA EB                  874 	ex	de,hl
   02AB 2ArC6s0A            875 	ld	hl,(offset)
   02AE 19                  876 	add	hl,de		;HL = curtrk+offset
   02AF 44                  877 	ld	b,h
   02B0 4D                  878 	ld	c,l
u  02B1 CD 00 00            879 	call	settrkf		;track set up
                            880 				;note that BC - curtrk is difference to move in bios
   02B4 D1                  881 	pop	de		;recall curtrk
   02B5 2ArC6s0A            882 	ld	hl,(curtrka)
   02B8 73                  883 	ld	(hl),e
   02B9 23                  884 	inc	hl
   02BA 72                  885 	ld	(hl),d		;curtrk updated
                            886 				;now compute sector as arecord-currec
   02BB D1                  887 	pop	de		;recall currec
   02BC 2ArC6s0A            888 	ld	hl,(curreca)
   02BF 73                  889 	ld	(hl),e
   02C0 23                  890 	inc	hl
   02C1 72                  891 	ld	(hl),d
   02C2 C1                  892 	pop	bc		;BC=arecord, DE=currec
   02C3 79                  893 	ld	a,c
   02C4 93                  894 	sub	e
   02C5 4F                  895 	ld	c,a
   02C6 78                  896 	ld	a,b
   02C7 9A                  897 	sbc	a,d
   02C8 47                  898 	ld	b,a
   02C9 2ArC6s0A            899 	ld	hl,(tranv)
   02CC EB                  900 	ex	de,hl		;BC=sector#, DE=.tran
u  02CD CD 00 00            901 	call	sectran		;HL = tran(sector)
   02D0 4D                  902 	ld	c,l
   02D1 44                  903 	ld	b,h		;BC = tran(sector)
u  02D2 C3 00 00            904 	jp	setsecf		;sector selected
                            905 ;	ret
                            906 
                            907 ;	file control block (fcb) constants
o  02D5                     908 empty	equ	0e5h		;empty directory entry
o  02D5                     909 lstrec	equ	127		;last record# in extent
o  02D5                     910 recsiz	equ	128		;record size
o  02D5                     911 fcblen	equ	32		;file control block size
o  02D5                     912 dirrec	equ	recsiz/fcblen	;directory elts / record
o  02D5                     913 dskshf	equ	2		;log2(dirrec)
o  02D5                     914 dskmsk	equ	dirrec-1
o  02D5                     915 fcbshf	equ	5		;log2(fcblen)
                            916 
o  02D5                     917 extnum	equ	12		;extent number field
o  02D5                     918 maxext	equ	31		;largest extent number
o  02D5                     919 ubytes	equ	13		;unfilled bytes field
o  02D5                     920 modnum	equ	14		;data module number
o  02D5                     921 maxmod	equ	15		;largest module number
o  02D5                     922 fwfmsk	equ	80h		;file write flag is high order modnum
o  02D5                     923 namlen	equ	15		;name length
o  02D5                     924 reccnt	equ	15		;record count field
o  02D5                     925 dskmap	equ	16		;disk map field
o  02D5                     926 lstfcb	equ	fcblen-1
o  02D5                     927 nxtrec	equ	fcblen
o  02D5                     928 ranrec	equ	nxtrec+1	;random record field (2 bytes)
                            929 
                            930 ;	reserved file indicators
o  02D5                     931 rofile	equ	9		;high order of first type char
o  02D5                     932 invis	equ	10		;invisible file in dir command
                            933 ;	equ	11		;reserved
                            934 
                            935 ;	utility functions for file access
                            936 
   02D5                     937 dm$position:			;compute disk map position for vrecord to HL
a  02D5                     938 	ld	hl,blkshf
   02D5 4E                  939 	ld	c,(hl)		;shift count to C
   02D6 3ArC6s0A            940 	ld	a,(vrecord)	;current virtual record to A
   02D9 B7                  941 dmpos0:	or	a
   02DA 1F                  942 	rra
   02DB 0D                  943 	dec	c
   02DC C2rD9s02            944 	jp	nz,dmpos0
                            945 				;A = shr(vrecord,blkshf) = vrecord/2**(sect/block)
   02DF 47                  946 	ld	b,a		;save it for later addition
a  02E0                     947 	ld	a,8
   02E0 96                  948 	sub	(hl)		;8-blkshf to accumulator
   02E1 4F                  949 	ld	c,a		;extent shift count in register c
   02E2 3ArC6s0A            950 	ld	a,(extval)	;extent value ani extmsk
   02E5                     951 dmpos1:
                            952 				;blkshf = 3,4,5,6,7, C=5,4,3,2,1
                            953 				;shift is 4,3,2,1,0
   02E5 0D                  954 	dec	c
   02E6 CArEEs02            955 	jp	z,dmpos2
   02E9 B7                  956 	or	a
   02EA 17                  957 	rla
   02EB C3rE5s02            958 	jp	dmpos1
                            959 
   02EE                     960 dmpos2:				;arrive here with A = shl(ext and extmsk,7-blkshf)
   02EE 80                  961 	add	a,b		;add the previous shr(vrecord,blkshf) value
                            962 				;A is one of the following values, depending upon alloc
                            963 				;bks blkshf
                            964 				;1k   3     v/8 + extval * 16
                            965 				;2k   4     v/16+ extval * 8
                            966 				;4k   5     v/32+ extval * 4
                            967 				;8k   6     v/64+ extval * 2
                            968 				;16k  7     v/128+extval * 1
   02EF C9                  969 	ret			;with dm$position in A
                            970 
   02F0                     971 getdm:				;return disk map value from position given by BC
   02F0 2ArFCs01            972 	ld	hl,(info)	;base address of file control block
ua 02F3                     973 	ld	de,dskmap
   02F3 19                  974 	add	hl,de		;HL =.diskmap
   02F4 09                  975 	add	hl,bc		;index by a single byte value
   02F5 3ArC6s0A            976 	ld	a,(single)	;single byte/map entry?
   02F8 B7                  977 	or	a
   02F9 CArFEs02            978 	jp	z,getdmd	;get disk map single byte
   02FC 6E                  979 	ld	l,(hl)
a  02FD                     980 	ld	h,0
   02FD C9                  981 	ret			;with HL=00bb
   02FE                     982 getdmd:
   02FE 09                  983 	add	hl,bc		;HL=.fcb(dm+i*2)
                            984 				;double precision value returned
   02FF 5E                  985 	ld	e,(hl)
   0300 23                  986 	inc	hl
   0301 56                  987 	ld	d,(hl)
   0302 EB                  988 	ex	de,hl
   0303 C9                  989 	ret
                            990 
   0304                     991 index:				;compute disk block number from current fcb
   0304 CDrD5s02            992 	call	dm$position	;0...15 in register A
   0307 4F                  993 	ld	c,a
a  0308                     994 	ld	b,0
   0308 CDrF0s02            995 	call	getdm		;value to HL
   030B 22rC6s0A            996 	ld	(arecord),hl
   030E C9                  997 	ret
                            998 
   030F                     999 allocated:			;called following index to see if block allocated
   030F 2ArC6s0A           1000 	ld	hl,(arecord)
   0312 7D                 1001 	ld	a,l
   0313 B4                 1002 	or	h
   0314 C9                 1003 	ret
                           1004 
   0315                    1005 atran:				;compute actual record address, assuming index called
   0315 3ArC6s0A           1006 	ld	a,(blkshf)	;shift count to reg A
   0318 2ArC6s0A           1007 	ld	hl,(arecord)
   031B 29                 1008 atran0:	add	hl,hl
   031C 3D                 1009 	dec	a
   031D C2r1Bs03           1010 	jp	nz,atran0	;shl(arecord,blkshf)
   0320 22rC6s0A           1011 	ld	(arecord1),hl	;save shifted block #
   0323 3ArC6s0A           1012 	ld	a,(blkmsk)
   0326 4F                 1013 	ld	c,a		;mask value to C
   0327 3ArC6s0A           1014 	ld	a,(vrecord)
   032A A1                 1015 	and	c		;masked value in A
   032B B5                 1016 	or	l
   032C 6F                 1017 	ld	l,a		;to HL
   032D 22rC6s0A           1018 	ld	(arecord),hl	;arecord=HL or (vrecord and blkmsk)
   0330 C9                 1019 	ret
                           1020 
   0331                    1021 getexta:			;get current extent field address to A
   0331 2ArFCs01           1022 	ld	hl,(info)
ua 0334                    1023 	ld	de,extnum
   0334 19                 1024 	add	hl,de		;HL=.fcb(extnum)
   0335 C9                 1025 	ret
                           1026 
   0336                    1027 getfcba:			;compute reccnt and nxtrec addresses for get/setfcb
   0336 2ArFCs01           1028 	ld	hl,(info)
ua 0339                    1029 	ld	de,reccnt
   0339 19                 1030 	add	hl,de
   033A EB                 1031 	ex	de,hl		;DE=.fcb(reccnt)
ua 033B                    1032 	ld	hl,nxtrec-reccnt
   033B 19                 1033 	add	hl,de		;HL=.fcb(nxtrec)
   033C C9                 1034 	ret
                           1035 
   033D                    1036 getfcb:				;set variables from currently addressed fcb
   033D CDr36s03           1037 	call	getfcba		;addresses in DE, HL
   0340 7E                 1038 	ld	a,(hl)
   0341 32rC6s0A           1039 	ld	(vrecord),a	;vrecord=fcb(nxtrec)
   0344 EB                 1040 	ex	de,hl
   0345 7E                 1041 	ld	a,(hl)
   0346 32rC6s0A           1042 	ld	(rcount),a	;rcount=fcb(reccnt)
   0349 CDr31s03           1043 	call	getexta		;HL=.fcb(extnum)
   034C 3ArC6s0A           1044 	ld	a,(extmsk)	;extent mask to a
   034F A6                 1045 	and	(hl)		;fcb(extnum) and extmsk
   0350 32rC6s0A           1046 	ld	(extval),a
   0353 C9                 1047 	ret
                           1048 
   0354                    1049 setfcb:				;place values back into current fcb
   0354 CDr36s03           1050 	call	getfcba		;addresses to DE, HL
   0357 3ArC6s0A           1051 	ld	a,(seqio)
a  035A                    1052 	cp	02
   035A C2r5Es03           1053 	jp	nz,setfcb1
   035D AF                 1054 	xor	a		;check ranfill
   035E                    1055 setfcb1:
   035E 4F                 1056 	ld	c,a		;=1 if sequential i/o
   035F 3ArC6s0A           1057 	ld	a,(vrecord)
   0362 81                 1058 	add	a,c
   0363 77                 1059 	ld	(hl),a		;fcb(nxtrec)=vrecord+seqio
   0364 EB                 1060 	ex	de,hl
   0365 3ArC6s0A           1061 	ld	a,(rcount)
   0368 77                 1062 	ld	(hl),a		;fcb(reccnt)=rcount
   0369 C9                 1063 	ret
                           1064 
   036A                    1065 hlrotr:				;hl rotate right by amount C
   036A 0C                 1066 	inc	c		;in case zero
   036B                    1067 hlrotr0:
   036B 0D                 1068 	dec	c
   036C C8                 1069 	ret	z		;return when zero
   036D 7C                 1070 	ld	a,h
   036E B7                 1071 	or	a
   036F 1F                 1072 	rra
   0370 67                 1073 	ld	h,a		;high byte
   0371 7D                 1074 	ld	a,l
   0372 1F                 1075 	rra
   0373 6F                 1076 	ld	l,a		;low byte
   0374 C3r6Bs03           1077 	jp	hlrotr0
                           1078 
   0377                    1079 compute$cs:			;compute checksum for current directory buffer
ua 0377                    1080 	ld	c,recsiz	;size of directory buffer
   0377 2ArC6s0A           1081 	ld	hl,(buffa)	;current directory buffer
   037A AF                 1082 	xor	a		;clear checksum value
   037B                    1083 computecs0:
   037B 86                 1084 	add	a,(hl)
   037C 23                 1085 	inc	hl
   037D 0D                 1086 	dec	c		;cs=cs+buff(recsiz-C)
   037E C2r7Bs03           1087 	jp	nz,computecs0
   0381 C9                 1088 	ret			;with checksum in A
                           1089 
   0382                    1090 hlrotl:				;rotate the mask in HL by amount in C
   0382 0C                 1091 	inc	c		;may be zero
   0383                    1092 hlrotl0:
   0383 0D                 1093 	dec	c
   0384 C8                 1094 	ret	z		;return if zero
   0385 29                 1095 	add	hl,hl
   0386 C3r83s03           1096 	jp	hlrotl0
                           1097 
   0389                    1098 set$cdisk:			;set a "1" value in curdsk position of BC
   0389 C5                 1099 	push	bc		;save input parameter
   038A 3ArFCs01           1100 	ld	a,(curdsk)
   038D 4F                 1101 	ld	c,a		;ready parameter for shift
a  038E                    1102 	ld	hl,1		;number to shift
   038E CDr82s03           1103 	call	hlrotl		;HL = mask to integrate
   0391 C1                 1104 	pop	bc		;original mask
   0392 79                 1105 	ld	a,c
   0393 B5                 1106 	or	l
   0394 6F                 1107 	ld	l,a
   0395 78                 1108 	ld	a,b
   0396 B4                 1109 	or	h
   0397 67                 1110 	ld	h,a		;HL = mask or rol(1,curdsk)
   0398 C9                 1111 	ret
                           1112 
   0399                    1113 nowrite:			;return true if dir checksum difference occurred
   0399 2ArC6s0A           1114 	ld	hl,(rodsk)
   039C 3ArFCs01           1115 	ld	a,(curdsk)
   039F 4F                 1116 	ld	c,a
   03A0 CDr6As03           1117 	call	hlrotr
   03A3 7D                 1118 	ld	a,l
q  03A4                    1119 	and	1b
   03A4 C9                 1120 	ret			;non zero if nowrite
                           1121 
   03A5                    1122 set$ro:				;set current disk to read only
a  03A5                    1123 	ld	hl,rodsk
   03A5 4E                 1124 	ld	c,(hl)
   03A6 23                 1125 	inc	hl
   03A7 46                 1126 	ld	b,(hl)
   03A8 CDr89s03           1127 	call	set$cdisk	;sets bit to 1
   03AB 22rC6s0A           1128 	ld	(rodsk),hl
                           1129 				;high water mark in directory goes to max
   03AE 2ArC6s0A           1130 	ld	hl,(dirmax)
   03B1 23                 1131 	inc	hl
   03B2 EB                 1132 	ex	de,hl		;DE = directory max
   03B3 2ArC6s0A           1133 	ld	hl,(cdrmaxa)	;HL = .cdrmax
   03B6 73                 1134 	ld	(hl),e
   03B7 23                 1135 	inc	hl
   03B8 72                 1136 	ld	(hl),d		;cdrmax = dirmax
   03B9 C9                 1137 	ret
                           1138 
   03BA                    1139 check$rodir:			;check current directory element for read/only status
   03BA CDrCBs03           1140 	call	getdptra	;address of element
                           1141 
   03BD                    1142 check$rofile:			;check current buff(dptr) or fcb(0) for r/o status
ua 03BD                    1143 	ld	de,rofile
   03BD 19                 1144 	add	hl,de		;offset to ro bit
   03BE 7E                 1145 	ld	a,(hl)
   03BF 17                 1146 	rla
   03C0 D0                 1147 	ret	nc		;return if not set
a  03C1                    1148 	ld	hl,roferr
   03C1 C3rFCs01           1149 	jp	goerr
                           1150 ;	jp	rof$error 	;exit to read only disk message
                           1151 
                           1152 
   03C4                    1153 check$write:			;check for write protected disk
   03C4 CDr99s03           1154 	call	nowrite
   03C7 C8                 1155 	ret	z		;ok to write if not rodsk
a  03C8                    1156 	ld	hl,roderr
   03C8 C3rFCs01           1157 	jp	goerr
                           1158 ;	jp	rod$error	;read only disk error
                           1159 
   03CB                    1160 getdptra:			;compute the address of a directory element at
                           1161 				;positon dptr in the buffer
   03CB 2ArC6s0A           1162 	ld	hl,(buffa)
   03CE 3ArC6s0A           1163 	ld	a,(dptr)
   03D1                    1164 addh:				;HL = HL + A
   03D1 85                 1165 	add	a,l
   03D2 6F                 1166 	ld	l,a
   03D3 D0                 1167 	ret	nc
                           1168 				;overflow to H
   03D4 24                 1169 	inc	h
   03D5 C9                 1170 	ret
                           1171 
                           1172 
   03D6                    1173 getmodnum:			;compute the address of the module number
                           1174 				;bring module number to accumulator
                           1175 				;(high order bit is fwf (file write flag)
   03D6 2ArFCs01           1176 	ld	hl,(info)
ua 03D9                    1177 	ld	de,modnum
   03D9 19                 1178 	add	hl,de		;HL=.fcb(modnum)
   03DA 7E                 1179 	ld	a,(hl)
   03DB C9                 1180 	ret			;A=fcb(modnum)
                           1181 
   03DC                    1182 clrmodnum:			;clear the module number field for user open/make
   03DC CDrD6s03           1183 	call	getmodnum
a  03DF                    1184 	ld	(hl),0		;fcb(modnum)=0
   03DF C9                 1185 	ret
                           1186 
   03E0 CDrD6s03           1187 setfwf:	call	getmodnum	;HL=.fcb(modnum), A=fcb(modnum)
                           1188 				;set fwf (file write flag) to "1"
ua 03E3                    1189 	or	fwfmsk
   03E3 77                 1190 	ld	(hl),a		;fcb(modnum)=fcb(modnum) or 80h
                           1191 				;also returns non zero in accumulator
   03E4 C9                 1192 	ret
                           1193 
                           1194 
   03E5                    1195 compcdr:			;return cy if cdrmax > dcnt
   03E5 2ArC6s0A           1196 	ld	hl,(dcnt)
   03E8 EB                 1197 	ex	de,hl		;DE = directory counter
   03E9 2ArC6s0A           1198 	ld	hl,(cdrmaxa)	;HL=.cdrmax
   03EC 7B                 1199 	ld	a,e
   03ED 96                 1200 	sub	(hl)		;low(dcnt) - low(cdrmax)
   03EE 23                 1201 	inc	hl		;HL = .cdrmax+1
   03EF 7A                 1202 	ld	a,d
   03F0 9E                 1203 	sbc	a,(hl)		;hig(dcnt) - hig(cdrmax)
                           1204 				;condition dcnt - cdrmax  produces cy if cdrmax>dcnt
   03F1 C9                 1205 	ret
                           1206 
   03F2                    1207 setcdr:				;if not (cdrmax > dcnt) then cdrmax = dcnt+1
   03F2 CDrE5s03           1208 	call	compcdr
   03F5 D8                 1209 	ret	c		;return if cdrmax > dcnt
                           1210 				;otherwise, HL = .cdrmax+1, DE = dcnt
   03F6 13                 1211 	inc	de
   03F7 72                 1212 	ld	(hl),d
   03F8 2B                 1213 	dec	hl
   03F9 73                 1214 	ld	(hl),e
   03FA C9                 1215 	ret
                           1216 
   03FB                    1217 subdh:				;compute HL = DE - HL
   03FB 7B                 1218 	ld	a,e
   03FC 95                 1219 	sub	l
   03FD 6F                 1220 	ld	l,a
   03FE 7A                 1221 	ld	a,d
   03FF 9C                 1222 	sbc	a,h
   0400 67                 1223 	ld	h,a
   0401 C9                 1224 	ret
                           1225 
   0402                    1226 newchecksum:
ua 0402                    1227 	ld	c,true		;drop through to compute new checksum
   0402                    1228 checksum:			;compute current checksum record and update the
                           1229 				;directory element if C=true, or check for = if not
                           1230 				;drec < chksiz?
   0402 2ArC6s0A           1231 	ld	hl,(drec)
   0405 EB                 1232 	ex	de,hl
   0406 2ArC6s0A           1233 	ld	hl,(chksiz)
   0409 CDrFBs03           1234 	call	subdh		;DE-HL
   040C D0                 1235 	ret	nc		;skip checksum if past checksum vector size
                           1236 				;drec < chksiz, so continue
   040D C5                 1237 	push	bc		;save init flag
   040E CDr77s03           1238 	call	compute$cs	;check sum value to A
   0411 2ArC6s0A           1239 	ld	hl,(checka)	;address of check sum vector
   0414 EB                 1240 	ex	de,hl
   0415 2ArC6s0A           1241 	ld	hl,(drec)	;value of drec
   0418 19                 1242 	add	hl,de		;HL = .check(drec)
   0419 C1                 1243 	pop	bc		;recall true=0ffh or false=00 to C
   041A 0C                 1244 	inc	c		;0ffh produces zero flag
   041B CAr28s04           1245 	jp	z,initial$cs
                           1246 				;not initializing, compare
   041E BE                 1247 	cp	(hl)		;compute$cs=check(drec)?
   041F C8                 1248 	ret	z		;no message if ok
                           1249 				;checksum error, are we beyond
                           1250 				;the end of the disk?
   0420 CDrE5s03           1251 	call	compcdr
   0423 D0                 1252 	ret	nc		;no message if so
   0424 CDrA5s03           1253 	call	set$ro		;read/only disk set
   0427 C9                 1254 	ret
                           1255 
   0428                    1256 initial$cs:			;initializing the checksum
   0428 77                 1257 	ld	(hl),a
   0429 C9                 1258 	ret
                           1259 
                           1260 
   042A                    1261 wrdir:				;write the current directory entry, set checksum
   042A CDr02s04           1262 	call	newchecksum	;initialize entry
   042D CDr3Fs04           1263 	call	setdir		;directory dma
a  0430                    1264 	ld	c,1		;indicates a write directory operation
   0430 CDr57s02           1265 	call	wrbuff		;write the buffer
   0433 C3r3Cs04           1266 	jp	setdata		;to data dma address
                           1267 ;	ret
   0436                    1268 rd$dir:				;read a directory entry into the directory buffer
   0436 CDr3Fs04           1269 	call	setdir		;directory dma
   0439 CDr51s02           1270 	call	rdbuff		;directory record loaded
                           1271 				;jmp setdata to data dma address
                           1272 ;	ret
   043C                    1273 setdata:			;set data dma address
a  043C                    1274 	ld	hl,dmaad
   043C C3r3Fs04           1275 	jp	setdma		;to complete the call
                           1276 
   043F                    1277 setdir:				;set directory dma address
a  043F                    1278 	ld	hl,buffa	;jmp setdma to complete call
                           1279 
   043F                    1280 setdma:				;HL=.dma address to set (i.e., buffa or dmaad)
   043F 4E                 1281 	ld	c,(hl)
   0440 23                 1282 	inc	hl
   0441 46                 1283 	ld	b,(hl)		;parameter ready
u  0442 C3 00 00           1284 	jp	setdmaf
                           1285 
   0445                    1286 dir$to$user:			;copy the directory entry to the user buffer
                           1287 				;after call to search or searchn by user code
   0445 2ArC6s0A           1288 	ld	hl,(buffa)
   0448 EB                 1289 	ex	de,hl		;source is directory buffer
   0449 2ArC6s0A           1290 	ld	hl,(dmaad)	;destination is user dma address
ua 044C                    1291 	ld	c,recsiz	;copy entire record
   044C C3r01s02           1292 	jp	move
                           1293 ;	ret
                           1294 
   044F                    1295 end$of$dir:			;return zero flag if at end of directory, non zero
                           1296 				;if not at end (end of dir if dcnt = 0ffffh)
a  044F                    1297 	ld	hl,dcnt
   044F 7E                 1298 	ld	a,(hl)		;may be 0ffh
   0450 23                 1299 	inc	hl
   0451 BE                 1300 	cp	(hl)		;low(dcnt) = high(dcnt)?
   0452 C0                 1301 	ret	nz		;non zero returned if different
                           1302 				;high and low the same, = 0ffh?
   0453 3C                 1303 	inc	a		;0ffh becomes 00 if so
   0454 C9                 1304 	ret
                           1305 
   0455                    1306 set$end$dir:			;set dcnt to the end of the directory
ua 0455                    1307 	ld	hl,enddir
   0455 22rC6s0A           1308 	ld	(dcnt),hl
   0458 C9                 1309 	ret
                           1310 
   0459                    1311 read$dir:			;read next directory entry, with C=true if initializing
   0459 2ArC6s0A           1312 	ld	hl,(dirmax)
   045C EB                 1313 	ex	de,hl		;in preparation for subtract
   045D 2ArC6s0A           1314 	ld	hl,(dcnt)
   0460 23                 1315 	inc	hl
   0461 22rC6s0A           1316 	ld	(dcnt),hl	;dcnt=dcnt+1
                           1317 				;continue while dirmax >= dcnt (dirmax-dcnt no cy)
   0464 CDrFBs03           1318 	call	subdh		;DE-HL
   0467 D2r6Ds04           1319 	jp	nc,read$dir0
                           1320 				;yes, set dcnt to end of directory
   046A C3r55s04           1321 	jp	set$end$dir
                           1322 ;	ret
                           1323 
   046D                    1324 read$dir0:			;not at end of directory, seek next element
                           1325 				;initialization flag is in C
   046D 3ArC6s0A           1326 	ld	a,(dcnt)
ua 0470                    1327 	and	dskmsk		;low(dcnt) and dskmsk
ua 0470                    1328 	ld	b,fcbshf	;to multiply by fcb size
   0470                    1329 read$dir1:
   0470 87                 1330 	add	a,a
   0471 05                 1331 	dec	b
   0472 C2r70s04           1332 	jp	nz,read$dir1
                           1333 				;A = (low(dcnt) and dskmsk) shl fcbshf
   0475 32rC6s0A           1334 	ld	(dptr),a	;ready for next dir operation
   0478 B7                 1335 	or	a
   0479 C0                 1336 	ret	nz		;return if not a new record
   047A C5                 1337 	push	bc		;save initialization flag C
   047B CDr5Fs02           1338 	call	seek$dir	;seek proper record
   047E CDr36s04           1339 	call	rd$dir		;read the directory record
   0481 C1                 1340 	pop	bc		;recall initialization flag
   0482 C3r02s04           1341 	jp	checksum	;checksum the directory elt
                           1342 ;	ret
                           1343 
                           1344 
   0485                    1345 getallocbit:			;given allocation vector position BC, return with byte
                           1346 				;containing BC shifted so that the least significant
                           1347 				;bit is in the low order accumulator position.  HL is
                           1348 				;the address of the byte for possible replacement in
                           1349 				;memory upon return, and D contains the number of shifts
                           1350 				;required to place the returned value back into position
   0485 79                 1351 	ld	a,c
q  0486                    1352 	and	111b
   0486 3C                 1353 	inc	a
   0487 5F                 1354 	ld	e,a
   0488 57                 1355 	ld	d,a
                           1356 				;d and e both contain the number of bit positions to shift
   0489 79                 1357 	ld	a,c
   048A 0F                 1358 	rrca
   048B 0F                 1359 	rrca
   048C 0F                 1360 	rrca
q  048D                    1361 	and	11111b
   048D 4F                 1362 	ld	c,a		;C shr 3 to C
   048E 78                 1363 	ld	a,b
   048F 87                 1364 	add	a,a
   0490 87                 1365 	add	a,a
   0491 87                 1366 	add	a,a
   0492 87                 1367 	add	a,a
   0493 87                 1368 	add	a,a		;B shl 5
   0494 B1                 1369 	or	c
   0495 4F                 1370 	ld	c,a		;bbbccccc to C
   0496 78                 1371 	ld	a,b
   0497 0F                 1372 	rrca
   0498 0F                 1373 	rrca
   0499 0F                 1374 	rrca
q  049A                    1375 	and	11111b
   049A 47                 1376 	ld	b,a		;BC shr 3 to BC
   049B 2ArC6s0A           1377 	ld	hl,(alloca)	;base address of allocation vector
   049E 09                 1378 	add	hl,bc
   049F 7E                 1379 	ld	a,(hl)		;byte to A, hl = .alloc(BC shr 3)
                           1380 				;now move the bit to the low order position of A
   04A0 07                 1381 rotl:	rlca
   04A1 1D                 1382 	dec	e
   04A2 C2rA0s04           1383 	jp	nz,rotl
   04A5 C9                 1384 	ret
                           1385 
                           1386 
   04A6                    1387 set$alloc$bit:			;BC is the bit position of ALLOC to set or reset.  The
                           1388 				;value of the bit is in register E.
   04A6 D5                 1389 	push	de
   04A7 CDr85s04           1390 	call	getallocbit	;shifted val A, count in D
q  04AA                    1391 	and	11111110b	;mask low bit to zero (may be set)
   04AA C1                 1392 	pop	bc
   04AB B1                 1393 	or	c		;low bit of C is masked into A
                           1394 ;	jp	rotr 		;to rotate back into proper position
                           1395 ;	ret
   04AC                    1396 rotr:
                           1397 				;byte value from ALLOC is in register A, with shift count
                           1398 				;in register C (to place bit back into position), and
                           1399 				;target ALLOC position in registers HL, rotate and replace
   04AC 0F                 1400 	rrca
   04AD 15                 1401 	dec	d
   04AE C2rACs04           1402 	jp	nz,rotr		;back into position
   04B1 77                 1403 	ld	(hl),a		;back to ALLOC
   04B2 C9                 1404 	ret
                           1405 
   04B3                    1406 scandm:				;scan the disk map addressed by dptr for non-zero
                           1407 				;entries, the allocation vector entry corresponding
                           1408 				;to a non-zero entry is set to the value of C (0,1)
   04B3 CDrCBs03           1409 	call	getdptra	;HL = buffa + dptr
                           1410 				;HL addresses the beginning of the directory entry
ua 04B6                    1411 	ld	de,dskmap
   04B6 19                 1412 	add	hl,de		;hl now addresses the disk map
   04B7 C5                 1413 	push	bc		;save the 0/1 bit to set
ua 04B8                    1414 	ld	c,fcblen-dskmap+1;size of single byte disk map + 1
   04B8                    1415 scandm0:			;loop once for each disk map entry
   04B8 D1                 1416 	pop	de		;recall bit parity
   04B9 0D                 1417 	dec	c
   04BA C8                 1418 	ret	z		;all done scanning?
                           1419 				;no, get next entry for scan
   04BB D5                 1420 	push	de		;replace bit parity
   04BC 3ArC6s0A           1421 	ld	a,(single)
   04BF B7                 1422 	or	a
   04C0 CArC9s04           1423 	jp	z,scandm1
                           1424 				;single byte scan operation
   04C3 C5                 1425 	push	bc		;save counter
   04C4 E5                 1426 	push	hl		;save map address
   04C5 4E                 1427 	ld	c,(hl)
a  04C6                    1428 	ld	b,0		;BC=block#
   04C6 C3rCFs04           1429 	jp	scandm2
                           1430 
   04C9                    1431 scandm1:			;double byte scan operation
   04C9 0D                 1432 	dec	c		;count for double byte
   04CA C5                 1433 	push	bc		;save counter
   04CB 4E                 1434 	ld	c,(hl)
   04CC 23                 1435 	inc	hl
   04CD 46                 1436 	ld	b,(hl)		;BC=block#
   04CE E5                 1437 	push	hl		;save map address
   04CF                    1438 scandm2:			;arrive here with BC=block#, E=0/1
   04CF 79                 1439 	ld	a,c
   04D0 B0                 1440 	or	b		;skip if = 0000
   04D1 CArDEs04           1441 	jp	z,scanm3
   04D4 2ArC6s0A           1442 	ld	hl,(maxall)	;check invalid index
   04D7 7D                 1443 	ld	a,l
   04D8 91                 1444 	sub	c
   04D9 7C                 1445 	ld	a,h
   04DA 98                 1446 	sbc	a,b		;maxall - block#
   04DB D4rA6s04           1447 	call	nc,set$alloc$bit
                           1448 				;bit set to 0/1
   04DE E1                 1449 scanm3:	pop	hl
   04DF 23                 1450 	inc	hl		;to next bit position
   04E0 C1                 1451 	pop	bc		;recall counter
   04E1 C3rB8s04           1452 	jp	scandm0		;for another item
                           1453 
   04E4                    1454 initialize:			;initialize the current disk
                           1455 				;lret = false ;set to true if $ file exists
                           1456 				;compute the length of the allocation vector - 2
   04E4 2ArC6s0A           1457 	ld	hl,(maxall)
a  04E7                    1458 	ld	c,3		;perform maxall/8
                           1459 				;number of bytes in alloc vector is (maxall/8)+1
   04E7 CDr6As03           1460 	call	hlrotr
   04EA 23                 1461 	inc	hl		;HL = maxall/8+1
   04EB 44                 1462 	ld	b,h
   04EC 4D                 1463 	ld	c,l		;count down BC til zero
   04ED 2ArC6s0A           1464 	ld	hl,(alloca)	;base of allocation vector
                           1465 				;fill the allocation vector with zeros
   04F0                    1466 initial0:
a  04F0                    1467 	ld	(hl),0
   04F0 23                 1468 	inc	hl		;alloc(i)=0
   04F1 0B                 1469 	dec	bc		;count length down
   04F2 78                 1470 	ld	a,b
   04F3 B1                 1471 	or	c
   04F4 C2rF0s04           1472 	jp	nz,initial0
                           1473 				;set the reserved space for the directory
   04F7 2ArC6s0A           1474 	ld	hl,(dirblk)
   04FA EB                 1475 	ex	de,hl
   04FB 2ArC6s0A           1476 	ld	hl,(alloca)	;HL=.alloc()
   04FE 73                 1477 	ld	(hl),e
   04FF 23                 1478 	inc	hl
   0500 72                 1479 	ld	(hl),d		;sets reserved directory blks
                           1480 				;allocation vector initialized, home disk
   0501 CDr40s02           1481 	call	home
                           1482 				;cdrmax = 3 (scans at least one directory record)
   0504 2ArC6s0A           1483 	ld	hl,(cdrmaxa)
a  0507                    1484 	ld	(hl),3
   0507 23                 1485 	inc	hl
a  0508                    1486 	ld	(hl),0
                           1487 				;cdrmax = 0000
   0508 CDr55s04           1488 	call	set$end$dir	;dcnt = enddir
                           1489 				;read directory entries and check for allocated storage
   050B                    1490 initial2:
ua 050B                    1491 	ld	c,true
   050B CDr59s04           1492 	call	read$dir
   050E CDr4Fs04           1493 	call	end$of$dir
   0511 C8                 1494 	ret	z		;return if end of directory
                           1495 				;not end of directory, valid entry?
   0512 CDrCBs03           1496 	call	getdptra	;HL = buffa + dptr
ua 0515                    1497 	ld	a,empty
   0515 BE                 1498 	cp	(hl)
   0516 CAr0Bs05           1499 	jp	z,initial2	;go get another item
                           1500 				;not empty, user code the same?
   0519 3ArFCs01           1501 	ld	a,(usrcode)
   051C BE                 1502 	cp	(hl)
   051D C2r29s05           1503 	jp	nz,pdollar
                           1504 				;same user code, check for '$' submit
   0520 23                 1505 	inc	hl
   0521 7E                 1506 	ld	a,(hl)		;first character
q  0522                    1507 	sub	'$'		;dollar file?
   0522 C2r29s05           1508 	jp	nz,pdollar
                           1509 				;dollar file found, mark in lret
   0525 3D                 1510 	dec	a
u  0526 32 00 00           1511 	ld	(lret),a	;lret = 255
   0529                    1512 pdollar:			;now scan the disk map for allocated blocks
a  0529                    1513 	ld	c,1		;set to allocated
   0529 CDrB3s04           1514 	call	scandm
   052C CDrF2s03           1515 	call	setcdr		;set cdrmax to dcnt
   052F C3r0Bs05           1516 	jp	initial2	;for another entry
                           1517 
   0532                    1518 copy$dirloc:			;copy directory location to lret following
                           1519 				;delete, rename, ... ops
   0532 3ArC6s0A           1520 	ld	a,(dirloc)
   0535 C3rF5s01           1521 	jp	sta$ret
                           1522 ;	ret
                           1523 
   0538                    1524 compext:			;compare extent# in A with that in C, return nonzero
                           1525 				;if they do not match
   0538 C5                 1526 	push	bc		;save C's original value
   0539 F5                 1527 	push	af
   053A 3ArC6s0A           1528 	ld	a,(extmsk)
   053D 2F                 1529 	cpl
   053E 47                 1530 	ld	b,a
                           1531 				;B has negated form of extent mask
   053F 79                 1532 	ld	a,c
   0540 A0                 1533 	and	b
   0541 4F                 1534 	ld	c,a		;low bits removed from C
   0542 F1                 1535 	pop	af
   0543 A0                 1536 	and	b		;low bits removed from A
   0544 91                 1537 	sub	c
ua 0545                    1538 	and	maxext		;set flags
   0545 C1                 1539 	pop	bc		;restore original values
   0546 C9                 1540 	ret
                           1541 
   0547                    1542 search:				;search for directory element of length C at info
ao 0547                    1543 	ld	a,0ffh
   0547 32rC6s0A           1544 	ld	(dirloc),a	;changed if actually found
a  054A                    1545 	ld	hl,searchl
   054A 71                 1546 	ld	(hl),c		;searchl = C
   054B 2ArFCs01           1547 	ld	hl,(info)
   054E 22rC6s0A           1548 	ld	(searcha),hl	;searcha = info
   0551 CDr55s04           1549 	call	set$end$dir	;dcnt = enddir
   0554 CDr40s02           1550 	call	home		;to start at the beginning
                           1551 				;(drop through to searchn)
                           1552 
   0557                    1553 searchn:			;search for the next directory element, assuming
                           1554 				;a previous call on search which sets searcha and
                           1555 				;searchl
ua 0557                    1556 	ld	c,false
   0557 CDr59s04           1557 	call	read$dir	;read next dir element
   055A CDr4Fs04           1558 	call	end$of$dir
   055D CArABs05           1559 	jp	z,search$fin	;skip to end if so
                           1560 				;not end of directory, scan for match
   0560 2ArC6s0A           1561 	ld	hl,(searcha)
   0563 EB                 1562 	ex	de,hl		;DE=beginning of user fcb
   0564 1A                 1563 	ld	a,(de)		;first character
ua 0565                    1564 	cp	empty		;keep scanning if empty
   0565 CAr70s05           1565 	jp	z,searchnext
                           1566 				;not empty, may be end of logical directory
   0568 D5                 1567 	push	de		;save search address
   0569 CDrE5s03           1568 	call	compcdr		;past logical end?
   056C D1                 1569 	pop	de		;recall address
   056D D2rABs05           1570 	jp	nc,search$fin	;artificial stop
   0570                    1571 searchnext:
   0570 CDrCBs03           1572 	call	getdptra	;HL = buffa+dptr
   0573 3ArC6s0A           1573 	ld	a,(searchl)
   0576 4F                 1574 	ld	c,a		;length of search to c
a  0577                    1575 	ld	b,0		;b counts up, c counts down
   0577                    1576 searchloop:
   0577 79                 1577 	ld	a,c
   0578 B7                 1578 	or	a
   0579 CAr9Fs05           1579 	jp	z,endsearch
   057C 1A                 1580 	ld	a,(de)
q  057D                    1581 	cp	'?'
   057D CAr98s05           1582 	jp	z,searchok	;? matches all
                           1583 				;scan next character if not ubytes
   0580 78                 1584 	ld	a,b
ua 0581                    1585 	cp	ubytes
   0581 CAr98s05           1586 	jp	z,searchok
                           1587 				;not the ubytes field, extent field?
ua 0584                    1588 	cp	extnum		;may be extent field
   0584 1A                 1589 	ld	a,(de)		;fcb character
   0585 CAr8Fs05           1590 	jp	z,searchext	;skip to search extent
   0588 96                 1591 	sub	(hl)
q  0589                    1592 	and	7fh		;mask-out flags/extent modulus
   0589 C2r57s05           1593 	jp	nz,searchn	;skip if not matched
   058C C3r98s05           1594 	jp	searchok	;matched character
                           1595 
   058F                    1596 searchext:			;A has fcb character
                           1597 				;attempt an extent # match
   058F C5                 1598 	push	bc		;save counters
   0590 4E                 1599 	ld	c,(hl)		;directory character to c
   0591 CDr38s05           1600 	call	compext		;compare user/dir char
   0594 C1                 1601 	pop	bc		;recall counters
   0595 C2r57s05           1602 	jp	nz,searchn	;skip if no match
   0598                    1603 searchok:			;current character matches
   0598 13                 1604 	inc	de
   0599 23                 1605 	inc	hl
   059A 04                 1606 	inc	b
   059B 0D                 1607 	dec	c
   059C C3r77s05           1608 	jp	searchloop
                           1609 
   059F                    1610 endsearch:			;entire name matches, return dir position
   059F 3ArC6s0A           1611 	ld	a,(dcnt)
ua 05A2                    1612 	and	dskmsk
u  05A2 32 00 00           1613 	ld	(lret),a
                           1614 				;lret = low(dcnt) and 11b
a  05A5                    1615 	ld	hl,dirloc
   05A5 7E                 1616 	ld	a,(hl)
   05A6 17                 1617 	rla
   05A7 D0                 1618 	ret	nc		;dirloc=0ffh?
                           1619 				;yes, change it to 0 to mark as found
   05A8 AF                 1620 	xor	a
   05A9 77                 1621 	ld	(hl),a		;dirloc=0
   05AA C9                 1622 	ret
                           1623 
   05AB                    1624 search$fin:			;end of directory, or empty name
   05AB CDr55s04           1625 	call	set$end$dir	;may be artifical end
a  05AE                    1626 	ld	a,255
   05AE C3rF5s01           1627 	jp	sta$ret
                           1628 
   05B1                    1629 delete:				;delete the currently addressed file
   05B1 CDrC4s03           1630 	call	check$write	;write protected?
ua 05B4                    1631 	ld	c,extnum
   05B4 CDr47s05           1632 	call	search		;search through file type
   05B7                    1633 delete0:
                           1634 				;loop while directory matches
   05B7 CDr4Fs04           1635 	call	end$of$dir
   05BA C8                 1636 	ret	z		;stop if end
                           1637 				;set each non zero disk map entry to 0
                           1638 				;in the allocation vector
                           1639 				;may be r/o file
   05BB CDrBAs03           1640 	call	check$rodir	;ro disk error if found
   05BE CDrCBs03           1641 	call	getdptra	;HL=.buff(dptr)
ua 05C1                    1642 	ld	(hl),empty
a  05C1                    1643 	ld	c,0
   05C1 CDrB3s04           1644 	call	scandm		;alloc elts set to 0
   05C4 CDr2As04           1645 	call	wrdir		;write the directory
   05C7 CDr57s05           1646 	call	searchn		;to next element
   05CA C3rB7s05           1647 	jp	delete0		;for another record
                           1648 
   05CD                    1649 get$block:			;given allocation vector position BC, find the zero bit
                           1650 				;closest to this position by searching left and right.
                           1651 				;if found, set the bit to one and return the bit position
                           1652 				;in hl.  if not found (i.e., we pass 0 on the left, or
                           1653 				;maxall on the right), return 0000 in hl
   05CD 50                 1654 	ld	d,b
   05CE 59                 1655 	ld	e,c		;copy of starting position to de
   05CF                    1656 lefttst:
   05CF 79                 1657 	ld	a,c
   05D0 B0                 1658 	or	b
   05D1 CArE0s05           1659 	jp	z,righttst	;skip if left=0000
                           1660 				;left not at position zero, bit zero?
   05D4 0B                 1661 	dec	bc
   05D5 D5                 1662 	push	de
   05D6 C5                 1663 	push	bc		;left,right pushed
   05D7 CDr85s04           1664 	call	getallocbit
   05DA 1F                 1665 	rra
   05DB D2rFBs05           1666 	jp	nc,retblock	;return block number if zero
                           1667 				;bit is one, so try the right
   05DE C1                 1668 	pop	bc
   05DF D1                 1669 	pop	de		;left, right restored
   05E0                    1670 righttst:
   05E0 2ArC6s0A           1671 	ld	hl,(maxall)	;value of maximum allocation#
   05E3 7B                 1672 	ld	a,e
   05E4 95                 1673 	sub	l
   05E5 7A                 1674 	ld	a,d
   05E6 9C                 1675 	sbc	a,h		;right=maxall?
   05E7 D2r03s06           1676 	jp	nc,retblock0	;return block 0000 if so
   05EA 13                 1677 	inc	de
   05EB C5                 1678 	push	bc
   05EC D5                 1679 	push	de		;left, right pushed
   05ED 42                 1680 	ld	b,d
   05EE 4B                 1681 	ld	c,e		;ready right for call
   05EF CDr85s04           1682 	call	getallocbit
   05F2 1F                 1683 	rra
   05F3 D2rFBs05           1684 	jp	nc,retblock	;return block number if zero
   05F6 D1                 1685 	pop	de
   05F7 C1                 1686 	pop	bc		;restore left and right pointers
   05F8 C3rCFs05           1687 	jp	lefttst		;for another attempt
   05FB                    1688 retblock:
   05FB 17                 1689 	rla
   05FC 3C                 1690 	inc	a		;bit back into position and set to 1
                           1691 				;d contains the number of shifts required to reposition
   05FD CDrACs04           1692 	call	rotr		;move bit back to position and store
   0600 E1                 1693 	pop	hl
   0601 D1                 1694 	pop	de		;HL returned value, DE discarded
   0602 C9                 1695 	ret
                           1696 
   0603                    1697 retblock0:			;cannot find an available bit, return 0000
   0603 79                 1698 	ld	a,c
   0604 B0                 1699 	or	b
   0605 C2rCFs05           1700 	jp	nz,lefttst	;also at beginning
ao 0608                    1701 	ld	hl,0000h
   0608 C9                 1702 	ret
                           1703 
   0609                    1704 copy$fcb:			;copy the entire file control block
a  0609                    1705 	ld	c,0
ua 0609                    1706 	ld	e,fcblen	;start at 0, to fcblen-1
                           1707 ;	jp	copy$dir
                           1708 
   0609                    1709 copy$dir:			;copy fcb information starting at C for E bytes
                           1710 				;into the currently addressed directory entry
   0609 D5                 1711 	push	de		;save length for later
a  060A                    1712 	ld	b,0		;double index to BC
   060A 2ArFCs01           1713 	ld	hl,(info)	;HL = source for data
   060D 09                 1714 	add	hl,bc
   060E EB                 1715 	ex	de,hl		;DE=.fcb(C), source for copy
   060F CDrCBs03           1716 	call	getdptra	;HL=.buff(dptr), destination
   0612 C1                 1717 	pop	bc		;DE=source, HL=dest, C=length
   0613 CDr01s02           1718 	call	move		;data moved
   0616                    1719 seek$copy:			;enter from close to seek and copy current element
   0616 CDr5Fs02           1720 	call	seek$dir	;to the directory element
   0619 C3r2As04           1721 	jp	wrdir		;write the directory element
                           1722 ;	ret
   061C                    1723 rename:				;rename the file described by the first half of
                           1724 				;the currently addressed file control block. the
                           1725 				;new name is contained in the last half of the
                           1726 				;currently addressed file conrol block.  the file
                           1727 				;name and type are changed, but the reel number
                           1728 				;is ignored.  the user number is identical
   061C CDrC4s03           1729 	call	check$write	;may be write protected
                           1730 				;search up to the extent field
ua 061F                    1731 	ld	c,extnum
   061F CDr47s05           1732 	call	search
                           1733 				;copy position 0
   0622 2ArFCs01           1734 	ld	hl,(info)
   0625 7E                 1735 	ld	a,(hl)		;HL=.fcb(0), A=fcb(0)
ua 0626                    1736 	ld	de,dskmap
   0626 19                 1737 	add	hl,de		;HL=.fcb(dskmap)
   0627 77                 1738 	ld	(hl),a		;fcb(dskmap)=fcb(0)
                           1739 				;assume the same disk drive for new named file
   0628                    1740 rename0:
   0628 CDr4Fs04           1741 	call	end$of$dir
   062B C8                 1742 	ret	z		;stop at end of dir
                           1743 				;not end of directory, rename next element
   062C CDrBAs03           1744 	call	check$rodir	;may be read-only file
ua 062F                    1745 	ld	c,dskmap
ua 062F                    1746 	ld	e,extnum
   062F CDr09s06           1747 	call	copy$dir
                           1748 				;element renamed, move to next
   0632 CDr57s05           1749 	call	searchn
   0635 C3r28s06           1750 	jp	rename0
                           1751 
   0638                    1752 indicators:			;set file indicators for current fcb
ua 0638                    1753 	ld	c,extnum
   0638 CDr47s05           1754 	call	search		;through file type
   063B CDr4Fs04           1755 indic0:	call	end$of$dir
   063E C8                 1756 	ret	z		;stop at end of dir
                           1757 				;not end of directory, continue to change
a  063F                    1758 	ld	c,0
ua 063F                    1759 	ld	e,extnum	;copy name
   063F CDr09s06           1760 	call	copy$dir
   0642 CDr57s05           1761 	call	searchn
   0645 C3r3Bs06           1762 	jp	indic0
                           1763 
   0648                    1764 open:				;search for the directory entry, copy to fcb
ua 0648                    1765 	ld	c,namlen
   0648 CDr47s05           1766 	call	search
   064B CDr4Fs04           1767 	call	end$of$dir
   064E C8                 1768 	ret	z		;return with lret=255 if end
                           1769 				;not end of directory, copy fcb information
   064F                    1770 open$copy:			;(referenced below to copy fcb info)
   064F CDr31s03           1771 	call	getexta
   0652 7E                 1772 	ld	a,(hl)
   0653 F5                 1773 	push	af
   0654 E5                 1774 	push	hl		;save extent#
   0655 CDrCBs03           1775 	call	getdptra
   0658 EB                 1776 	ex	de,hl		;DE = .buff(dptr)
   0659 2ArFCs01           1777 	ld	hl,(info)	;HL=.fcb(0)
ua 065C                    1778 	ld	c,nxtrec	;length of move operation
   065C D5                 1779 	push	de		;save .buff(dptr)
   065D CDr01s02           1780 	call	move		;from .buff(dptr) to .fcb(0)
                           1781 				;note that entire fcb is copied, including indicators
   0660 CDrE0s03           1782 	call	setfwf		;sets file write flag
   0663 D1                 1783 	pop	de
ua 0664                    1784 	ld	hl,extnum
   0664 19                 1785 	add	hl,de		;HL=.buff(dptr+extnum)
   0665 4E                 1786 	ld	c,(hl)		;C = directory extent number
ua 0666                    1787 	ld	hl,reccnt
   0666 19                 1788 	add	hl,de		;HL=.buff(dptr+reccnt)
   0667 46                 1789 	ld	b,(hl)		;B holds directory record count
   0668 E1                 1790 	pop	hl
   0669 F1                 1791 	pop	af
   066A 77                 1792 	ld	(hl),a		;restore extent number
                           1793 				;HL = .user extent#, B = dir rec cnt, C = dir extent#
                           1794 				;if user ext < dir ext then user := 128 records
                           1795 				;if user ext = dir ext then user := dir records
                           1796 				;if user ext > dir ext then user := 0 records
   066B 79                 1797 	ld	a,c
   066C BE                 1798 	cp	(hl)
   066D 78                 1799 	ld	a,b		;ready dir reccnt
   066E CAr74s06           1800 	jp	z,open$rcnt	;if same, user gets dir reccnt
a  0671                    1801 	ld	a,0
   0671 DAr74s06           1802 	jp	c,open$rcnt	;user is larger
a  0674                    1803 	ld	a,128		;directory is larger
   0674                    1804 open$rcnt:			;A has record count to fill
   0674 2ArFCs01           1805 	ld	hl,(info)
ua 0677                    1806 	ld	de,reccnt
   0677 19                 1807 	add	hl,de
   0678 77                 1808 	ld	(hl),a
   0679 C9                 1809 	ret
                           1810 
   067A                    1811 mergezero:			;HL = .fcb1(i), DE = .fcb2(i),
                           1812 				;if fcb1(i) = 0 then fcb1(i) := fcb2(i)
   067A 7E                 1813 	ld	a,(hl)
   067B 23                 1814 	inc	hl
   067C B6                 1815 	or	(hl)
   067D 2B                 1816 	dec	hl
   067E C0                 1817 	ret	nz		;return if = 0000
   067F 1A                 1818 	ld	a,(de)
   0680 77                 1819 	ld	(hl),a
   0681 13                 1820 	inc	de
   0682 23                 1821 	inc	hl		;low byte copied
   0683 1A                 1822 	ld	a,(de)
   0684 77                 1823 	ld	(hl),a
   0685 1B                 1824 	dec	de
   0686 2B                 1825 	dec	hl		;back to input form
   0687 C9                 1826 	ret
                           1827 
   0688                    1828 close:				;locate the directory element and re-write it
   0688 AF                 1829 	xor	a
u  0689 32 00 00           1830 	ld	(lret),a
   068C 32rC6s0A           1831 	ld	(dcnt),a
   068F 32rC7s0A           1832 	ld	(dcnt+1),a
   0692 CDr99s03           1833 	call	nowrite
   0695 C0                 1834 	ret	nz		;skip close if r/o disk
                           1835 				;check file write flag - 0 indicates written
   0696 CDrD6s03           1836 	call	getmodnum	;fcb(modnum) in A
ua 0699                    1837 	and	fwfmsk
   0699 C0                 1838 	ret	nz		;return if bit remains set
ua 069A                    1839 	ld	c,namlen
   069A CDr47s05           1840 	call	search		;locate file
   069D CDr4Fs04           1841 	call	end$of$dir
   06A0 C8                 1842 	ret	z		;return if not found
                           1843 				;merge the disk map at info with that at buff(dptr)
ua 06A1                    1844 	ld	bc,dskmap
   06A1 CDrCBs03           1845 	call	getdptra
   06A4 09                 1846 	add	hl,bc
   06A5 EB                 1847 	ex	de,hl		;DE is .buff(dptr+16)
   06A6 2ArFCs01           1848 	ld	hl,(info)
   06A9 09                 1849 	add	hl,bc		;DE=.buff(dptr+16), HL=.fcb(16)
ua 06AA                    1850 	ld	c,fcblen-dskmap;length of single byte dm
   06AA 3ArC6s0A           1851 merge0:	ld	a,(single)
   06AD B7                 1852 	or	a
   06AE CArC5s06           1853 	jp	z,merged	;skip to double
                           1854 				;this is a single byte map
                           1855 				;if fcb(i) = 0 then fcb(i) = buff(i)
                           1856 				;if buff(i) = 0 then buff(i) = fcb(i)
                           1857 				;if fcb(i) <> buff(i) then error
   06B1 7E                 1858 	ld	a,(hl)
   06B2 B7                 1859 	or	a
   06B3 1A                 1860 	ld	a,(de)
   06B4 C2rB8s06           1861 	jp	nz,fcbnzero
                           1862 				;fcb(i) = 0
   06B7 77                 1863 	ld	(hl),a		;fcb(i) = buff(i)
   06B8                    1864 fcbnzero:
   06B8 B7                 1865 	or	a
   06B9 C2rBEs06           1866 	jp	nz,buffnzero
                           1867 				;buff(i) = 0
   06BC 7E                 1868 	ld	a,(hl)
   06BD 12                 1869 	ld	(de),a		;buff(i)=fcb(i)
   06BE                    1870 buffnzero:
   06BE BE                 1871 	cp	(hl)
   06BF C2rF4s06           1872 	jp	nz,mergerr	;fcb(i) = buff(i)?
   06C2 C3rDAs06           1873 	jp	dmset		;if merge ok
                           1874 
   06C5                    1875 merged:				;this is a double byte merge operation
   06C5 CDr7As06           1876 	call	mergezero	;buff = fcb if buff 0000
   06C8 EB                 1877 	ex	de,hl
   06C9 CDr7As06           1878 	call	mergezero
   06CC EB                 1879 	ex	de,hl		;fcb = buff if fcb 0000
                           1880 				;they should be identical at this point
   06CD 1A                 1881 	ld	a,(de)
   06CE BE                 1882 	cp	(hl)
   06CF C2rF4s06           1883 	jp	nz,mergerr	;low same?
   06D2 13                 1884 	inc	de
   06D3 23                 1885 	inc	hl		;to high byte
   06D4 1A                 1886 	ld	a,(de)
   06D5 BE                 1887 	cp	(hl)
   06D6 C2rF4s06           1888 	jp	nz,mergerr	;high same?
                           1889 				;merge operation ok for this pair
   06D9 0D                 1890 	dec	c		;extra count for double byte
   06DA 13                 1891 dmset:	inc	de
   06DB 23                 1892 	inc	hl		;to next byte position
   06DC 0D                 1893 	dec	c
   06DD C2rAAs06           1894 	jp	nz,merge0	;for more
                           1895 				;end of disk map merge, check record count
                           1896 				;DE = .buff(dptr)+32, HL = .fcb(32)
ua 06E0                    1897 	ld	bc,-(fcblen-extnum)
   06E0 09                 1898 	add	hl,bc
   06E1 EB                 1899 	ex	de,hl
   06E2 09                 1900 	add	hl,bc
                           1901 				;DE = .fcb(extnum), HL = .buff(dptr+extnum)
   06E3 1A                 1902 	ld	a,(de)		;current user extent number
                           1903 				;if fcb(ext) >= buff(fcb) then
                           1904 				;buff(ext) := fcb(ext), buff(rec) := fcb(rec)
   06E4 BE                 1905 	cp	(hl)
   06E5 DArEEs06           1906 	jp	c,endmerge
                           1907 				;fcb extent number >= dir extent number
   06E8 77                 1908 	ld	(hl),a		;buff(ext) = fcb(ext)
                           1909 				;update directory record count field
ua 06E9                    1910 	ld	bc,reccnt-extnum
   06E9 09                 1911 	add	hl,bc
   06EA EB                 1912 	ex	de,hl
   06EB 09                 1913 	add	hl,bc
                           1914 				;DE=.buff(reccnt), HL=.fcb(reccnt)
   06EC 7E                 1915 	ld	a,(hl)
   06ED 12                 1916 	ld	(de),a		;buff(reccnt)=fcb(reccnt)
   06EE                    1917 endmerge:
ua 06EE                    1918 	ld	a,true
   06EE 32rC6s0A           1919 	ld	(fcb$copied),a	;mark as copied
   06F1 C3r16s06           1920 	jp	seek$copy	;ok to "wrdir" here - 1.4 compat
                           1921 				;		ret
                           1922 
   06F4                    1923 mergerr:			;elements did not merge correctly
ua 06F4                    1924 	ld	hl,lret
   06F4 35                 1925 	dec	(hl)		;=255 non zero flag set
   06F5 C9                 1926 	ret
                           1927 
   06F6                    1928 make:				;create a new file by creating a directory entry
                           1929 				;then opening the file
   06F6 CDrC4s03           1930 	call	check$write	;may be write protected
   06F9 2ArFCs01           1931 	ld	hl,(info)
   06FC E5                 1932 	push	hl		;save fcb address, look for e5
a  06FD                    1933 	ld	hl,efcb
   06FD 22rFCs01           1934 	ld	(info),hl	;info = .empty
a  0700                    1935 	ld	c,1
   0700 CDr47s05           1936 	call	search		;length 1 match on empty entry
   0703 CDr4Fs04           1937 	call	end$of$dir	;zero flag set if no space
   0706 E1                 1938 	pop	hl		;recall info address
   0707 22rFCs01           1939 	ld	(info),hl	;in case we return here
   070A C8                 1940 	ret	z		;return with error condition 255 if not found
   070B EB                 1941 	ex	de,hl		;DE = info address
                           1942 				;clear the remainder of the fcb
ua 070C                    1943 	ld	hl,namlen
   070C 19                 1944 	add	hl,de		;HL=.fcb(namlen)
ua 070D                    1945 	ld	c,fcblen-namlen	;number of bytes to fill
   070D AF                 1946 	xor	a		;clear accumulator to 00 for fill
   070E 77                 1947 make0:	ld	(hl),a
   070F 23                 1948 	inc	hl
   0710 0D                 1949 	dec	c
   0711 C2r0Es07           1950 	jp	nz,make0
ua 0714                    1951 	ld	hl,ubytes
   0714 19                 1952 	add	hl,de		;HL = .fcb(ubytes)
   0715 77                 1953 	ld	(hl),a		;fcb(ubytes) = 0
   0716 CDrF2s03           1954 	call	setcdr		;may have extended the directory
                           1955 				;now copy entry to the directory
   0719 CDr09s06           1956 	call	copy$fcb
                           1957 				;and set the file write flag to "1"
   071C C3rE0s03           1958 	jp	setfwf
                           1959 ;	ret
                           1960 
   071F                    1961 open$reel:			;close the current extent, and open the next one
                           1962 				;if possible.  RMF is true if in read mode
   071F AF                 1963 	xor	a
   0720 32rC6s0A           1964 	ld	(fcb$copied),a	;set true if actually copied
   0723 CDr88s06           1965 	call	close		;close current extent
                           1966 				;lret remains at enddir if we cannot open the next ext
   0726 CDr4Fs04           1967 	call	end$of$dir
   0729 C8                 1968 	ret	z		;return if end
                           1969 				;increment extent number
   072A 2ArFCs01           1970 	ld	hl,(info)
ua 072D                    1971 	ld	bc,extnum
   072D 09                 1972 	add	hl,bc		;HL=.fcb(extnum)
   072E 7E                 1973 	ld	a,(hl)
   072F 3C                 1974 	inc	a
ua 0730                    1975 	and	maxext
   0730 77                 1976 	ld	(hl),a		;fcb(extnum)=++1
   0731 CAr40s07           1977 	jp	z,open$mod	;move to next module if zero
                           1978 				;may be in the same extent group
   0734 47                 1979 	ld	b,a
   0735 3ArC6s0A           1980 	ld	a,(extmsk)
   0738 A0                 1981 	and	b
                           1982 				;if result is zero, then not in the same group
a  0739                    1983 	ld	hl,fcb$copied	;true if the fcb was copied to directory
   0739 A6                 1984 	and	(hl)		;produces a 00 in accumulator if not written
   073A CAr46s07           1985 	jp	z,open$reel0	;go to next physical extent
                           1986 				;result is non zero, so we must be in same logical ext
   073D C3r62s07           1987 	jp	open$reel1	;to copy fcb information
   0740                    1988 open$mod:			;extent number overflow, go to next module
ua 0740                    1989 	ld	bc,modnum-extnum
   0740 09                 1990 	add	hl,bc		;HL=.fcb(modnum)
   0741 34                 1991 	inc	(hl)		;fcb(modnum)=++1
                           1992 				;module number incremented, check for overflow
   0742 7E                 1993 	ld	a,(hl)
ua 0743                    1994 	and	maxmod		;mask high order bits
   0743 CAr6Cs07           1995 	jp	z,open$r$err	;cannot overflow to zero
                           1996 				;otherwise, ok to continue with new module
   0746                    1997 open$reel0:
ua 0746                    1998 	ld	c,namlen
   0746 CDr47s05           1999 	call	search		;next extent found?
   0749 CDr4Fs04           2000 	call	end$of$dir
   074C C2r62s07           2001 	jp	nz,open$reel1
                           2002 				;end of file encountered
   074F 3ArC6s0A           2003 	ld	a,(rmf)
   0752 3C                 2004 	inc	a		;0ffh becomes 00 if read
   0753 CAr6Cs07           2005 	jp	z,open$r$err	;sets lret = 1
                           2006 				;try to extend the current file
   0756 CDrF6s06           2007 	call	make
                           2008 				;cannot be end of directory
   0759 CDr4Fs04           2009 	call	end$of$dir
   075C CAr6Cs07           2010 	jp	z,open$r$err	;with lret = 1
   075F C3r65s07           2011 	jp	open$reel2
                           2012 
   0762                    2013 open$reel1:			;not end of file, open
   0762 CDr4Fs06           2014 	call	open$copy
   0765                    2015 open$reel2:
   0765 CDr3Ds03           2016 	call	getfcb		;set parameters
   0768 AF                 2017 	xor	a
   0769 C3rF5s01           2018 	jp	sta$ret		;lret = 0
                           2019 ;	ret 			;with lret = 0
                           2020 
   076C                    2021 open$r$err:			;cannot move to next extent of this file
   076C CDrF9s01           2022 	call	setlret1	;lret = 1
   076F C3rE0s03           2023 	jp	setfwf		;ensure that it will not be closed
                           2024 ;	ret
                           2025 
   0772                    2026 seqdiskread:			;sequential disk read operation
a  0772                    2027 	ld	a,1
   0772 32rC6s0A           2028 	ld	(seqio),a
                           2029 				;drop through to diskread
                           2030 
   0775                    2031 diskread:			;(may enter from seqdiskread)
ua 0775                    2032 	ld	a,true
   0775 32rC6s0A           2033 	ld	(rmf),a		;read mode flag = true (open$reel)
                           2034 				;read the next record from the current fcb
   0778 CDr3Ds03           2035 	call	getfcb		;sets parameters for the read
   077B 3ArC6s0A           2036 	ld	a,(vrecord)
a  077E                    2037 	ld	hl,rcount
   077E BE                 2038 	cp	(hl)		;vrecord-rcount
                           2039 				;skip if rcount > vrecord
   077F DAr93s07           2040 	jp	c,recordok
                           2041 				;not enough records in the extent
                           2042 				;record count must be 128 to continue
a  0782                    2043 	cp	128		;vrecord = 128?
   0782 C2rA8s07           2044 	jp	nz,diskeof	;skip if vrecord<>128
   0785 CDr1Fs07           2045 	call	open$reel	;go to next extent if so
   0788 AF                 2046 	xor	a
   0789 32rC6s0A           2047 	ld	(vrecord),a	;vrecord=00
                           2048 				;now check for open ok
u  078C 3A 00 00           2049 	ld	a,(lret)
   078F B7                 2050 	or	a
   0790 C2rA8s07           2051 	jp	nz,diskeof	;stop at eof
   0793                    2052 recordok:			;arrive with fcb addressing a record to read
   0793 CDr04s03           2053 	call	index
                           2054 				;error 2 if reading unwritten data
                           2055 				;(returns 1 to be compatible with 1.4)
   0796 CDr0Fs03           2056 	call	allocated	;arecord=0000?
   0799 CArA8s07           2057 	jp	z,diskeof
                           2058 				;record has been allocated, read it
   079C CDr15s03           2059 	call	atran		;arecord now a disk address
   079F CDr6Bs02           2060 	call	seek		;to proper track,sector
   07A2 CDr51s02           2061 	call	rdbuff		;to dma address
   07A5 C3r54s03           2062 	jp	setfcb		;replace parameter
                           2063 ;	ret
                           2064 
   07A8                    2065 diskeof:
   07A8 C3rF9s01           2066 	jp	setlret1	;lret = 1
                           2067 ;	ret
                           2068 
   07AB                    2069 seqdiskwrite:			;sequential disk write
a  07AB                    2070 	ld	a,1
   07AB 32rC6s0A           2071 	ld	(seqio),a
                           2072 				;drop through to diskwrite
                           2073 
   07AE                    2074 diskwrite:			;(may enter here from seqdiskwrite above)
ua 07AE                    2075 	ld	a,false
   07AE 32rC6s0A           2076 	ld	(rmf),a		;read mode flag
                           2077 				;write record to currently selected file
   07B1 CDrC4s03           2078 	call	check$write	;in case write protected
   07B4 2ArFCs01           2079 	ld	hl,(info)	;HL = .fcb(0)
   07B7 CDrBDs03           2080 	call	check$rofile	;may be a read-only file
   07BA CDr3Ds03           2081 	call	getfcb		;to set local parameters
   07BD 3ArC6s0A           2082 	ld	a,(vrecord)
ua 07C0                    2083 	cp	lstrec+1	;vrecord-128
                           2084 				;skip if vrecord > lstrec
                           2085 				;vrecord = 128, cannot open next extent
   07C0 D2rF9s01           2086 	jp	nc,setlret1	;lret=1
   07C3                    2087 diskwr0:			;can write the next record, so continue
   07C3 CDr04s03           2088 	call	index
   07C6 CDr0Fs03           2089 	call	allocated
a  07C9                    2090 	ld	c,0		;marked as normal write operation for wrbuff
   07C9 C2r07s08           2091 	jp	nz,diskwr1
                           2092 				;not allocated
                           2093 				;the argument to getblock is the starting
                           2094 				;position for the disk search, and should be
                           2095 				;the last allocated block for this file, or
                           2096 				;the value 0 if no space has been allocated
   07CC CDrD5s02           2097 	call	dm$position
   07CF 32rC6s0A           2098 	ld	(dminx),a	;save for later
ao 07D2                    2099 	ld	bc,0000h	;may use block zero
   07D2 B7                 2100 	or	a
   07D3 CArDDs07           2101 	jp	z,nopblock	;skip if no previous block
                           2102 				;previous block exists at A
   07D6 4F                 2103 	ld	c,a
   07D7 0B                 2104 	dec	bc		;previous block # in BC
   07D8 CDrF0s02           2105 	call	getdm		;previous block # to HL
   07DB 44                 2106 	ld	b,h
   07DC 4D                 2107 	ld	c,l		;BC=prev block#
   07DD                    2108 nopblock:			;BC = 0000, or previous block #
   07DD CDrCDs05           2109 	call	get$block	;block # to HL
                           2110 				;arrive here with block# or zero
   07E0 7D                 2111 	ld	a,l
   07E1 B4                 2112 	or	h
   07E2 C2rE8s07           2113 	jp	nz,blockok
                           2114 				;cannot find a block to allocate
a  07E5                    2115 	ld	a,2
   07E5 C3rF5s01           2116 	jp	sta$ret		;lret=2
                           2117 
   07E8                    2118 blockok:			;allocated block number is in HL
   07E8 22rC6s0A           2119 	ld	(arecord),hl
   07EB EB                 2120 	ex	de,hl		;block number to DE
   07EC 2ArFCs01           2121 	ld	hl,(info)
ua 07EF                    2122 	ld	bc,dskmap
   07EF 09                 2123 	add	hl,bc		;HL=.fcb(dskmap)
   07F0 3ArC6s0A           2124 	ld	a,(single)
   07F3 B7                 2125 	or	a		;set flags for single byte dm
   07F4 3ArC6s0A           2126 	ld	a,(dminx)	;recall dm index
   07F7 CAr01s08           2127 	jp	z,allocwd	;skip if allocating word
                           2128 				;allocating a byte value
   07FA CDrD1s03           2129 	call	addh
   07FD 73                 2130 	ld	(hl),e		;single byte alloc
   07FE C3r07s08           2131 	jp	diskwru		;to continue
                           2132 
   0801                    2133 allocwd:			;allocate a word value
   0801 4F                 2134 	ld	c,a
a  0802                    2135 	ld	b,0		;double(dminx)
   0802 09                 2136 	add	hl,bc
   0803 09                 2137 	add	hl,bc		;HL=.fcb(dminx*2)
   0804 73                 2138 	ld	(hl),e
   0805 23                 2139 	inc	hl
   0806 72                 2140 	ld	(hl),d		;double wd
   0807                    2141 diskwru:			;disk write to previously unallocated block
a  0807                    2142 	ld	c,2		;marked as unallocated write
   0807                    2143 diskwr1:			;continue the write operation of no allocation error
                           2144 				;C = 0 if normal write, 2 if to prev unalloc block
u  0807 3A 00 00           2145 	ld	a,(lret)
   080A B7                 2146 	or	a
   080B C0                 2147 	ret	nz		;stop if non zero returned value
   080C C5                 2148 	push	bc		;save write flag
   080D CDr15s03           2149 	call	atran		;arecord set
   0810 3ArC6s0A           2150 	ld	a,(seqio)
   0813 3D                 2151 	dec	a
   0814 3D                 2152 	dec	a
   0815 C2r50s08           2153 	jp	nz,diskwr11
   0818 C1                 2154 	pop	bc
   0819 C5                 2155 	push	bc
   081A 79                 2156 	ld	a,c
   081B 3D                 2157 	dec	a
   081C 3D                 2158 	dec	a
   081D C2r50s08           2159 	jp	nz,diskwr11	;old allocation
   0820 E5                 2160 	push	hl		;arecord in hl ret from atran
   0821 2ArC6s0A           2161 	ld	hl,(buffa)
   0824 57                 2162 	ld	d,a		;zero buffa & fill
   0825 77                 2163 fill0:	ld	(hl),a
   0826 23                 2164 	inc	hl
   0827 14                 2165 	inc	d
   0828 F2r25s08           2166 	jp	p,fill0
   082B CDr3Fs04           2167 	call	setdir
   082E 2ArC6s0A           2168 	ld	hl,(arecord1)
a  0831                    2169 	ld	c,2
   0831 22rC6s0A           2170 fill1:	ld	(arecord),hl
   0834 C5                 2171 	push	bc
   0835 CDr6Bs02           2172 	call	seek
   0838 C1                 2173 	pop	bc
   0839 CDr57s02           2174 	call	wrbuff		;write fill record
   083C 2ArC6s0A           2175 	ld	hl,(arecord)	;restore last record
a  083F                    2176 	ld	c,0		;change  allocate flag
   083F 3ArC6s0A           2177 	ld	a,(blkmsk)
   0842 47                 2178 	ld	b,a
   0843 A5                 2179 	and	l
   0844 B8                 2180 	cp	b
   0845 23                 2181 	inc	hl
   0846 C2r31s08           2182 	jp	nz,fill1	;cont until cluster is zeroed
   0849 E1                 2183 	pop	hl
   084A 22rC6s0A           2184 	ld	(arecord),hl
   084D CDr3Cs04           2185 	call	setdata
   0850                    2186 diskwr11:
   0850 CDr6Bs02           2187 	call	seek		;to proper file position
   0853 C1                 2188 	pop	bc
   0854 C5                 2189 	push	bc		;restore/save write flag (C=2 if new block)
   0855 CDr57s02           2190 	call	wrbuff		;written to disk
   0858 C1                 2191 	pop	bc		;C = 2 if a new block was allocated, 0 if not
                           2192 				;increment record count if rcount<=vrecord
   0859 3ArC6s0A           2193 	ld	a,(vrecord)
a  085C                    2194 	ld	hl,rcount
   085C BE                 2195 	cp	(hl)		;vrecord-rcount
   085D DAr62s08           2196 	jp	c,diskwr2
                           2197 				;rcount <= vrecord
   0860 77                 2198 	ld	(hl),a
   0861 34                 2199 	inc	(hl)		;rcount = vrecord+1
a  0862                    2200 	ld	c,2		;mark as record count incremented
   0862                    2201 diskwr2:			;A has vrecord, C=2 if new block or new record#
   0862 0D                 2202 	dec	c
   0863 0D                 2203 	dec	c
   0864 C2r6Ds08           2204 	jp	nz,noupdate
   0867 F5                 2205 	push	af		;save vrecord value
   0868 CDrD6s03           2206 	call	getmodnum	;HL=.fcb(modnum), A=fcb(modnum)
                           2207 				;reset the file write flag to mark as written fcb
uq 086B                    2208 	and	(not fwfmsk) and 0ffh;bit reset
   086B 77                 2209 	ld	(hl),a		;fcb(modnum) = fcb(modnum) and 7fh
   086C F1                 2210 	pop	af		;restore vrecord
   086D                    2211 noupdate:			;check for end of extent, if found attempt to open
                           2212 				;next extent in preparation for next write
ua 086D                    2213 	cp	lstrec		;vrecord=lstrec?
   086D C2r85s08           2214 	jp	nz,diskwr3	;skip if not
                           2215 				;may be random access write, if so we are done
                           2216 				;change next
   0870 3ArC6s0A           2217 	ld	a,(seqio)
a  0873                    2218 	cp	1
   0873 C2r85s08           2219 	jp	nz,diskwr3	;skip next extent open op
                           2220 				;update current fcb before going to next extent
   0876 CDr54s03           2221 	call	setfcb
   0879 CDr1Fs07           2222 	call	open$reel	;rmf=false
                           2223 				;vrecord remains at lstrec causing eof if
                           2224 				;no more directory space is available
ua 087C                    2225 	ld	hl,lret
   087C 7E                 2226 	ld	a,(hl)
   087D B7                 2227 	or	a
   087E C2r85s08           2228 	jp	nz,nospace
                           2229 				;space available, set vrecord=255
   0881 3D                 2230 	dec	a
   0882 32rC6s0A           2231 	ld	(vrecord),a	;goes to 00 next time
   0885                    2232 nospace:
a  0885                    2233 	ld	(hl),0		;lret = 00 for returned value
   0885                    2234 diskwr3:
   0885 C3r54s03           2235 	jp	setfcb		;replace parameters
                           2236 ;	ret
                           2237 
   0888                    2238 rseek:				;random access seek operation, C=0ffh if read mode
                           2239 				;fcb is assumed to address an active file control block
                           2240 				;(modnum has been set to 1100$0000b if previous bad seek)
   0888 AF                 2241 	xor	a
   0889 32rC6s0A           2242 	ld	(seqio),a	;marked as random access operation
   088C C5                 2243 rseek1:	push	bc		;save r/w flag
   088D 2ArFCs01           2244 	ld	hl,(info)
   0890 EB                 2245 	ex	de,hl		;DE will hold base of fcb
ua 0891                    2246 	ld	hl,ranrec
   0891 19                 2247 	add	hl,de		;HL=.fcb(ranrec)
   0892 7E                 2248 	ld	a,(hl)
q  0893                    2249 	and	7fh
   0893 F5                 2250 	push	af		;record number
   0894 7E                 2251 	ld	a,(hl)
   0895 17                 2252 	rla			;cy=lsb of extent#
   0896 23                 2253 	inc	hl
   0897 7E                 2254 	ld	a,(hl)
   0898 17                 2255 	rla
q  0899                    2256 	and	11111b		;A=ext#
   0899 4F                 2257 	ld	c,a		;C holds extent number, record stacked
   089A 7E                 2258 	ld	a,(hl)
   089B 1F                 2259 	rra
   089C 1F                 2260 	rra
   089D 1F                 2261 	rra
   089E 1F                 2262 	rra
q  089F                    2263 	and	1111b		;mod#
   089F 47                 2264 	ld	b,a		;B holds module#, C holds ext#
   08A0 F1                 2265 	pop	af		;recall sought record #
                           2266 				;check to insure that high byte of ran rec = 00
   08A1 23                 2267 	inc	hl
   08A2 6E                 2268 	ld	l,(hl)		;l=high byte (must be 00)
   08A3 2C                 2269 	inc	l
   08A4 2D                 2270 	dec	l
a  08A5                    2271 	ld	l,6		;zero flag, l=6
                           2272 				;produce error 6, seek past physical eod
   08A5 C2rECs08           2273 	jp	nz,seekerr
                           2274 				;otherwise, high byte = 0, A = sought record
ua 08A8                    2275 	ld	hl,nxtrec
   08A8 19                 2276 	add	hl,de		;HL = .fcb(nxtrec)
   08A9 77                 2277 	ld	(hl),a		;sought rec# stored away
                           2278 				;arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
                           2279 				;the r/w flag is still stacked.  compare fcb values
ua 08AA                    2280 	ld	hl,extnum
   08AA 19                 2281 	add	hl,de
   08AB 79                 2282 	ld	a,c		;A=seek ext#
   08AC 96                 2283 	sub	(hl)
   08AD C2rB6s08           2284 	jp	nz,ranclose	;tests for = extents
                           2285 				;extents match, check mod#
ua 08B0                    2286 	ld	hl,modnum
   08B0 19                 2287 	add	hl,de
   08B1 78                 2288 	ld	a,b		;B=seek mod#
                           2289 				;could be overflow at eof, producing module#
                           2290 				;of 90H or 10H, so compare all but fwf
   08B2 96                 2291 	sub	(hl)
q  08B3                    2292 	and	7fh
   08B3 CArE2s08           2293 	jp	z,seekok	;same?
   08B6                    2294 ranclose:
   08B6 C5                 2295 	push	bc
   08B7 D5                 2296 	push	de		;save seek mod#,ext#, .fcb
   08B8 CDr88s06           2297 	call	close		;current extent closed
   08BB D1                 2298 	pop	de
   08BC C1                 2299 	pop	bc		;recall parameters and fill
a  08BD                    2300 	ld	l,3		;cannot close error #3
u  08BD 3A 00 00           2301 	ld	a,(lret)
   08C0 3C                 2302 	inc	a
   08C1 CArE7s08           2303 	jp	z,badseek
ua 08C4                    2304 	ld	hl,extnum
   08C4 19                 2305 	add	hl,de
   08C5 71                 2306 	ld	(hl),c		;fcb(extnum)=ext#
ua 08C6                    2307 	ld	hl,modnum
   08C6 19                 2308 	add	hl,de
   08C7 70                 2309 	ld	(hl),b		;fcb(modnum)=mod#
   08C8 CDr48s06           2310 	call	open		;is the file present?
u  08CB 3A 00 00           2311 	ld	a,(lret)
   08CE 3C                 2312 	inc	a
   08CF C2rE2s08           2313 	jp	nz,seekok	;open successful?
                           2314 				;cannot open the file, read mode?
   08D2 C1                 2315 	pop	bc		;r/w flag to c (=0ffh if read)
   08D3 C5                 2316 	push	bc		;everyone expects this item stacked
a  08D4                    2317 	ld	l,4		;seek to unwritten extent #4
   08D4 0C                 2318 	inc	c		;becomes 00 if read operation
   08D5 CArE7s08           2319 	jp	z,badseek	;skip to error if read operation
                           2320 				;write operation, make new extent
   08D8 CDrF6s06           2321 	call	make
a  08DB                    2322 	ld	l,5		;cannot create new extent #5
u  08DB 3A 00 00           2323 	ld	a,(lret)
   08DE 3C                 2324 	inc	a
   08DF CArE7s08           2325 	jp	z,badseek	;no dir space
                           2326 				;file make operation successful
   08E2                    2327 seekok:
   08E2 C1                 2328 	pop	bc		;discard r/w flag
   08E3 AF                 2329 	xor	a
   08E4 C3rF5s01           2330 	jp	sta$ret		;with zero set
   08E7                    2331 badseek:			;fcb no longer contains a valid fcb, mark
                           2332 				;with 1100$000b in modnum field so that it
                           2333 				;appears as overflow with file write flag set
   08E7 E5                 2334 	push	hl		;save error flag
   08E8 CDrD6s03           2335 	call	getmodnum	;HL = .modnum
ao 08EB                    2336 	ld	(hl),11000000b
   08EB E1                 2337 	pop	hl		;and drop through
   08EC                    2338 seekerr:
   08EC C1                 2339 	pop	bc		;discard r/w flag
   08ED 7D                 2340 	ld	a,l
u  08EE 32 00 00           2341 	ld	(lret),a	;lret=#, nonzero
                           2342 				;setfwf returns non-zero accumulator for err
   08F1 C3rE0s03           2343 	jp	setfwf		;flag set, so subsequent close ok
                           2344 ;	ret
                           2345 
   08F4                    2346 randiskread:			;random disk read operation
ua 08F4                    2347 	ld	c,true		;marked as read operation
   08F4 CDr88s08           2348 	call	rseek
   08F7 CCr75s07           2349 	call	z,diskread	;if seek successful
   08FA C9                 2350 	ret
                           2351 
   08FB                    2352 randiskwrite:			;random disk write operation
ua 08FB                    2353 	ld	c,false		;marked as write operation
   08FB CDr88s08           2354 	call	rseek
   08FE CCrAEs07           2355 	call	z,diskwrite	;if seek successful
   0901 C9                 2356 	ret
                           2357 
   0902                    2358 compute$rr:			;compute random record position for getfilesize/setrandom
   0902 EB                 2359 	ex	de,hl
   0903 19                 2360 	add	hl,de
                           2361 				;DE=.buf(dptr) or .fcb(0), HL = .f(nxtrec/reccnt)
   0904 4E                 2362 	ld	c,(hl)
a  0905                    2363 	ld	b,0		;BC = 0000 0000 ?rrr rrrr
ua 0905                    2364 	ld	hl,extnum
   0905 19                 2365 	add	hl,de
   0906 7E                 2366 	ld	a,(hl)
   0907 0F                 2367 	rrca
q  0908                    2368 	and	80h		;A=e000 0000
   0908 81                 2369 	add	a,c
   0909 4F                 2370 	ld	c,a
a  090A                    2371 	ld	a,0
   090A 88                 2372 	adc	a,b
   090B 47                 2373 	ld	b,a
                           2374 				;BC = 0000 000? errrr rrrr
   090C 7E                 2375 	ld	a,(hl)
   090D 0F                 2376 	rrca
q  090E                    2377 	and	0fh
   090E 80                 2378 	add	a,b
   090F 47                 2379 	ld	b,a
                           2380 				;BC = 000? eeee errrr rrrr
ua 0910                    2381 	ld	hl,modnum
   0910 19                 2382 	add	hl,de
   0911 7E                 2383 	ld	a,(hl)		;A=XXX? mmmm
   0912 87                 2384 	add	a,a
   0913 87                 2385 	add	a,a
   0914 87                 2386 	add	a,a
   0915 87                 2387 	add	a,a		;cy=? A=mmmm 0000
   0916 F5                 2388 	push	af
   0917 80                 2389 	add	a,b
   0918 47                 2390 	ld	b,a
                           2391 				;cy=?, BC = mmmm eeee errr rrrr
   0919 F5                 2392 	push	af		;possible second carry
   091A E1                 2393 	pop	hl		;cy = lsb of L
   091B 7D                 2394 	ld	a,l		;cy = lsb of A
   091C E1                 2395 	pop	hl		;cy = lsb of L
   091D B5                 2396 	or	l		;cy/cy = lsb of A
a  091E                    2397 	and	1		;A = 0000 000? possible carry-out
   091E C9                 2398 	ret
                           2399 
   091F                    2400 getfilesize:			;compute logical file size for current fcb
ua 091F                    2401 	ld	c,extnum
   091F CDr47s05           2402 	call	search
                           2403 				;zero the receiving ranrec field
   0922 2ArFCs01           2404 	ld	hl,(info)
ua 0925                    2405 	ld	de,ranrec
   0925 19                 2406 	add	hl,de
   0926 E5                 2407 	push	hl		;save position
   0927 72                 2408 	ld	(hl),d
   0928 23                 2409 	inc	hl
   0929 72                 2410 	ld	(hl),d
   092A 23                 2411 	inc	hl
   092B 72                 2412 	ld	(hl),d		;=00 00 00
   092C                    2413 getsize:
   092C CDr4Fs04           2414 	call	end$of$dir
   092F CAr51s09           2415 	jp	z,setsize
                           2416 				;current fcb addressed by dptr
   0932 CDrCBs03           2417 	call	getdptra
ua 0935                    2418 	ld	de,reccnt	;ready for compute size
   0935 CDr02s09           2419 	call	compute$rr
                           2420 				;A=0000 000? BC = mmmm eeee errr rrrr
                           2421 				;compare with memory, larger?
   0938 E1                 2422 	pop	hl
   0939 E5                 2423 	push	hl		;recall, replace .fcb(ranrec)
   093A 5F                 2424 	ld	e,a		;save cy
   093B 79                 2425 	ld	a,c
   093C 96                 2426 	sub	(hl)
   093D 23                 2427 	inc	hl		;ls byte
   093E 78                 2428 	ld	a,b
   093F 9E                 2429 	sbc	a,(hl)
   0940 23                 2430 	inc	hl		;middle byte
   0941 7B                 2431 	ld	a,e
   0942 9E                 2432 	sbc	a,(hl)		;carry if .fcb(ranrec) > directory
   0943 DAr4Bs09           2433 	jp	c,getnextsize	;for another try
                           2434 				;fcb is less or equal, fill from directory
   0946 73                 2435 	ld	(hl),e
   0947 2B                 2436 	dec	hl
   0948 70                 2437 	ld	(hl),b
   0949 2B                 2438 	dec	hl
   094A 71                 2439 	ld	(hl),c
   094B                    2440 getnextsize:
   094B CDr57s05           2441 	call	searchn
   094E C3r2Cs09           2442 	jp	getsize
                           2443 
   0951                    2444 setsize:
   0951 E1                 2445 	pop	hl		;discard .fcb(ranrec)
   0952 C9                 2446 	ret
                           2447 
   0953                    2448 setrandom:			;set random record from the current file control block
   0953 2ArFCs01           2449 	ld	hl,(info)
ua 0956                    2450 	ld	de,nxtrec	;ready params for computesize
   0956 CDr02s09           2451 	call	compute$rr	;DE=info, A=cy, BC=mmmm eeee errr rrrr
ua 0959                    2452 	ld	hl,ranrec
   0959 19                 2453 	add	hl,de		;HL = .fcb(ranrec)
   095A 71                 2454 	ld	(hl),c
   095B 23                 2455 	inc	hl
   095C 70                 2456 	ld	(hl),b
   095D 23                 2457 	inc	hl
   095E 77                 2458 	ld	(hl),a		;to ranrec
   095F C9                 2459 	ret
                           2460 
   0960                    2461 select:				;select disk info for subsequent input or output ops
   0960 2ArC6s0A           2462 	ld	hl,(dlog)
   0963 3ArFCs01           2463 	ld	a,(curdsk)
   0966 4F                 2464 	ld	c,a
   0967 CDr6As03           2465 	call	hlrotr
   096A E5                 2466 	push	hl
   096B EB                 2467 	ex	de,hl		;save it for test below, send to seldsk
   096C CDr0Bs02           2468 	call	selectdisk
   096F E1                 2469 	pop	hl		;recall dlog vector
   0970 CCrFCs01           2470 	call	z,sel$error	;returns true if select ok
                           2471 				;is the disk logged in?
   0973 7D                 2472 	ld	a,l
   0974 1F                 2473 	rra
   0975 D8                 2474 	ret	c		;return if bit is set
                           2475 				;disk not logged in, set bit and initialize
   0976 2ArC6s0A           2476 	ld	hl,(dlog)
   0979 4D                 2477 	ld	c,l
   097A 44                 2478 	ld	b,h		;call ready
   097B CDr89s03           2479 	call	set$cdisk
   097E 22rC6s0A           2480 	ld	(dlog),hl	;dlog=set$cdisk(dlog)
   0981 C3rE4s04           2481 	jp	initialize
                           2482 ;	ret
                           2483 
   0984                    2484 curselect:
   0984 3ArC6s0A           2485 	ld	a,(linfo)
a  0987                    2486 	ld	hl,curdsk
   0987 BE                 2487 	cp	(hl)
   0988 C8                 2488 	ret	z		;skip if linfo=curdsk
   0989 77                 2489 	ld	(hl),a		;curdsk=info
   098A C3r60s09           2490 	jp	select
                           2491 ;	ret
                           2492 
   098D                    2493 reselect:			;check current fcb to see if reselection necessary
ua 098D                    2494 	ld	a,true
   098D 32rC6s0A           2495 	ld	(resel),a	;mark possible reselect
   0990 2ArFCs01           2496 	ld	hl,(info)
   0993 7E                 2497 	ld	a,(hl)		;drive select code
q  0994                    2498 	and	11111b		;non zero is auto drive select
   0994 3D                 2499 	dec	a		;drive code normalized to 0..30, or 255
   0995 32rC6s0A           2500 	ld	(linfo),a	;save drive code
a  0998                    2501 	cp	30
   0998 D2rA9s09           2502 	jp	nc,noselect
                           2503 				;auto select function, save curdsk
   099B 3ArFCs01           2504 	ld	a,(curdsk)
   099E 32rC6s0A           2505 	ld	(olddsk),a	;olddsk=curdsk
   09A1 7E                 2506 	ld	a,(hl)
   09A2 32rC6s0A           2507 	ld	(fcbdsk),a	;save drive code
q  09A5                    2508 	and	11100000b
   09A5 77                 2509 	ld	(hl),a		;preserve hi bits
   09A6 CDr84s09           2510 	call	curselect
   09A9                    2511 noselect:			;set user code
   09A9 3ArFCs01           2512 	ld	a,(usrcode)	;0...31
   09AC 2ArFCs01           2513 	ld	hl,(info)
   09AF B6                 2514 	or	(hl)
   09B0 77                 2515 	ld	(hl),a
   09B1 C9                 2516 	ret
                           2517 
                           2518 ;	individual function handlers
   09B2                    2519 func12:				;return version number
ua 09B2                    2520 	ld	a,dvers
   09B2 C3rF5s01           2521 	jp	sta$ret		;lret = dvers (high = 00)
                           2522 ;	ret
                           2523 ;	jp	goback
                           2524 
   09B5                    2525 func13:				;reset disk system - initialize to disk 0
a  09B5                    2526 	ld	hl,0
   09B5 22rC6s0A           2527 	ld	(rodsk),hl
   09B8 22rC6s0A           2528 	ld	(dlog),hl
   09BB AF                 2529 	xor	a
   09BC 32rFCs01           2530 	ld	(curdsk),a	;note that usrcode remains unchanged
ua 09BF                    2531 	ld	hl,tbuff
   09BF 22rC6s0A           2532 	ld	(dmaad),hl	;dmaad = tbuff
   09C2 CDr3Cs04           2533 	call	setdata		;to data dma address
   09C5 C3r60s09           2534 	jp	select
                           2535 ;	ret
                           2536 ;	jp	goback
                           2537 
o  09C8                    2538 func14	equ	curselect	;select disk info
                           2539 ;	ret
                           2540 ;	jp	goback
                           2541 
   09C8                    2542 func15:				;open file
   09C8 CDrDCs03           2543 	call	clrmodnum	;clear the module number
   09CB CDr8Ds09           2544 	call	reselect
   09CE C3r48s06           2545 	jp	open
                           2546 ;	ret
                           2547 ;	jp	goback
                           2548 
   09D1                    2549 func16:				;close file
   09D1 CDr8Ds09           2550 	call	reselect
   09D4 C3r88s06           2551 	jp	close
                           2552 ;	ret
                           2553 ;	jp	goback
                           2554 
   09D7                    2555 func17:				;search for first occurrence of a file
a  09D7                    2556 	ld	c,0		;length assuming '?' true
   09D7 EB                 2557 	ex	de,hl		;was lhld info
   09D8 7E                 2558 	ld	a,(hl)
q  09D9                    2559 	cp	'?'		;no reselect if ?
   09D9 CArE6s09           2560 	jp	z,qselect	;skip reselect if so
                           2561 				;normal search
   09DC CDr31s03           2562 	call	getexta
   09DF 7E                 2563 	ld	a,(hl)
q  09E0                    2564 	cp	'?'		;
   09E0 C4rDCs03           2565 	call	nz,clrmodnum	;module number zeroed
   09E3 CDr8Ds09           2566 	call	reselect
ua 09E6                    2567 	ld	c,namlen
   09E6                    2568 qselect:
   09E6 CDr47s05           2569 	call	search
   09E9 C3r45s04           2570 	jp	dir$to$user	;copy directory entry to user
                           2571 ;	ret
                           2572 ;	jp	goback
                           2573 
   09EC                    2574 func18:				;search for next occurrence of a file name
   09EC 2ArC6s0A           2575 	ld	hl,(searcha)
   09EF 22rFCs01           2576 	ld	(info),hl
   09F2 CDr8Ds09           2577 	call	reselect
   09F5 CDr57s05           2578 	call	searchn
   09F8 C3r45s04           2579 	jp	dir$to$user	;copy directory entry to user
                           2580 ;	ret
                           2581 ;	jp	goback
                           2582 
   09FB                    2583 func19:				;delete a file
   09FB CDr8Ds09           2584 	call	reselect
   09FE CDrB1s05           2585 	call	delete
   0A01 C3r32s05           2586 	jp	copy$dirloc
                           2587 ;	ret
                           2588 ;	jp	goback
                           2589 
   0A04                    2590 func20:				;read a file
   0A04 CDr8Ds09           2591 	call	reselect
   0A07 C3r72s07           2592 	jp	seqdiskread
                           2593 ;	jp	goback
                           2594 
   0A0A                    2595 func21:				;write a file
   0A0A CDr8Ds09           2596 	call	reselect
   0A0D C3rABs07           2597 	jp	seqdiskwrite
                           2598 ;	jp	goback
                           2599 
   0A10                    2600 func22:				;make a file
   0A10 CDrDCs03           2601 	call	clrmodnum
   0A13 CDr8Ds09           2602 	call	reselect
   0A16 C3rF6s06           2603 	jp	make
                           2604 ;	ret
                           2605 ;	jp	goback
                           2606 
   0A19                    2607 func23:				;rename a file
   0A19 CDr8Ds09           2608 	call	reselect
   0A1C CDr1Cs06           2609 	call	rename
   0A1F C3r32s05           2610 	jp	copy$dirloc
                           2611 ;	ret
                           2612 ;	jp	goback
                           2613 
   0A22                    2614 func24:				;return the login vector
   0A22 2ArC6s0A           2615 	ld	hl,(dlog)
   0A25 C3r4Ds0A           2616 	jp	sthl$ret
                           2617 ;	ret
                           2618 ;	jp	goback
                           2619 
   0A28                    2620 func25:				;return selected disk number
   0A28 3ArFCs01           2621 	ld	a,(curdsk)
   0A2B C3rF5s01           2622 	jp	sta$ret
                           2623 ;	ret
                           2624 ;	jp	goback
                           2625 
   0A2E                    2626 func26:				;set the subsequent dma address to info
   0A2E EB                 2627 	ex	de,hl		;was lhld info
   0A2F 22rC6s0A           2628 	ld	(dmaad),hl	;dmaad = info
   0A32 C3r3Cs04           2629 	jp	setdata		;to data dma address
                           2630 ;	ret
                           2631 ;	jp	goback
                           2632 
   0A35                    2633 func27:				;return the login vector address
   0A35 2ArC6s0A           2634 	ld	hl,(alloca)
   0A38 C3r4Ds0A           2635 	jp	sthl$ret
                           2636 ;	ret
                           2637 ;	jp	goback
                           2638 
o  0A3B                    2639 func28	equ	set$ro
                           2640 				;write protect current disk
                           2641 ;	ret
                           2642 ;	jp	goback
                           2643 
   0A3B                    2644 func29:				;return r/o bit vector
   0A3B 2ArC6s0A           2645 	ld	hl,(rodsk)
   0A3E C3r4Ds0A           2646 	jp	sthl$ret
                           2647 ;	ret
                           2648 ;	jp	goback
                           2649 
   0A41                    2650 func30:				;set file indicators
   0A41 CDr8Ds09           2651 	call	reselect
   0A44 CDr38s06           2652 	call	indicators
   0A47 C3r32s05           2653 	jp	copy$dirloc	;lret=dirloc
                           2654 ;	ret
                           2655 ;	jp	goback
                           2656 
   0A4A                    2657 func31:				;return address of disk parameter block
   0A4A 2ArC6s0A           2658 	ld	hl,(dpbaddr)
   0A4D                    2659 sthl$ret:
   0A4D 22rFCs01           2660 	ld	(aret),hl
   0A50 C9                 2661 	ret
                           2662 ;	jp	goback
                           2663 
   0A51                    2664 func32:				;set user code
   0A51 3ArC6s0A           2665 	ld	a,(linfo)
q  0A54                    2666 	cp	0ffh
   0A54 C2r5Ds0A           2667 	jp	nz,setusrcode
                           2668 				;interrogate user code instead
   0A57 3ArFCs01           2669 	ld	a,(usrcode)
   0A5A C3rF5s01           2670 	jp	sta$ret		;lret=usrcode
                           2671 ;	ret
                           2672 ;	jp	goback
                           2673 
   0A5D                    2674 setusrcode:
q  0A5D                    2675 	and	1fh
   0A5D 32rFCs01           2676 	ld	(usrcode),a
   0A60 C9                 2677 	ret
                           2678 ;	jp	goback
                           2679 
   0A61                    2680 func33:				;random disk read operation
   0A61 CDr8Ds09           2681 	call	reselect
   0A64 C3rF4s08           2682 	jp	randiskread	;to perform the disk read
                           2683 ;	ret
                           2684 ;	jp	goback
                           2685 
   0A67                    2686 func34:				;random disk write operation
   0A67 CDr8Ds09           2687 	call	reselect
   0A6A C3rFBs08           2688 	jp	randiskwrite	;to perform the disk write
                           2689 ;	ret
                           2690 ;	jp	goback
                           2691 
   0A6D                    2692 func35:				;return file size (0-65536)
   0A6D CDr8Ds09           2693 	call	reselect
   0A70 C3r1Fs09           2694 	jp	getfilesize
                           2695 ;	ret
                           2696 ;	jp	goback
                           2697 
o  0A73                    2698 func36	equ	setrandom	;set random record
                           2699 ;	ret
                           2700 ;	jp	goback
                           2701 
   0A73 2ArFCs01           2702 func37:	ld	hl,(info)
   0A76 7D                 2703 	ld	a,l
   0A77 2F                 2704 	cpl
   0A78 5F                 2705 	ld	e,a
   0A79 7C                 2706 	ld	a,h
   0A7A 2F                 2707 	cpl
   0A7B 2ArC6s0A           2708 	ld	hl,(dlog)
   0A7E A4                 2709 	and	h
   0A7F 57                 2710 	ld	d,a
   0A80 7D                 2711 	ld	a,l
   0A81 A3                 2712 	and	e
   0A82 5F                 2713 	ld	e,a
   0A83 2ArC6s0A           2714 	ld	hl,(rodsk)
   0A86 EB                 2715 	ex	de,hl
   0A87 22rC6s0A           2716 	ld	(dlog),hl
   0A8A 7D                 2717 	ld	a,l
   0A8B A3                 2718 	and	e
   0A8C 6F                 2719 	ld	l,a
   0A8D 7C                 2720 	ld	a,h
   0A8E A2                 2721 	and	d
   0A8F 67                 2722 	ld	h,a
   0A90 22rC6s0A           2723 	ld	(rodsk),hl
   0A93 C9                 2724 	ret
                           2725 
   0A94                    2726 goback:				;arrive here at end of processing to return to user
   0A94 3ArC6s0A           2727 	ld	a,(resel)
   0A97 B7                 2728 	or	a
   0A98 CArAFs0A           2729 	jp	z,retmon
                           2730 				;reselection may have taken place
   0A9B 2ArFCs01           2731 	ld	hl,(info)
a  0A9E                    2732 	ld	(hl),0		;fcb(0)=0
   0A9E 3ArC6s0A           2733 	ld	a,(fcbdsk)
   0AA1 B7                 2734 	or	a
   0AA2 CArAFs0A           2735 	jp	z,retmon
                           2736 				;restore disk number
   0AA5 77                 2737 	ld	(hl),a		;fcb(0)=fcbdsk
   0AA6 3ArC6s0A           2738 	ld	a,(olddsk)
   0AA9 32rC6s0A           2739 	ld	(linfo),a
   0AAC CDr84s09           2740 	call	curselect
                           2741 
                           2742 ;	return from the disk monitor
   0AAF 2ArFCs01           2743 retmon:	ld	hl,(entsp)
   0AB2 F9                 2744 	ld	sp,hl		;user stack restored
   0AB3 2ArFCs01           2745 	ld	hl,(aret)
   0AB6 7D                 2746 	ld	a,l
   0AB7 44                 2747 	ld	b,h		;BA = HL = aret
   0AB8 C9                 2748 	ret
                           2749 
o  0AB9                    2750 func38	equ	func$ret
o  0AB9                    2751 func39	equ	func$ret
   0AB9                    2752 func40:				;random disk write with zero fill of unallocated block
   0AB9 CDr8Ds09           2753 	call	reselect
a  0ABC                    2754 	ld	a,2
   0ABC 32rC6s0A           2755 	ld	(seqio),a
ua 0ABF                    2756 	ld	c,false
   0ABF CDr8Cs08           2757 	call	rseek1
   0AC2 CCrAEs07           2758 	call	z,diskwrite	;if seek successful
   0AC5 C9                 2759 	ret
                           2760 
                           2761 ;	data areas
                           2762 
                           2763 ;	initialized data
o  0AC6                    2764 efcb:	db	empty		;0e5=available dir entry
o  0AC6                    2765 rodsk:	dw	0		;read only disk vector
o  0AC6                    2766 dlog:	dw	0		;logged-in disks
o  0AC6                    2767 dmaad:	dw	tbuff		;initial dma address
                           2768 
                           2769 ;	curtrka - alloca are set upon disk select
                           2770 ;	(data must be adjacent, do not insert variables)
                           2771 ;	(address of translate vector, not used)
   0AC6                    2772 cdrmaxa:
o  0AC6                    2773 	ds	word		;pointer to cur dir max value
   0AC6                    2774 curtrka:
o  0AC6                    2775 	ds	word		;current track address
   0AC6                    2776 curreca:
o  0AC6                    2777 	ds	word		;current record address
o  0AC6                    2778 buffa:	ds	word		;pointer to directory dma address
   0AC6                    2779 dpbaddr:
o  0AC6                    2780 	ds	word		;current disk parameter block address
o  0AC6                    2781 checka:	ds	word		;current checksum vector address
o  0AC6                    2782 alloca:	ds	word		;current allocation vector address
o  0AC6                    2783 addlist	equ	$-buffa		;address list size
                           2784 
                           2785 ;	sectpt - offset obtained from disk parm block at dpbaddr
                           2786 ;	(data must be adjacent, do not insert variables)
o  0AC6                    2787 sectpt:	ds	word		;sectors per track
o  0AC6                    2788 blkshf:	ds	byte		;block shift factor
o  0AC6                    2789 blkmsk:	ds	byte		;block mask
o  0AC6                    2790 extmsk:	ds	byte		;extent mask
o  0AC6                    2791 maxall:	ds	word		;maximum allocation number
o  0AC6                    2792 dirmax:	ds	word		;largest directory number
o  0AC6                    2793 dirblk:	ds	word		;reserved allocation bits for directory
o  0AC6                    2794 chksiz:	ds	word		;size of checksum vector
o  0AC6                    2795 offset:	ds	word		;offset tracks at beginning
o  0AC6                    2796 dpblist	equ	$-sectpt	;size of area
                           2797 
                           2798 ;	local variables
o  0AC6                    2799 tranv:	ds	word		;address of translate vector
   0AC6                    2800 fcb$copied:
o  0AC6                    2801 	ds	byte		;set true if copy$fcb called
o  0AC6                    2802 rmf:	ds	byte		;read mode flag for open$reel
o  0AC6                    2803 dirloc:	ds	byte		;directory flag in rename, etc.
o  0AC6                    2804 seqio:	ds	byte		;1 if sequential i/o
o  0AC6                    2805 linfo:	ds	byte		;low(info)
o  0AC6                    2806 dminx:	ds	byte		;local for diskwrite
   0AC6                    2807 searchl:
o  0AC6                    2808 	ds	byte		;search length
   0AC6                    2809 searcha:
o  0AC6                    2810 	ds	word		;search address
o  0AC6                    2811 tinfo:	ds	word		;temp for info in "make"
o  0AC6                    2812 single:	ds	byte		;set true if single byte allocation map
o  0AC6                    2813 resel:	ds	byte		;reselection flag
o  0AC6                    2814 olddsk:	ds	byte		;disk on entry to bdos
o  0AC6                    2815 fcbdsk:	ds	byte		;disk named in fcb
o  0AC6                    2816 rcount:	ds	byte		;record count in current fcb
o  0AC6                    2817 extval:	ds	byte		;extent number and extmsk
   0AC6                    2818 vrecord:
o  0AC6                    2819 	ds	word		;current virtual record
   0AC6                    2820 arecord:
o  0AC6                    2821 	ds	word		;current actual record
   0AC6                    2822 arecord1:
o  0AC6                    2823 	ds	word		;current actual block# * blkmsk
                           2824 
                           2825 ;	local variables for directory access
o  0AC6                    2826 dptr:	ds	byte		;directory pointer 0,1,2,3
o  0AC6                    2827 dcnt:	ds	word		;directory counter 0,1,...,dirmax
o  0AC6                    2828 drec:	ds	word		;directory record 0,1,...,dirmax/4
                           2829 
                           2830 ;bios	equ	($ and 0ff00h)+100h;next module
                           2831 
                           2832 ;;dwg;;	end
                           2833 
                           2834 ;; dwg ; end dri source code here
                           2835 
   0AC6                    2836 _bdos_end::
                           2837 	.area _CODE
                           2838 	.area _CABS
