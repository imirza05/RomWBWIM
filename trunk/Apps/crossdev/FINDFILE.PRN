                ; findfile.asm 7/21/2012 dwg - added keystroke scan terminate
                ; findfile.asm 7/19/2012 dwg - for 2.0.0.0 B22
                ; findfile.asm 2/20.2012 dwg - add RESET$DISK before exit for ZDOS
                ; findfile.asm 2/17/2012 dwg - review for release 1.5.1.0
                ; findfile.asm 2/11/2012 dwg - make ident compliant
                ; findfile.asm 1/30/2012 dwg - use new do$start and do$end macros
                ; findfile.asm 1/22/2012 dwg - find a file on any slice
                
                ; Copyright (C) 2011-2012 Douglas Goodall Licensed under GPL Ver 3.
                ;
                ; This file is part of NuBiosDWG and is free software: you can
                ; redistribute it and/or modify it under the terms of the GNU
                ; General Public License as published by the Free Software Foundation,
                ; either version 3 of the License, or (at your option) any later version.
                ; This file is distributed in the hope that it will be useful,
                ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                ; GNU General Public License for more details.
                ; You should have received a copy of the GNU General Public License
                ; along with it.  If not, see <http://www.gnu.org/licenses/>.
                
                	maclib	portab
                	maclib	globals
                	maclib	stdlib
                	maclib	cpmbios
                	maclib	cpmbdos
                	maclib	bioshdr
                	maclib	printers
                	maclib	banner
                	maclib	terminal
                	maclib	applvers
                	maclib	version
                ;	maclib	ffhaslu
                ;	maclib	ffnumlu
                ;	maclib	ffsetlu
                ;	maclib	ffgetlu
                ;	maclib	z80
                ;	maclib	memory
                ;	maclib	cpmappl
                ;	maclib	identity
                
                ; identity.lib 2/19/2012 dwg - add ify macro
                ; identity.lib 2/17/2012 dwg - Program Identity Declarations
                
                	extrn	x$ident
                
                ident	macro	file1fcb
                	lxi	h,file1fcb
                	call	x$ident
                	endm
                
                ify	macro	progname,bool
                	local	done
                	local	file
                	local	fini
                	ident	file
                	jmp	fini
                	newfcb	file,0,progname
                fini:	mvi	a,bool
                	cpi	TRUE
                	jnz	done
                	conout	CR
                	conout	LF
                done:	
                	endm
                
                
                identx	macro	file1fcb
                	local	openok
                	local	identend
                
                	local	ldrive,lcolon,lname,ldot,lext,lterm
                
                	mvi	c,FOPEN
                	lxi	d,file1fcb
                	call	BDOS
                	cpi	255
                	jnz	openok
                
                	memcpy	lname,file1fcb+1,8
                	mvi	a,','
                	sta	ldot
                	memcpy	lext,file1fcb+9,3
                	mvi	a,'$'
                	sta	lterm
                	print	lname
                	printf	' -- File Not Found'
                	jmp	identend
                openok:
                
                	mvi	c,SETDMA
                	lxi	d,buffer
                	call	BDOS
                
                	mvi	c,READSEQ
                	lxi	d,file1fcb
                	call	BDOS
                
                	mvi	c,FCLOSE
                	lxi	d,file1fcb
                	call	BDOS
                
                	lxi	d,d$prog
                	mvi	c,9
                	call	BDOS
                
                	conout	','
                	conout	' '
                	lda	p$rmj
                	mov	l,a
                	mvi	h,0
                	call	pr$d$word
                	conout	'.'
                	lda	p$rmn
                	mov	l,a
                	call	pr$d$word
                	conout	'.'
                	lda	p$rup
                	mov	l,a
                	call	pr$d$word
                	conout	'.'
                	lda	p$rtp
                	mov	l,a
                	call	pr$d$word
                	conout	','
                	conout	' '
                
                	lda	p$mon
                	mov	l,a
                	call	pr$d$word
                	conout	'/'
                	lda	p$day
                	mov	l,a
                	call	pr$d$word
                	conout	'/'
                	lhld	p$year
                	call	pr$d$word
                	conout	','
                	conout	' '
                
                	lxi	d,d$prod
                	mvi	c,9
                	call	BDOS
                	conout	','
                	conout	' '
                
                	lxi	d,d$orig
                	mvi	c,9
                	call	BDOS
                	conout	','
                	conout	' '
                
                	lxi	d,d$ser
                	mvi	c,9
                	call	BDOS
                	conout	','
                	conout 	' '
                
                	lxi	d,d$name
                	mvi	c,9
                	call	BDOS
                	jmp	identend
                
                ldrive	ds	1
                lcolon	ds	1
                lname	ds	8
                ldot	ds	1
                lext	ds	3
                lterm	ds	1
                
                identend:
                	endm
                
                idata	macro
                	jmp	around$bandata
                argv	dw	prog,dat,prod,orig,ser,myname,0
                prog	db	'IDENT.COM   $'
                	date
                	serial
                	product
                	originator
                	oriname
                uuid	db	'777A67C2-4A92-42D4-80FE-C96FD6483BD2$'
                	db	'buffer-->'
                	public	buffer,p$start,p$hexrf,p$sig
                	public	p$rmj,p$rmn,p$rup,p$rtp
                	public	p$mon,p$day,p$year
                buffer	ds	1
                p$start	ds	2
                p$hexrf	ds	16
                p$sig	ds	2
                p$rmj	ds	1
                p$rmn	ds	1
                p$rup	ds	1
                p$rtp	ds	1
                p$mon	ds	1
                p$day	ds	1
                p$year	ds	2
                p$argv	ds	2
                p$e5	ds	1
                p$pr$st	ds	2
                p$code1	ds	3		; begin: lxi h,0
                p$code2	ds	1		;   dad sp
                p$code3	ds	3		;   shld pre$stk
                p$code4	ds	3		;    lxi sp,stack$top
                p$code5	ds	1		;    nop
                p$code6	ds	3		;    jmp around$bandata
                p$prog	ds	2		;   dw prog
                p$dat	ds	2		;   dw dat
                p$prod	ds	2		;   dw prod
                p$orig	ds	2		;   dw orig
                p$ser	ds	2		;   dw ser
                p$nam	ds	2		;   dw nam
                p$term	ds	2		;   dw 0
                d$prog	ds	8+1+3+1		;   db '12345678.123$'
                d$date	ds	2+1+2+1+4+1	;   db ' 2/11/2012$'
                d$ser	ds	6+1		;   db '654321$'
                d$prod	ds	5+1		;   db 'CPM80$'
                d$orig	ds	3+1		;   db 'DWG$'
                d$name	ds	1+7+1+1+1+1+7+1	;   db ' Douglas W. Goodall$'
                d$uuid	ds	37		; unique user identification
                d$term2	ds	1		; can be set to zero or dollar sign
                p$len	equ	$-buffer
                p$rsvd	ds	128-p$len
                	db	'<--buffer'
                crlf	db	CR,LF,'$'
                around$bandata:
                
                	endm
                
                ; eof - identity.lib
                
                
                
                ; cpmappl.lib 2/10/2012 dwg - begin 1.6 development
                ; cpmappl.lib 2/04/2012 dwg - fix typo mov becomes mvi
                ; cpmappl.lib 2/ 2/2012 dwg - initial version
                 
                ;
                ; Copyright (C) 2011-2012 Douglas Goodall Licensed under GPL Ver 3.
                ;
                ; This file is part of NuBiosDWG and is free software: you can
                ; redistribute it and/or modify it under the terms of the GNU
                ; General Public License as published by the Free Software Foundation,
                ; either version 3 of the License, or (at your option) any later version.
                ; This file is distributed in the hope that it will be useful,
                ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                ; GNU General Public License for more details.
                ; You should have received a copy of the GNU General Public License
                ; along with it.  If not, see <http://www.gnu.org/licenses/>.
                ;
                
                do$start	macro
                
                start:	jmp	begin
                
                	public	hexref
                hexref	db	'0123456789ABCDEF'
                
                	public	id$sig,id$rmj,id$rmn,id$rup,id$rtp,id$mon,id$day,id$yr
                id$sig	db	'ID'
                id$rmj	db	A$RMJ
                id$rmn	db	A$RMN
                id$rup	db	A$RUP
                id$rtp	db	A$RTP
                id$mon	db	A$MONTH
                id$day	db	A$DAY
                id$yr	dw	A$YEAR
                id$argv	dw	argv
                	db	0e5h
                
                
                	public	pre$stk
                pre$stk	ds	2
                
                	public	begin
                begin:	lxi	h,0
                	dad	sp
                	shld	pre$stk
                	lxi	sp,stack$top
                	nop
                	endm
                
                
                ;---------------------------------
                
                
                do$end	macro
                	lhld	pre$stk
                	sphl
                
                	mvi	c,13
                	call	BDOS
                
                	ret
                	ds	stack$size
                stack$top:
                
                	endm
                
                movfcb	macro	destn,source
                	lxi d,destn
                	lxi h,source
                	lxi b,LENFCB
                	ldir
                	endm
                
                copyfcb	macro	fcbname,source
                	local	around
                	jmp	around
                fcbname	ds	32
                around:
                	endm
                
                
                ; memory.lib 2/17/2012 dwg - review for release 1.5.1.0
                ; memory.lib 2/11/2012 dwg - review for release 1.5
                ; memory.lib 2/04/2012 dwg - adjust for new macros
                ; memory.lib 1/13/2012 dwg - POSIX memcpy and memset
                
                	extrn	x$memcpy
                	extrn	x$memset
                
                memcpy	macro	dst,src,siz
                	lxi	d,dst		; load 1st positional parameter into reg
                	lxi	h,src		; load 2nd positional parameter into reg
                	lxi	b,siz		; load 3rd positional parameter into reg
                	call	x$memcpy	; call actual routine in see memory.asm
                	endm
                
                memset	macro	dst,data,siz
                	lxi	h,dst		; load 1st positional parameter into reg
                	mvi	a,data		; load 2nd positional parameter into reg
                	lxi	b,siz		; load 3rd positional parameter into reg
                	call	x$memset	; call actual routine in see memory.asm
                	endm
                
                ; eof - memory.lib
                
                
                ;	@CHK MACRO USED FOR CHECKING 8 BIT DISPLACMENTS
                ;
                @CHK	MACRO	?DD	;; USED FOR CHECKING RANGE OF 8-BIT DISP.S
                	IF (?DD GT 7FH) AND (?DD LT 0FF80H)
                 'DISPLACEMENT RANGE ERROR - Z80 LIB'
                	ENDIF
                	ENDM
                LDX	MACRO	?R,?D	
                	@CHK	?D
                	DB	0DDH,?R*8+46H,?D
                	ENDM
                LDY	MACRO	?R,?D	
                	@CHK	?D
                	DB	0FDH,?R*8+46H,?D
                	ENDM
                STX	MACRO	?R,?D	
                	@CHK	?D
                	DB	0DDH,70H+?R,?D
                	ENDM
                STY	MACRO	?R,?D	
                	@CHK	?D
                	DB	0FDH,70H+?R,?D
                	ENDM
                MVIX	MACRO	?N,?D	
                	@CHK	?D
                	DB	0DDH,36H,?D,?N
                	ENDM
                MVIY	MACRO	?N,?D	
                	@CHK	?D
                	DB	0FDH,36H,?D,?N
                	ENDM
                LDAI	MACRO		
                	DB	0EDH,57H
                	ENDM
                LDAR	MACRO		
                	DB	0EDH,5FH
                	ENDM
                STAI	MACRO		
                	DB	0EDH,47H
                	ENDM
                STAR	MACRO		
                	DB	0EDH,4FH
                	ENDM
                
                LXIX	MACRO	?NNNN	
                	DB	0DDH,21H
                	DW	?NNNN
                	ENDM
                LXIY	MACRO	?NNNN	
                	DB	0FDH,21H
                	DW	?NNNN
                	ENDM
                LDED	MACRO	?NNNN	
                	DB	0EDH,5BH
                	DW	?NNNN
                	ENDM
                LBCD	MACRO	?NNNN	
                	DB	0EDH,4BH
                	DW	?NNNN
                	ENDM
                LSPD	MACRO	?NNNN	
                	DB	0EDH,07BH
                	DW	?NNNN
                	ENDM
                LIXD	MACRO	?NNNN	
                	DB	0DDH,2AH
                	DW	?NNNN
                	ENDM
                LIYD	MACRO	?NNNN	
                	DB	0FDH,2AH
                	DW	?NNNN
                	ENDM
                SBCD	MACRO	?NNNN	
                	DB	0EDH,43H
                	DW	?NNNN
                	ENDM
                SDED	MACRO	?NNNN	
                	DB	0EDH,53H
                	DW	?NNNN
                	ENDM
                SSPD	MACRO	?NNNN	
                	DB	0EDH,73H
                	DW	?NNNN
                	ENDM
                SIXD	MACRO	?NNNN	
                	DB	0DDH,22H
                	DW	?NNNN
                	ENDM
                SIYD	MACRO	?NNNN	
                	DB	0FDH,22H
                	DW	?NNNN
                	ENDM
                SPIX	MACRO		
                	DB	0DDH,0F9H
                	ENDM
                SPIY	MACRO		
                	DB	0FDH,0F9H
                	ENDM
                PUSHIX	MACRO		
                	DB	0DDH,0E5H
                	ENDM
                PUSHIY	MACRO		
                	DB	0FDH,0E5H
                	ENDM
                POPIX	MACRO		
                	DB	0DDH,0E1H
                	ENDM
                POPIY	MACRO		
                	DB	0FDH,0E1H
                	ENDM
                EXAF	MACRO		
                	DB	08H
                	ENDM
                EXX	MACRO		
                	DB	0D9H
                	ENDM
                XTIX	MACRO		
                	DB	0DDH,0E3H
                	ENDM
                XTIY	MACRO		
                	DB	0FDH,0E3H
                	ENDM
                
                LDI	MACRO		
                	DB	0EDH,0A0H
                	ENDM
                LDIR	MACRO		
                	DB	0EDH,0B0H
                	ENDM
                LDD	MACRO		
                	DB	0EDH,0A8H
                	ENDM
                LDDR	MACRO		
                	DB	0EDH,0B8H
                	ENDM
                CCI	MACRO		
                	DB	0EDH,0A1H
                	ENDM
                CCIR	MACRO		
                	DB	0EDH,0B1H
                	ENDM
                CCD	MACRO		
                	DB	0EDH,0A9H
                	ENDM
                CCDR	MACRO		
                	DB	0EDH,0B9H
                	ENDM
                
                ADDX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH,86H,?D
                	ENDM
                ADDY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH,86H,?D
                	ENDM
                ADCX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH,8EH,?D
                	ENDM
                ADCY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH,8EH,?D
                	ENDM
                SUBX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH,96H,?D
                	ENDM
                SUBY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH,96H,?D
                	ENDM
                SBCX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH,9EH,?D
                	ENDM
                SBCY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH,9EH,?D
                	ENDM
                ANDX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH,0A6H,?D
                	ENDM
                ANDY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH,0A6H,?D
                	ENDM
                XORX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH,0AEH,?D
                	ENDM
                XORY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH,0AEH,?D
                	ENDM
                ORX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH,0B6H,?D
                	ENDM
                ORY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH,0B6H,?D
                	ENDM
                CMPX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH,0BEH,?D
                	ENDM
                CMPY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH,0BEH,?D
                	ENDM
                INRX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH,34H,?D
                	ENDM
                INRY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH,34H,?D
                	ENDM
                DCRX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH,035H,?D
                	ENDM
                DCRY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH,35H,?D
                	ENDM
                
                NEG	MACRO		
                	DB	0EDH,44H
                	ENDM
                IM0	MACRO		
                	DB	0EDH,46H
                	ENDM
                IM1	MACRO		
                	DB	0EDH,56H
                	ENDM
                IM2	MACRO		
                	DB	0EDH,5EH
                	ENDM
                
                
 0000 =         BC	EQU	0
 0002 =         DE	EQU	2
 0004 =         HL	EQU	4
 0004 =         IX	EQU	4	
 0004 =         IY	EQU	4	
                DADC	MACRO	?R	
                	DB	0EDH,?R*8+4AH
                	ENDM
                DSBC	MACRO	?R	
                	DB	0EDH,?R*8+42H
                	ENDM
                DADX	MACRO	?R	
                	DB	0DDH,?R*8+09H
                	ENDM
                DADY	MACRO	?R	
                	DB	0FDH,?R*8+09H
                	ENDM
                INXIX	MACRO		
                	DB	0DDH,23H
                	ENDM
                INXIY	MACRO		
                	DB	0FDH,23H
                	ENDM
                DCXIX	MACRO		
                	DB	0DDH,2BH
                	ENDM
                DCXIY	MACRO		
                	DB	0FDH,2BH
                	ENDM
                
                BIT	MACRO	?N,?R	
                	DB	0CBH,?N*8+?R+40H
                	ENDM
                SETB	MACRO	?N,?R
                	DB	0CBH,?N*8+?R+0C0H
                	ENDM
                RES	MACRO	?N,?R
                	DB	0CBH,?N*8+?R+80H
                	ENDM
                
                BITX	MACRO	?N,?D	
                	@CHK	?D
                	DB	0DDH,0CBH,?D,?N*8+46H
                	ENDM
                BITY	MACRO	?N,?D	
                	@CHK	?D
                	DB	0FDH,0CBH,?D,?N*8+46H
                	ENDM
                SETX	MACRO	?N,?D	
                	@CHK	?D
                	DB	0DDH,0CBH,?D,?N*8+0C6H
                	ENDM
                SETY	MACRO	?N,?D	
                	@CHK	?D
                	DB	0FDH,0CBH,?D,?N*8+0C6H
                	ENDM
                RESX	MACRO	?N,?D	
                	@CHK	?D
                	DB	0DDH,0CBH,?D,?N*8+86H
                	ENDM
                RESY	MACRO	?N,?D	
                	@CHK	?D
                	DB	0FDH,0CBH,?D,?N*8+86H
                	ENDM
                
                JR	MACRO	?N
                	DB	18H,?N-$-1
                	ENDM
                JRC	MACRO	?N
                	DB	38H,?N-$-1
                	ENDM
                JRNC	MACRO	?N
                	DB	30H,?N-$-1
                	ENDM
                JRZ	MACRO	?N
                	DB	28H,?N-$-1
                	ENDM
                JRNZ	MACRO	?N
                	DB	20H,?N-$-1
                	ENDM
                DJNZ	MACRO	?N
                	DB	10H,?N-$-1
                	ENDM
                
                PCIX	MACRO		
                	DB	0DDH,0E9H
                	ENDM
                PCIY	MACRO		
                	DB	0FDH,0E9H
                	ENDM
                
                RETI	MACRO		
                	DB	0EDH,4DH
                	ENDM
                RETN	MACRO		
                	DB	0EDH,45H
                	ENDM
                
                INP	MACRO	?R	
                	DB	0EDH,?R*8+40H
                	ENDM
                OUTP	MACRO	?R	
                	DB	0EDH,?R*8+41H
                	ENDM
                INI	MACRO		
                	DB	0EDH,0A2H
                	ENDM
                INIR	MACRO		
                	DB	0EDH,0B2H
                	ENDM
                IND	MACRO		
                	DB	0EDH,0AAH
                	ENDM
                INDR	MACRO		
                	DB	0EDH,0BAH
                	ENDM
                OUTI	MACRO		
                	DB	0EDH,0A3H
                	ENDM
                OUTIR	MACRO		
                	DB	0EDH,0B3H
                	ENDM
                OUTD	MACRO		
                	DB	0EDH,0ABH
                	ENDM
                OUTDR	MACRO		
                	DB	0EDH,0BBH
                	ENDM
                
                
                RLCR	MACRO	?R	
                	DB	0CBH, 00H + ?R
                	ENDM
                RLCX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH, 0CBH, ?D, 06H
                	ENDM
                RLCY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH, 0CBH, ?D, 06H
                	ENDM
                RALR	MACRO	?R	
                	DB	0CBH, 10H+?R
                	ENDM
                RALX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH, 0CBH, ?D, 16H
                	ENDM
                RALY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH, 0CBH, ?D, 16H
                	ENDM
                RRCR	MACRO	?R	
                	DB	0CBH, 08H + ?R
                	ENDM
                RRCX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH, 0CBH, ?D, 0EH
                	ENDM
                RRCY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH, 0CBH, ?D, 0EH
                	ENDM
                RARR	MACRO	?R	
                	DB	0CBH, 18H + ?R
                	ENDM
                RARX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH, 0CBH, ?D, 1EH
                	ENDM
                RARY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH, 0CBH, ?D, 1EH
                	ENDM
                SLAR	MACRO	?R	
                	DB	0CBH, 20H + ?R
                	ENDM
                SLAX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH, 0CBH, ?D, 26H
                	ENDM
                SLAY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH, 0CBH, ?D, 26H
                	ENDM
                SRAR	MACRO	?R	
                	DB	0CBH, 28H+?R
                	ENDM
                SRAX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH, 0CBH, ?D, 2EH
                	ENDM
                SRAY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH, 0CBH, ?D, 2EH
                	ENDM
                SRLR	MACRO	?R	
                	DB	0CBH, 38H + ?R
                	ENDM
                SRLX	MACRO	?D	
                	@CHK	?D
                	DB	0DDH, 0CBH, ?D, 3EH
                	ENDM
                SRLY	MACRO	?D	
                	@CHK	?D
                	DB	0FDH, 0CBH, ?D, 3EH
                	ENDM
                RLD	MACRO		
                	DB	0EDH, 6FH
                	ENDM
                RRD	MACRO		
                	DB	0EDH, 67H
                	ENDM
                
                ; ffsetlu.lib 1/24/2012 dwg - 
                ffgetlu	macro	
                	mvi	c,RETCURR
                	call	BDOS
                	mov	c,a
                	call	BISELDSK
                	lxi	d,16+2
                	dad	d
                	mov	a,m
                	endm
                ; eof - ffsetlu
                
                
                ; ffsetlu.lib 2/12/2012 dwg - review for use in superfmt
                ; ffsetlu.lib 1/24/2012 dwg - 
                
                ; enter with desired LU in A reg
                ffsetlu	macro	
                	enter
                	push	psw
                	mvi	c,RETCURR
                	call	BDOS
                	mov	c,a
                	call	BISELDSK	; uses c parameter (drive)
                	lxi	d,16+2
                	dad	d
                	pop	psw
                	mov	m,a		; put slice into CURRENT
                	mvi	c,13
                	call	BDOS
                	leave
                	endm
                
                ; eof - ffsetlu
                
                
                ; ffhaslu.lib 1/22/2012 dwg - macro to detect drive with logical unit support
                
                ffhaslu	macro	
                	local	ret$false,fini
                	mvi	c,RETCURR
                	call	BDOS
                	mov	c,a
                	call	BISELDSK
                	lxi	d,16		; offset to end of DPH
                	dad	d		; calc offset of 1st signature byte
                	mov	a,m		; pick up first sig byte which s/b 'L'
                	cpi	'L'
                	jnz	ret$false	; if it wasn't, indicate to caller no LU
                	inx	h		; bump ptr to 2nd signature byte
                	mov	a,m		; pick up second sig byte which s/b 'U'
                	cpi	'U'
                	jnz	ret$false	; if it wasn't, indicate to caller no LU
                	mvi	a,TRUE		; otherwise indicate presence of LU support
                	jmp	fini		; finish up macro
                ret$false:
                	mvi	a,FALSE		; prepare negative response for caller
                fini:
                	endm
                
                
                
                ; ffnumlu.lib 1/22/2012 dwg - macro to get number of logical units
                
                ffnumlu	macro	
                	mvi	c,RETCURR
                	call	BDOS
                	mov	c,a
                	call	BISELDSK
                	lxi	d,16+2+2	; offset to end of DPH
                	dad	d		; calc offset of 1st signature byte
                	mov	a,m
                	endm
                
                ; eof - ffnumlu.lib
                
                
                
                prfilnam	macro	fcb
                	local	fnbuf,fnext,prfnfini
                	memcpy	fnbuf,fcb+1,8
                	memcpy	fnext,fcb+9,3
                
                	lda fnext
                	ani 07fh
                	sta fnext
                
                	lda fnext+1
                	ani 07fh
                	sta fnext+1
                
                	lda fnext+2
                	ani 07fh
                	sta fnext+2
                
                	mvi	c,9
                	lxi	d,fnbuf
                	call	BDOS
                	
                	jmp	prfnfini
                
                fnbuf	db	0,0,0,0,0,0,0,0
                	db	'.'
                fnext	db	0,0,0,' $'
                prfnfini:
                	endm
                
                
                	do$start
 0000+C32200    START:	JMP	BEGIN
 0003+3031323334HEXREF	DB	'0123456789ABCDEF'
 0013+4944      ID$SIG	DB	'ID'
 0015+02        ID$RMJ	DB	A$RMJ
 0016+05        ID$RMN	DB	A$RMN
 0017+00        ID$RUP	DB	A$RUP
 0018+01        ID$RTP	DB	A$RTP
 0019+03        ID$MON	DB	A$MONTH
 001A+1F        ID$DAY	DB	A$DAY
 001B+DD07      ID$YR	DW	A$YEAR
 001D+3000      ID$ARGV	DW	ARGV
 001F+E5        	DB	0E5H
 0020+          PRE$STK	DS	2
 0022+210000    BEGIN:	LXI	H,0
 0025+39        	DAD	SP
 0026+222000    	SHLD	PRE$STK
 0029+31C006    	LXI	SP,STACK$TOP
 002C+00        	NOP
                
                
 002D C3A000    	jmp	around$bandata
 0030 3E004B005Dargv	dw	prog,dat,prod,orig,ser,myname,0
 003E 46494E4446prog	db	'FINDFILE.COM$'
                	date
 004B+20332F3331DAT	DB	' 3/31/2013$'
                	serial
 0056+3635343332SER	DB	'654321$'
                	product
 005D+43504D3830PROD	DB	'CPM80$'
                	originator
 0063+44574724  ORIG	DB	'DWG$'
                	oriname
 0067+20444F5547MYNAME	DB	' DOUGLAS W GOODALL $'
 007B 3130374344uuid	db	'107CDD27-2E4D-4340-A324-BEB13054E67B$'
                around$bandata:
                
                
                	crtinit
 00A0+F5        	PUSH PSW
 00A1+C5        	PUSH B
 00A2+D5        	PUSH D
 00A3+E5        	PUSH H
 00A4+CD0000    	CALL	XCRTINIT
 00A7+E1        	POP H
 00A8+D1        	POP D
 00A9+C1        	POP B
 00AA+F1        	POP PSW
                	crtclr
 00AB+F5        	PUSH PSW
 00AC+C5        	PUSH B
 00AD+D5        	PUSH D
 00AE+E5        	PUSH H
 00AF+CD0000    	CALL	XCRTCLR		; CALL ACTUAL ROUTINE IN TERMINAL.ASM
 00B2+E1        	POP H
 00B3+D1        	POP D
 00B4+C1        	POP B
 00B5+F1        	POP PSW
                	crtlc	1,1
 00B6+F5        	PUSH PSW
 00B7+C5        	PUSH B
 00B8+D5        	PUSH D
 00B9+E5        	PUSH H
 00BA+2601      	MVI H,1		; LOAD 1ST POSITIONAL PARAMETER INTO REG
 00BC+2E01      	MVI L,1		; LOAD 2ND POSITIONAL PARAMETER INTO REG
 00BE+CD0000    	CALL XCRTLC		; CALL ACTUAL ROUTINE IN TERMINAL.ASM
 00C1+E1        	POP H
 00C2+D1        	POP D
 00C3+C1        	POP B
 00C4+F1        	POP PSW
                	sbanner	argv
 00C5+213000    	LXI	H,ARGV
 00C8+CD0000    	CALL	X$SBANNER
                ;	version	wrnmsg,errmsg
                
 00CB 3A8000    	lda 80h
 00CE FE00      	cpi 0
 00D0 C21501    	jnz	no$usage
                	print 	crlf
 00D3+F5        	PUSH PSW
 00D4+C5        	PUSH B
 00D5+D5        	PUSH D
 00D6+E5        	PUSH H
 00D7+0E09      	MVI C,PRINTSTR
 00D9+111A07    	LXI D,CRLF
 00DC+CD0500    	CALL BDOS
 00DF+E1        	POP H
 00E0+D1        	POP D
 00E1+C1        	POP B
 00E2+F1        	POP PSW
                	printf	'usage - findfile <filename>'
 00E3+F5        	PUSH PSW
 00E4+C5        	PUSH B
 00E5+D5        	PUSH D
 00E6+E5        	PUSH H
 00E7+0E09      	MVI C,PRINTSTR
 00E9+11F600    	LXI D,??0002
 00EC+CD0500    	CALL BDOS
 00EF+E1        	POP H
 00F0+D1        	POP D
 00F1+C1        	POP B
 00F2+F1        	POP PSW
 00F3+C31201    	JMP	??0001
 00F6+7573616765??0002	DB	'usage - findfile <filename>'
 0111+24        	DB	'$'
 0112 C38E04    	jmp all$done
                no$usage:
                
                
                	memcpy	work$fcb,PRIFCB,32
 0115+112207    	LXI	D,WORK$FCB		; LOAD 1ST POSITIONAL PARAMETER INTO REG
 0118+215C00    	LXI	H,PRIFCB		; LOAD 2ND POSITIONAL PARAMETER INTO REG
 011B+012000    	LXI	B,32		; LOAD 3RD POSITIONAL PARAMETER INTO REG
 011E+CD0000    	CALL	X$MEMCPY	; CALL ACTUAL ROUTINE IN SEE MEMORY.ASM
                
                	printf	'Finding: '
 0121+F5        	PUSH PSW
 0122+C5        	PUSH B
 0123+D5        	PUSH D
 0124+E5        	PUSH H
 0125+0E09      	MVI C,PRINTSTR
 0127+113401    	LXI D,??0004
 012A+CD0500    	CALL BDOS
 012D+E1        	POP H
 012E+D1        	POP D
 012F+C1        	POP B
 0130+F1        	POP PSW
 0131+C33E01    	JMP	??0003
 0134+46696E6469??0004	DB	'Finding: '
 013D+24        	DB	'$'
                	memcpy PRIFCB,work$fcb,16
 013E+115C00    	LXI	D,PRIFCB		; LOAD 1ST POSITIONAL PARAMETER INTO REG
 0141+212207    	LXI	H,WORK$FCB		; LOAD 2ND POSITIONAL PARAMETER INTO REG
 0144+011000    	LXI	B,16		; LOAD 3RD POSITIONAL PARAMETER INTO REG
 0147+CD0000    	CALL	X$MEMCPY	; CALL ACTUAL ROUTINE IN SEE MEMORY.ASM
                
 014A 3E24      	mvi	a,'$'
 014C 326500    	sta	PRIFCB+9
                	print PRIFCB+1
 014F+F5        	PUSH PSW
 0150+C5        	PUSH B
 0151+D5        	PUSH D
 0152+E5        	PUSH H
 0153+0E09      	MVI C,PRINTSTR
 0155+115D00    	LXI D,PRIFCB+1
 0158+CD0500    	CALL BDOS
 015B+E1        	POP H
 015C+D1        	POP D
 015D+C1        	POP B
 015E+F1        	POP PSW
                	conout	'.'
 015F+F5        	PUSH PSW
 0160+C5        	PUSH B
 0161+D5        	PUSH D
 0162+E5        	PUSH H
 0163+0E02      	MVI C,CWRITE		; SET FOR CONSOLE OUTPUT BDOS CALL
 0165+1E2E      	MVI E,'.'		; PLACE OUTPUT CHARACTER IN E AS REQUIRED
 0167+CD0500    	CALL BDOS		; CALL BDOS FUNCTION ENTRY POINT
 016A+E1        	POP H
 016B+D1        	POP D
 016C+C1        	POP B
 016D+F1        	POP PSW
                	memcpy	PRIFCB,work$fcb,16
 016E+115C00    	LXI	D,PRIFCB		; LOAD 1ST POSITIONAL PARAMETER INTO REG
 0171+212207    	LXI	H,WORK$FCB		; LOAD 2ND POSITIONAL PARAMETER INTO REG
 0174+011000    	LXI	B,16		; LOAD 3RD POSITIONAL PARAMETER INTO REG
 0177+CD0000    	CALL	X$MEMCPY	; CALL ACTUAL ROUTINE IN SEE MEMORY.ASM
 017A 3E24      	mvi	a,'$'
 017C 326800    	sta	PRIFCB+12
                	print	PRIFCB+9
 017F+F5        	PUSH PSW
 0180+C5        	PUSH B
 0181+D5        	PUSH D
 0182+E5        	PUSH H
 0183+0E09      	MVI C,PRINTSTR
 0185+116500    	LXI D,PRIFCB+9
 0188+CD0500    	CALL BDOS
 018B+E1        	POP H
 018C+D1        	POP D
 018D+C1        	POP B
 018E+F1        	POP PSW
                	print	crlf
 018F+F5        	PUSH PSW
 0190+C5        	PUSH B
 0191+D5        	PUSH D
 0192+E5        	PUSH H
 0193+0E09      	MVI C,PRINTSTR
 0195+111A07    	LXI D,CRLF
 0198+CD0500    	CALL BDOS
 019B+E1        	POP H
 019C+D1        	POP D
 019D+C1        	POP B
 019E+F1        	POP PSW
                
                	ffhaslu
 019F+0E19      	MVI	C,RETCURR
 01A1+CD0500    	CALL	BDOS
 01A4+4F        	MOV	C,A
 01A5+CD1BE6    	CALL	BISELDSK
 01A8+111000    	LXI	D,16		; OFFSET TO END OF DPH
 01AB+19        	DAD	D		; CALC OFFSET OF 1ST SIGNATURE BYTE
 01AC+7E        	MOV	A,M		; PICK UP FIRST SIG BYTE WHICH S/B 'L'
 01AD+FE4C      	CPI	'L'
 01AF+C2BE01    	JNZ	RET$FALSE	; IF IT WASN'T, INDICATE TO CALLER NO LU
 01B2+23        	INX	H		; BUMP PTR TO 2ND SIGNATURE BYTE
 01B3+7E        	MOV	A,M		; PICK UP SECOND SIG BYTE WHICH S/B 'U'
 01B4+FE55      	CPI	'U'
 01B6+C2BE01    	JNZ	RET$FALSE	; IF IT WASN'T, INDICATE TO CALLER NO LU
 01B9+3E01      	MVI	A,TRUE		; OTHERWISE INDICATE PRESENCE OF LU SUPPORT
 01BB+C3C001    	JMP	??0006		; FINISH UP MACRO
 01BE+3E00      	MVI	A,FALSE		; PREPARE NEGATIVE RESPONSE FOR CALLER
 01C0 FE01      	cpi	TRUE
 01C2 CAFD01    	jz	do$lu
                	memcpy	PRIFCB,work$fcb,32
 01C5+115C00    	LXI	D,PRIFCB		; LOAD 1ST POSITIONAL PARAMETER INTO REG
 01C8+212207    	LXI	H,WORK$FCB		; LOAD 2ND POSITIONAL PARAMETER INTO REG
 01CB+012000    	LXI	B,32		; LOAD 3RD POSITIONAL PARAMETER INTO REG
 01CE+CD0000    	CALL	X$MEMCPY	; CALL ACTUAL ROUTINE IN SEE MEMORY.ASM
 01D1 0E0F      	mvi	c,FOPEN
 01D3 115C00    	lxi	d,PRIFCB
 01D6 CD0500    	call	BDOS
 01D9 FEFF      	cpi 	255
 01DB C2E101    	jnz	single$true
 01DE C38E04    	jmp	all$done
                single$true:
                	printf	'Found'
 01E1+F5        	PUSH PSW
 01E2+C5        	PUSH B
 01E3+D5        	PUSH D
 01E4+E5        	PUSH H
 01E5+0E09      	MVI C,PRINTSTR
 01E7+11F401    	LXI D,??0008
 01EA+CD0500    	CALL BDOS
 01ED+E1        	POP H
 01EE+D1        	POP D
 01EF+C1        	POP B
 01F0+F1        	POP PSW
 01F1+C3FA01    	JMP	??0007
 01F4+466F756E64??0008	DB	'Found'
 01F9+24        	DB	'$'
 01FA C38E04    	jmp all$done
                
                do$lu:
                	ffgetlu
 01FD+0E19      	MVI	C,RETCURR
 01FF+CD0500    	CALL	BDOS
 0202+4F        	MOV	C,A
 0203+CD1BE6    	CALL	BISELDSK
 0206+111200    	LXI	D,16+2
 0209+19        	DAD	D
 020A+7E        	MOV	A,M
 020B 322007    	sta	entry$lu
                	;
                	ffnumlu	
 020E+0E19      	MVI	C,RETCURR
 0210+CD0500    	CALL	BDOS
 0213+4F        	MOV	C,A
 0214+CD1BE6    	CALL	BISELDSK
 0217+111400    	LXI	D,16+2+2	; OFFSET TO END OF DPH
 021A+19        	DAD	D		; CALC OFFSET OF 1ST SIGNATURE BYTE
 021B+7E        	MOV	A,M
 021C 321E07    	sta	lu$cnt
                	;
 021F 6F        	mov	l,a
 0220 2600      	mvi	h,0
 0222 CD0000    	call	pr$d$word
                	printf	' Logical Units Detected'
 0225+F5        	PUSH PSW
 0226+C5        	PUSH B
 0227+D5        	PUSH D
 0228+E5        	PUSH H
 0229+0E09      	MVI C,PRINTSTR
 022B+113802    	LXI D,??0010
 022E+CD0500    	CALL BDOS
 0231+E1        	POP H
 0232+D1        	POP D
 0233+C1        	POP B
 0234+F1        	POP PSW
 0235+C35002    	JMP	??0009
 0238+204C6F6769??0010	DB	' Logical Units Detected'
 024F+24        	DB	'$'
                	print	crlf
 0250+F5        	PUSH PSW
 0251+C5        	PUSH B
 0252+D5        	PUSH D
 0253+E5        	PUSH H
 0254+0E09      	MVI C,PRINTSTR
 0256+111A07    	LXI D,CRLF
 0259+CD0500    	CALL BDOS
 025C+E1        	POP H
 025D+D1        	POP D
 025E+C1        	POP B
 025F+F1        	POP PSW
                
 0260 3E00      	mvi	a,0
 0262 321F07    	sta	lu$num
                loop:
                	printf	'Scanning Logical Unit '
 0265+F5        	PUSH PSW
 0266+C5        	PUSH B
 0267+D5        	PUSH D
 0268+E5        	PUSH H
 0269+0E09      	MVI C,PRINTSTR
 026B+117802    	LXI D,??0012
 026E+CD0500    	CALL BDOS
 0271+E1        	POP H
 0272+D1        	POP D
 0273+C1        	POP B
 0274+F1        	POP PSW
 0275+C38F02    	JMP	??0011
 0278+5363616E6E??0012	DB	'Scanning Logical Unit '
 028E+24        	DB	'$'
 028F 3A1F07    	lda	lu$num
 0292 6F        	mov	l,a
 0293 2600      	mvi	h,0
 0295 CD0000    	call	pr$d$word
                	conout  ' '
 0298+F5        	PUSH PSW
 0299+C5        	PUSH B
 029A+D5        	PUSH D
 029B+E5        	PUSH H
 029C+0E02      	MVI C,CWRITE		; SET FOR CONSOLE OUTPUT BDOS CALL
 029E+1E20      	MVI E,' '		; PLACE OUTPUT CHARACTER IN E AS REQUIRED
 02A0+CD0500    	CALL BDOS		; CALL BDOS FUNCTION ENTRY POINT
 02A3+E1        	POP H
 02A4+D1        	POP D
 02A5+C1        	POP B
 02A6+F1        	POP PSW
                
                	; set the Logical Unit
 02A7 3A1F07    	lda 	lu$num
                	ffsetlu
 02AA+F5        	PUSH PSW
 02AB+C5        	PUSH B
 02AC+D5        	PUSH D
 02AD+E5        	PUSH H
 02AE+F5        	PUSH	PSW
 02AF+0E19      	MVI	C,RETCURR
 02B1+CD0500    	CALL	BDOS
 02B4+4F        	MOV	C,A
 02B5+CD1BE6    	CALL	BISELDSK	; USES C PARAMETER (DRIVE)
 02B8+111200    	LXI	D,16+2
 02BB+19        	DAD	D
 02BC+F1        	POP	PSW
 02BD+77        	MOV	M,A		; PUT SLICE INTO CURRENT
 02BE+0E0D      	MVI	C,13
 02C0+CD0500    	CALL	BDOS
 02C3+E1        	POP H
 02C4+D1        	POP D
 02C5+C1        	POP B
 02C6+F1        	POP PSW
                	
                	; test for the target file
                	memcpy	PRIFCB,work$fcb,32
 02C7+115C00    	LXI	D,PRIFCB		; LOAD 1ST POSITIONAL PARAMETER INTO REG
 02CA+212207    	LXI	H,WORK$FCB		; LOAD 2ND POSITIONAL PARAMETER INTO REG
 02CD+012000    	LXI	B,32		; LOAD 3RD POSITIONAL PARAMETER INTO REG
 02D0+CD0000    	CALL	X$MEMCPY	; CALL ACTUAL ROUTINE IN SEE MEMORY.ASM
 02D3 0E0F      	mvi	c,FOPEN
 02D5 115C00    	lxi	d,PRIFCB
 02D8 CD0500    	call	BDOS
 02DB 322107    	sta	retcode
                
 02DE 3A2107    	lda	retcode
 02E1 FEFF      	cpi	255
 02E3 CAFB03    	jz	not$yet
                	conout	CR
 02E6+F5        	PUSH PSW
 02E7+C5        	PUSH B
 02E8+D5        	PUSH D
 02E9+E5        	PUSH H
 02EA+0E02      	MVI C,CWRITE		; SET FOR CONSOLE OUTPUT BDOS CALL
 02EC+1E0D      	MVI E,CR		; PLACE OUTPUT CHARACTER IN E AS REQUIRED
 02EE+CD0500    	CALL BDOS		; CALL BDOS FUNCTION ENTRY POINT
 02F1+E1        	POP H
 02F2+D1        	POP D
 02F3+C1        	POP B
 02F4+F1        	POP PSW
                	prfilnam PRIFCB
 02F5+113003    	LXI	D,??0013		; LOAD 1ST POSITIONAL PARAMETER INTO REG
 02F8+215D00    	LXI	H,PRIFCB+1		; LOAD 2ND POSITIONAL PARAMETER INTO REG
 02FB+010800    	LXI	B,8		; LOAD 3RD POSITIONAL PARAMETER INTO REG
 02FE+CD0000    	CALL	X$MEMCPY	; CALL ACTUAL ROUTINE IN SEE MEMORY.ASM
 0301+113903    	LXI	D,??0014		; LOAD 1ST POSITIONAL PARAMETER INTO REG
 0304+216500    	LXI	H,PRIFCB+9		; LOAD 2ND POSITIONAL PARAMETER INTO REG
 0307+010300    	LXI	B,3		; LOAD 3RD POSITIONAL PARAMETER INTO REG
 030A+CD0000    	CALL	X$MEMCPY	; CALL ACTUAL ROUTINE IN SEE MEMORY.ASM
 030D+3A3903    	LDA ??0014
 0310+E67F      	ANI 07FH
 0312+323903    	STA ??0014
 0315+3A3A03    	LDA ??0014+1
 0318+E67F      	ANI 07FH
 031A+323A03    	STA ??0014+1
 031D+3A3B03    	LDA ??0014+2
 0320+E67F      	ANI 07FH
 0322+323B03    	STA ??0014+2
 0325+0E09      	MVI	C,9
 0327+113003    	LXI	D,??0013
 032A+CD0500    	CALL	BDOS
 032D+C33E03    	JMP	??0015
 0330+0000000000??0013	DB	0,0,0,0,0,0,0,0
 0338+2E        	DB	'.'
 0339+0000002024??0014	DB	0,0,0,' $'
                	printf	' '
 033E+F5        	PUSH PSW
 033F+C5        	PUSH B
 0340+D5        	PUSH D
 0341+E5        	PUSH H
 0342+0E09      	MVI C,PRINTSTR
 0344+115103    	LXI D,??0017
 0347+CD0500    	CALL BDOS
 034A+E1        	POP H
 034B+D1        	POP D
 034C+C1        	POP B
 034D+F1        	POP PSW
 034E+C35303    	JMP	??0016
 0351+20        ??0017	DB	' '
 0352+24        	DB	'$'
                	printf	'Found on Logical Unit '
 0353+F5        	PUSH PSW
 0354+C5        	PUSH B
 0355+D5        	PUSH D
 0356+E5        	PUSH H
 0357+0E09      	MVI C,PRINTSTR
 0359+116603    	LXI D,??0019
 035C+CD0500    	CALL BDOS
 035F+E1        	POP H
 0360+D1        	POP D
 0361+C1        	POP B
 0362+F1        	POP PSW
 0363+C37D03    	JMP	??0018
 0366+466F756E64??0019	DB	'Found on Logical Unit '
 037C+24        	DB	'$'
 037D 3A1F07    	lda	lu$num
 0380 6F        	mov	l,a
 0381 2600      	mvi	h,0
 0383 CD0000    	call	pr$d$word
                	conout	','
 0386+F5        	PUSH PSW
 0387+C5        	PUSH B
 0388+D5        	PUSH D
 0389+E5        	PUSH H
 038A+0E02      	MVI C,CWRITE		; SET FOR CONSOLE OUTPUT BDOS CALL
 038C+1E2C      	MVI E,','		; PLACE OUTPUT CHARACTER IN E AS REQUIRED
 038E+CD0500    	CALL BDOS		; CALL BDOS FUNCTION ENTRY POINT
 0391+E1        	POP H
 0392+D1        	POP D
 0393+C1        	POP B
 0394+F1        	POP PSW
                	conout	'('
 0395+F5        	PUSH PSW
 0396+C5        	PUSH B
 0397+D5        	PUSH D
 0398+E5        	PUSH H
 0399+0E02      	MVI C,CWRITE		; SET FOR CONSOLE OUTPUT BDOS CALL
 039B+1E28      	MVI E,'('		; PLACE OUTPUT CHARACTER IN E AS REQUIRED
 039D+CD0500    	CALL BDOS		; CALL BDOS FUNCTION ENTRY POINT
 03A0+E1        	POP H
 03A1+D1        	POP D
 03A2+C1        	POP B
 03A3+F1        	POP PSW
 03A4 3A1D07    	lda	drv$num
 03A7 4F        	mov	c,a
 03A8 CD1BE6    	call	BISELDSK
 03AB 010000    	lxi	b,0
 03AE CD1EE6    	call	BISETTRK
 03B1 010B00    	lxi	b,11
 03B4 CD21E6    	call	BISETSEC
 03B7 016207    	lxi	b,buffer
 03BA CD24E6    	call	BISETDMA
 03BD CD27E6    	call	BIREAD
                
 03C0 3E24      	mvi	a,'$'
 03C2 32D907    	sta	buffer+128-8-1
                	print	buffer+128-8-1-16
 03C5+F5        	PUSH PSW
 03C6+C5        	PUSH B
 03C7+D5        	PUSH D
 03C8+E5        	PUSH H
 03C9+0E09      	MVI C,PRINTSTR
 03CB+11C907    	LXI D,BUFFER+128-8-1-16
 03CE+CD0500    	CALL BDOS
 03D1+E1        	POP H
 03D2+D1        	POP D
 03D3+C1        	POP B
 03D4+F1        	POP PSW
                	conout	')'
 03D5+F5        	PUSH PSW
 03D6+C5        	PUSH B
 03D7+D5        	PUSH D
 03D8+E5        	PUSH H
 03D9+0E02      	MVI C,CWRITE		; SET FOR CONSOLE OUTPUT BDOS CALL
 03DB+1E29      	MVI E,')'		; PLACE OUTPUT CHARACTER IN E AS REQUIRED
 03DD+CD0500    	CALL BDOS		; CALL BDOS FUNCTION ENTRY POINT
 03E0+E1        	POP H
 03E1+D1        	POP D
 03E2+C1        	POP B
 03E3+F1        	POP PSW
                
 03E4 0E10      	mvi	c,FCLOSE
 03E6 115C00    	lxi	d,PRIFCB
 03E9 CD0500    	call	BDOS
                	conout	LF
 03EC+F5        	PUSH PSW
 03ED+C5        	PUSH B
 03EE+D5        	PUSH D
 03EF+E5        	PUSH H
 03F0+0E02      	MVI C,CWRITE		; SET FOR CONSOLE OUTPUT BDOS CALL
 03F2+1E0A      	MVI E,LF		; PLACE OUTPUT CHARACTER IN E AS REQUIRED
 03F4+CD0500    	CALL BDOS		; CALL BDOS FUNCTION ENTRY POINT
 03F7+E1        	POP H
 03F8+D1        	POP D
 03F9+C1        	POP B
 03FA+F1        	POP PSW
                not$yet:
                	conout	CR
 03FB+F5        	PUSH PSW
 03FC+C5        	PUSH B
 03FD+D5        	PUSH D
 03FE+E5        	PUSH H
 03FF+0E02      	MVI C,CWRITE		; SET FOR CONSOLE OUTPUT BDOS CALL
 0401+1E0D      	MVI E,CR		; PLACE OUTPUT CHARACTER IN E AS REQUIRED
 0403+CD0500    	CALL BDOS		; CALL BDOS FUNCTION ENTRY POINT
 0406+E1        	POP H
 0407+D1        	POP D
 0408+C1        	POP B
 0409+F1        	POP PSW
                
                	; Check for key hit interrupt scan
 040A 0E0B      	mvi	c,11		; get console status
 040C CD0500    	caLL	BDOS
 040F FE00      	cpi	0
 0411 CA1704    	jz	nyok		; jump if no key hit
 0414 C34D04    	jmp	abort		; gracefully exit loop
                nyok:
                
                
 0417 3A1F07    	lda	lu$num
 041A 3C        	inr	a
 041B 321F07    	sta	lu$num
                	;
 041E 3A1E07    	lda	lu$cnt
 0421 3D        	dcr	a
 0422 321E07    	sta	lu$cnt
 0425 FE00      	cpi	0
 0427 C26502    	jnz	loop
                
                	printf	'               '
 042A+F5        	PUSH PSW
 042B+C5        	PUSH B
 042C+D5        	PUSH D
 042D+E5        	PUSH H
 042E+0E09      	MVI C,PRINTSTR
 0430+113D04    	LXI D,??0021
 0433+CD0500    	CALL BDOS
 0436+E1        	POP H
 0437+D1        	POP D
 0438+C1        	POP B
 0439+F1        	POP PSW
 043A+C34D04    	JMP	??0020
 043D+2020202020??0021	DB	'               '
 044C+24        	DB	'$'
                
                abort:	conout	cr
 044D+F5        	PUSH PSW
 044E+C5        	PUSH B
 044F+D5        	PUSH D
 0450+E5        	PUSH H
 0451+0E02      	MVI C,CWRITE		; SET FOR CONSOLE OUTPUT BDOS CALL
 0453+1E0D      	MVI E,CR		; PLACE OUTPUT CHARACTER IN E AS REQUIRED
 0455+CD0500    	CALL BDOS		; CALL BDOS FUNCTION ENTRY POINT
 0458+E1        	POP H
 0459+D1        	POP D
 045A+C1        	POP B
 045B+F1        	POP PSW
                	printf	'Scan Completed                '
 045C+F5        	PUSH PSW
 045D+C5        	PUSH B
 045E+D5        	PUSH D
 045F+E5        	PUSH H
 0460+0E09      	MVI C,PRINTSTR
 0462+116F04    	LXI D,??0023
 0465+CD0500    	CALL BDOS
 0468+E1        	POP H
 0469+D1        	POP D
 046A+C1        	POP B
 046B+F1        	POP PSW
 046C+C38E04    	JMP	??0022
 046F+5363616E20??0023	DB	'Scan Completed                '
 048D+24        	DB	'$'
                
                all$done:
 048E 3A2007    	lda entry$lu
                	ffsetlu
 0491+F5        	PUSH PSW
 0492+C5        	PUSH B
 0493+D5        	PUSH D
 0494+E5        	PUSH H
 0495+F5        	PUSH	PSW
 0496+0E19      	MVI	C,RETCURR
 0498+CD0500    	CALL	BDOS
 049B+4F        	MOV	C,A
 049C+CD1BE6    	CALL	BISELDSK	; USES C PARAMETER (DRIVE)
 049F+111200    	LXI	D,16+2
 04A2+19        	DAD	D
 04A3+F1        	POP	PSW
 04A4+77        	MOV	M,A		; PUT SLICE INTO CURRENT
 04A5+0E0D      	MVI	C,13
 04A7+CD0500    	CALL	BDOS
 04AA+E1        	POP H
 04AB+D1        	POP D
 04AC+C1        	POP B
 04AD+F1        	POP PSW
                
 04AE 0E25      	mvi	c,RESET$DRIVE	; call to logout drive
 04B0 11FF00    	lxi	d,0ffh
 04B3 CD0500    	call	BDOS
                
                	do$end
 04B6+2A2000    	LHLD	PRE$STK
 04B9+F9        	SPHL
 04BA+0E0D      	MVI	C,13
 04BC+CD0500    	CALL	BDOS
 04BF+C9        	RET
 04C0+          	DS	STACK$SIZE
                
                
 06C0 4279207468wrnmsg	db	'By the way, this program is newer than the BIOS$'
                
 06F0 536F727279errmsg	db	'Sorry, this program requires a newer BIOS$'
                
 071A 0D0A      crlf	db	CR,LF
 071C 24        term	db	'$'
                
 071D           drv$num	ds	1	; drive code of current drive
 071E           lu$cnt	ds	1	; number of slices on drive
 071F           lu$num	ds	1	; slice index
 0720           entry$lu ds	1
 0721           retcode	ds	1
                
 0722           work$fcb	ds	64
 0762           buffer		ds	80h
                
                
 07E2           	end	start
